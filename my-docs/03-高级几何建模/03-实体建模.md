# 实体建模

3D实体是网格生成的基础，Gmsh提供多种创建实体的方法。

## 基本实体 (Primitives)

### 立方体/长方体 (Box)

```python
import gmsh
import math

gmsh.initialize()
gmsh.model.add("solids")

# addBox(x, y, z, dx, dy, dz)
# (x, y, z): 起点坐标
# (dx, dy, dz): 三个方向的尺寸

# 单位立方体
cube = gmsh.model.occ.addBox(0, 0, 0, 1, 1, 1)

# 长方体
box = gmsh.model.occ.addBox(2, 0, 0, 2, 1, 0.5)

gmsh.model.occ.synchronize()
gmsh.finalize()
```

### 球体 (Sphere)

```python
# addSphere(xc, yc, zc, radius, angle1=-pi/2, angle2=pi/2, angle3=2*pi)
# 可以创建完整球体或部分球体

# 完整球体
sphere = gmsh.model.occ.addSphere(0, 0, 0, 1)

# 半球（angle1控制纬度下限，angle2控制纬度上限）
hemisphere = gmsh.model.occ.addSphere(3, 0, 0, 1, angle1=0, angle2=math.pi/2)

# 球楔（angle3控制经度范围）
wedge = gmsh.model.occ.addSphere(6, 0, 0, 1, angle3=math.pi/2)
```

### 圆柱体 (Cylinder)

```python
# addCylinder(x, y, z, dx, dy, dz, r, angle=2*pi)
# (x, y, z): 底面圆心
# (dx, dy, dz): 轴向向量
# r: 半径
# angle: 圆周角度

# 完整圆柱
cylinder = gmsh.model.occ.addCylinder(0, 0, 0, 0, 0, 2, 0.5)

# 半圆柱
half_cyl = gmsh.model.occ.addCylinder(3, 0, 0, 0, 0, 2, 0.5, angle=math.pi)

# 斜向圆柱
tilted_cyl = gmsh.model.occ.addCylinder(6, 0, 0, 1, 1, 2, 0.3)
```

### 圆锥体 (Cone)

```python
# addCone(x, y, z, dx, dy, dz, r1, r2, angle=2*pi)
# r1: 底面半径
# r2: 顶面半径（为0时是尖锥）

# 完整圆锥
cone = gmsh.model.occ.addCone(0, 0, 0, 0, 0, 2, 1, 0)

# 截锥（圆台）
frustum = gmsh.model.occ.addCone(3, 0, 0, 0, 0, 2, 1, 0.5)

# 倒圆锥
inv_cone = gmsh.model.occ.addCone(6, 0, 0, 0, 0, 2, 0.3, 1)
```

### 圆环体 (Torus)

```python
# addTorus(x, y, z, r1, r2, angle=-1)
# (x, y, z): 圆环中心
# r1: 主半径（圆环中心到管道中心的距离）
# r2: 管道半径
# angle: 圆周角度（-1表示完整圆环）

# 完整圆环
torus = gmsh.model.occ.addTorus(0, 0, 0, 1, 0.3)

# 部分圆环
partial_torus = gmsh.model.occ.addTorus(4, 0, 0, 1, 0.3, angle=math.pi)
```

### 楔形体 (Wedge)

```python
# addWedge(x, y, z, dx, dy, dz, ltx=0)
# 创建楔形体（棱柱的一半）
# ltx: 顶面在X方向的偏移

wedge = gmsh.model.occ.addWedge(0, 0, 0, 2, 1, 1)

# 带偏移的楔形
wedge_offset = gmsh.model.occ.addWedge(3, 0, 0, 2, 1, 1, ltx=0.5)
```

## 拉伸实体 (Extrusion)

### 线性拉伸

```python
# extrude(dimTags, dx, dy, dz, numElements=[], heights=[], recombine=False)

# 创建截面
circle = gmsh.model.occ.addCircle(0, 0, 0, 1)
loop = gmsh.model.occ.addCurveLoop([circle])
disk = gmsh.model.occ.addPlaneSurface([loop])

# 拉伸
result = gmsh.model.occ.extrude([(2, disk)], 0, 0, 3)

# result是一个列表，包含：
# - 生成的体积
# - 拉伸产生的侧面
# - 拉伸产生的顶面
```

### 分层拉伸

```python
# 指定分层数和高度比例
result = gmsh.model.occ.extrude(
    [(2, disk)],
    0, 0, 3,
    numElements=[5, 10, 5],      # 每层的元素数
    heights=[0.2, 0.6, 0.2]     # 每层的高度比例（总和为1）
)
```

### 拉伸曲线

```python
# 拉伸曲线生成曲面
line = gmsh.model.occ.addLine(
    gmsh.model.occ.addPoint(0, 0, 0),
    gmsh.model.occ.addPoint(1, 0, 0)
)

# 拉伸曲线
surface = gmsh.model.occ.extrude([(1, line)], 0, 1, 0)
```

## 旋转实体 (Revolution)

### 基本旋转

```python
# revolve(dimTags, x, y, z, ax, ay, az, angle, numElements=[], heights=[], recombine=False)
# (x, y, z): 旋转轴上的一点
# (ax, ay, az): 旋转轴方向

# 创建截面
p1 = gmsh.model.occ.addPoint(1, 0, 0)
p2 = gmsh.model.occ.addPoint(2, 0, 0)
p3 = gmsh.model.occ.addPoint(2, 0, 1)
p4 = gmsh.model.occ.addPoint(1, 0, 1)

l1 = gmsh.model.occ.addLine(p1, p2)
l2 = gmsh.model.occ.addLine(p2, p3)
l3 = gmsh.model.occ.addLine(p3, p4)
l4 = gmsh.model.occ.addLine(p4, p1)

loop = gmsh.model.occ.addCurveLoop([l1, l2, l3, l4])
profile = gmsh.model.occ.addPlaneSurface([loop])

# 绕Z轴旋转360度
result = gmsh.model.occ.revolve(
    [(2, profile)],
    0, 0, 0,      # 旋转轴经过原点
    0, 0, 1,      # 旋转轴方向为Z轴
    2 * math.pi   # 旋转360度
)
```

### 部分旋转

```python
# 旋转90度
result = gmsh.model.occ.revolve(
    [(2, profile)],
    0, 0, 0,
    0, 0, 1,
    math.pi / 2
)
```

### 创建旋转体

```python
#!/usr/bin/env python3
"""
创建花瓶形状的旋转体
"""
import gmsh
import math

gmsh.initialize()
gmsh.model.add("vase")

# 花瓶轮廓点（r, z坐标）
profile_points = [
    (0.3, 0),
    (0.5, 0.5),
    (0.4, 1.0),
    (0.3, 1.5),
    (0.4, 2.0),
    (0.6, 2.5),
    (0.5, 3.0),
    (0.2, 3.5),
]

# 创建点
pts = []
for r, z in profile_points:
    pts.append(gmsh.model.occ.addPoint(r, 0, z))

# 创建样条曲线
spline = gmsh.model.occ.addSpline(pts)

# 闭合轮廓
axis_bottom = gmsh.model.occ.addPoint(0, 0, 0)
axis_top = gmsh.model.occ.addPoint(0, 0, 3.5)

bottom_line = gmsh.model.occ.addLine(pts[0], axis_bottom)
top_line = gmsh.model.occ.addLine(pts[-1], axis_top)
axis_line = gmsh.model.occ.addLine(axis_top, axis_bottom)

loop = gmsh.model.occ.addCurveLoop([spline, top_line, axis_line, bottom_line])
profile = gmsh.model.occ.addPlaneSurface([loop])

# 旋转360度
gmsh.model.occ.revolve([(2, profile)], 0, 0, 0, 0, 0, 1, 2*math.pi)

gmsh.model.occ.synchronize()
gmsh.model.mesh.generate(3)
gmsh.write("vase.msh")
gmsh.finalize()
```

## 放样实体 (Loft / ThruSections)

### 基本放样

```python
# addThruSections(wireTags, makeSolid=True, makeRuled=False, maxDegree=-1)

# 创建多个截面
wires = []

# 底部截面：圆形
c1 = gmsh.model.occ.addCircle(0, 0, 0, 1)
wires.append(gmsh.model.occ.addWire([c1]))

# 中间截面：方形
p1 = gmsh.model.occ.addPoint(-0.7, -0.7, 1)
p2 = gmsh.model.occ.addPoint(0.7, -0.7, 1)
p3 = gmsh.model.occ.addPoint(0.7, 0.7, 1)
p4 = gmsh.model.occ.addPoint(-0.7, 0.7, 1)
l1 = gmsh.model.occ.addLine(p1, p2)
l2 = gmsh.model.occ.addLine(p2, p3)
l3 = gmsh.model.occ.addLine(p3, p4)
l4 = gmsh.model.occ.addLine(p4, p1)
wires.append(gmsh.model.occ.addWire([l1, l2, l3, l4]))

# 顶部截面：小圆
c2 = gmsh.model.occ.addCircle(0, 0, 2, 0.5)
wires.append(gmsh.model.occ.addWire([c2]))

# 创建放样实体
solid = gmsh.model.occ.addThruSections(wires, makeSolid=True)
```

### 规则放样

```python
# makeRuled=True 创建直纹面连接的实体
solid = gmsh.model.occ.addThruSections(wires, makeSolid=True, makeRuled=True)
```

### 机翼放样

```python
#!/usr/bin/env python3
"""
使用放样创建机翼
"""
import gmsh
import math

def create_airfoil(x, y, z, chord, thickness, angle=0):
    """创建NACA 0012翼型截面"""
    n_points = 30
    points = []

    # NACA 0012公式
    def naca(x_c):
        t = thickness
        return 5*t*(0.2969*math.sqrt(x_c) - 0.1260*x_c -
                   0.3516*x_c**2 + 0.2843*x_c**3 - 0.1015*x_c**4)

    # 上表面
    for i in range(n_points + 1):
        x_c = (1 - math.cos(i * math.pi / n_points)) / 2
        y_c = naca(x_c)
        # 旋转和平移
        xp = x + chord * x_c * math.cos(angle) - chord * y_c * math.sin(angle)
        yp = y
        zp = z + chord * x_c * math.sin(angle) + chord * y_c * math.cos(angle)
        points.append(gmsh.model.occ.addPoint(xp, yp, zp))

    # 下表面（反向）
    for i in range(n_points - 1, 0, -1):
        x_c = (1 - math.cos(i * math.pi / n_points)) / 2
        y_c = -naca(x_c)
        xp = x + chord * x_c * math.cos(angle) - chord * y_c * math.sin(angle)
        yp = y
        zp = z + chord * x_c * math.sin(angle) + chord * y_c * math.cos(angle)
        points.append(gmsh.model.occ.addPoint(xp, yp, zp))

    # 闭合
    points.append(points[0])

    spline = gmsh.model.occ.addSpline(points)
    return gmsh.model.occ.addWire([spline])

gmsh.initialize()
gmsh.model.add("wing")

# 创建多个翼型截面
wires = []
y_positions = [0, 2, 4, 6]
chords = [1.0, 0.9, 0.7, 0.4]
angles = [0, 0.02, 0.04, 0.06]  # 扭转角

for y, chord, angle in zip(y_positions, chords, angles):
    wire = create_airfoil(0, y, 0, chord, 0.12, angle)
    wires.append(wire)

# 创建机翼实体
wing = gmsh.model.occ.addThruSections(wires, makeSolid=True)

gmsh.model.occ.synchronize()
gmsh.option.setNumber("Mesh.MeshSizeMax", 0.2)
gmsh.model.mesh.generate(3)
gmsh.write("wing.msh")
gmsh.finalize()
```

## 管道实体 (Pipe)

### 沿路径扫掠

```python
# addPipe(dimTags, wireTag, trihedron="")
# trihedron: 截面方向控制方法
#   "": 自动
#   "DiscreteTrihedron": 离散
#   "CorrectedFrenetTrihedron": 修正的Frenet标架
#   "FixedTrihedron": 固定方向

# 创建路径
path_points = [
    gmsh.model.occ.addPoint(0, 0, 0),
    gmsh.model.occ.addPoint(1, 0, 0.5),
    gmsh.model.occ.addPoint(2, 0.5, 1),
    gmsh.model.occ.addPoint(3, 1, 1),
]
path = gmsh.model.occ.addSpline(path_points)
path_wire = gmsh.model.occ.addWire([path])

# 创建截面（在路径起点）
section = gmsh.model.occ.addDisk(0, 0, 0, 0.2, 0.2)

# 扫掠
pipe = gmsh.model.occ.addPipe([(2, section)], path_wire)
```

### 螺旋管道

```python
#!/usr/bin/env python3
"""
创建螺旋管道（弹簧）
"""
import gmsh
import math

gmsh.initialize()
gmsh.model.add("spring")

# 螺旋参数
radius = 1.0      # 螺旋半径
pitch = 0.3       # 螺距
turns = 5         # 圈数
wire_radius = 0.05  # 线材半径
n_points = turns * 30

# 创建螺旋路径
path_points = []
for i in range(n_points):
    t = 2 * math.pi * turns * i / (n_points - 1)
    x = radius * math.cos(t)
    y = radius * math.sin(t)
    z = pitch * t / (2 * math.pi)
    path_points.append(gmsh.model.occ.addPoint(x, y, z))

path = gmsh.model.occ.addSpline(path_points)
path_wire = gmsh.model.occ.addWire([path])

# 创建截面
section = gmsh.model.occ.addDisk(radius, 0, 0, wire_radius, wire_radius,
                                  nx=0, ny=-1, nz=0)

# 扫掠
spring = gmsh.model.occ.addPipe([(2, section)], path_wire,
                                 trihedron="CorrectedFrenetTrihedron")

gmsh.model.occ.synchronize()
gmsh.option.setNumber("Mesh.MeshSizeMax", 0.05)
gmsh.model.mesh.generate(3)
gmsh.write("spring.msh")
gmsh.finalize()
```

## 倒角和圆角 (Chamfer & Fillet)

### 圆角 (Fillet)

```python
# fillet(volumeTags, curveTags, radii, removeVolume=True)

# 创建一个立方体
box = gmsh.model.occ.addBox(0, 0, 0, 1, 1, 1)
gmsh.model.occ.synchronize()

# 获取所有边
edges = gmsh.model.getBoundary([(3, box)], combined=False,
                                oriented=False, recursive=True)
edge_tags = [e[1] for e in edges if e[0] == 1]

# 对所有边进行圆角处理
filleted = gmsh.model.occ.fillet([box], edge_tags, [0.1])
```

### 选择性圆角

```python
# 只对部分边进行圆角
# 需要先识别要处理的边

box = gmsh.model.occ.addBox(0, 0, 0, 2, 1, 1)
gmsh.model.occ.synchronize()

# 获取边界信息
edges = gmsh.model.getBoundary([(3, box)], combined=False,
                                oriented=False, recursive=True)

# 选择顶部的边（z=1的边）
top_edges = []
for e in edges:
    if e[0] == 1:
        bbox = gmsh.model.occ.getBoundingBox(1, e[1])
        if bbox[2] > 0.9 and bbox[5] > 0.9:  # z_min和z_max都接近1
            top_edges.append(e[1])

# 只对顶部边圆角
if top_edges:
    gmsh.model.occ.fillet([box], top_edges, [0.1])
```

### 变半径圆角

```python
# 可以为不同的边指定不同的圆角半径
edge_tags = [e1, e2, e3, e4]
radii = [0.1, 0.2, 0.1, 0.2]  # 每条边的圆角半径

filleted = gmsh.model.occ.fillet([box], edge_tags, radii)
```

### 倒角 (Chamfer)

```python
# chamfer(volumeTags, curveTags, surfaceTags, distances, removeVolume=True)
# 需要指定边和相邻的面

box = gmsh.model.occ.addBox(0, 0, 0, 1, 1, 1)
gmsh.model.occ.synchronize()

# 获取边和面
edges = gmsh.model.getEntities(1)
faces = gmsh.model.getEntities(2)

# 选择边和相邻面
edge_tags = [edges[0][1]]
face_tags = [faces[0][1]]  # 相邻面

chamfered = gmsh.model.occ.chamfer([box], edge_tags, face_tags, [0.1])
```

## 壳体和偏移 (Shell & Offset)

### 抽壳 (Shell)

```python
# 将实体转换为薄壁壳体
# removeVolume后创建新的薄壁体

box = gmsh.model.occ.addBox(0, 0, 0, 2, 1, 1)
gmsh.model.occ.synchronize()

# 获取要移除的面（如顶面）
faces = gmsh.model.getBoundary([(3, box)], combined=False,
                                oriented=False, recursive=False)

# 找到顶面（z=1）
top_face = None
for f in faces:
    if f[0] == 2:
        com = gmsh.model.occ.getCenterOfMass(2, f[1])
        if abs(com[2] - 1) < 0.01:
            top_face = f[1]
            break

# 抽壳（移除顶面，壁厚0.1）
# 使用偏移面来实现
```

### 偏移 (Offset)

```python
# 使用布尔运算实现偏移效果
outer = gmsh.model.occ.addBox(0, 0, 0, 2, 2, 2)
inner = gmsh.model.occ.addBox(0.1, 0.1, 0.1, 1.8, 1.8, 1.8)

shell = gmsh.model.occ.cut([(3, outer)], [(3, inner)])
```

## 完整示例：复杂机械零件

```python
#!/usr/bin/env python3
"""
创建带圆角、孔洞的机械零件
"""
import gmsh
import math

gmsh.initialize()
gmsh.model.add("mechanical_part")

# 1. 主体
main_body = gmsh.model.occ.addBox(0, 0, 0, 10, 5, 2)

# 2. 添加圆柱凸台
boss = gmsh.model.occ.addCylinder(7.5, 2.5, 2, 0, 0, 1.5, 1.5)

# 3. 布尔并集
body = gmsh.model.occ.fuse([(3, main_body)], [(3, boss)])
gmsh.model.occ.synchronize()

# 获取合并后的体积tag
volumes = gmsh.model.getEntities(3)
body_tag = volumes[0][1]

# 4. 创建安装孔
holes = []
hole_positions = [(2, 1), (2, 4), (8, 1), (8, 4)]
for x, y in hole_positions:
    hole = gmsh.model.occ.addCylinder(x, y, -0.1, 0, 0, 2.2, 0.3)
    holes.append((3, hole))

# 5. 创建中心沉孔
center_hole = gmsh.model.occ.addCylinder(7.5, 2.5, 2, 0, 0, 1.6, 0.5)
counterbore = gmsh.model.occ.addCylinder(7.5, 2.5, 3, 0, 0, 0.6, 0.8)
holes.append((3, center_hole))
holes.append((3, counterbore))

# 6. 布尔差集
result = gmsh.model.occ.cut([(3, body_tag)], holes)
gmsh.model.occ.synchronize()

# 7. 添加圆角
volumes = gmsh.model.getEntities(3)
if volumes:
    vol_tag = volumes[0][1]

    # 获取所有边
    edges = gmsh.model.getBoundary([(3, vol_tag)], combined=False,
                                    oriented=False, recursive=True)

    # 选择外部边（排除孔的边）进行圆角
    fillet_edges = []
    for e in edges:
        if e[0] == 1:
            length = gmsh.model.occ.getMass(1, e[1])
            # 选择较长的边（排除圆孔边）
            if length > 1:
                fillet_edges.append(e[1])

    # 应用小圆角
    if fillet_edges:
        try:
            gmsh.model.occ.fillet([vol_tag], fillet_edges[:4], [0.2])
        except:
            print("部分圆角失败，继续...")

gmsh.model.occ.synchronize()

# 网格设置
gmsh.option.setNumber("Mesh.MeshSizeMin", 0.1)
gmsh.option.setNumber("Mesh.MeshSizeMax", 0.5)
gmsh.option.setNumber("Mesh.MeshSizeFromCurvature", 20)

# 生成网格
gmsh.model.mesh.generate(3)

# 输出信息
nodes = gmsh.model.mesh.getNodes()
print(f"节点数: {len(nodes[0])}")

gmsh.write("mechanical_part.msh")
gmsh.finalize()
```

## 实体操作总结

| 操作 | 函数 | 说明 |
|-----|------|------|
| 立方体 | addBox | 基本长方体 |
| 球体 | addSphere | 完整或部分球体 |
| 圆柱 | addCylinder | 完整或部分圆柱 |
| 圆锥 | addCone | 圆锥或截锥 |
| 圆环 | addTorus | 完整或部分圆环 |
| 拉伸 | extrude | 线性拉伸曲面 |
| 旋转 | revolve | 绕轴旋转曲面 |
| 放样 | addThruSections | 通过多截面 |
| 管道 | addPipe | 沿路径扫掠 |
| 圆角 | fillet | 边的圆角处理 |
| 倒角 | chamfer | 边的倒角处理 |

## 下一步

- [04-CAD导入](./04-CAD导入.md) - 学习导入外部CAD文件
