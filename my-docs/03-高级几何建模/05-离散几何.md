# 离散几何

离散几何允许从现有网格数据创建几何实体，是处理STL文件、扫描数据等的重要技术。

## 离散几何概念

```
点云/网格数据          →        离散几何          →        新网格
   ·  ·  ·                    ┌─────────┐
  ·  ·  ·  ·                  │  曲面   │              ╱╲╱╲
 ·  ·  ·  ·  ·      →         │  曲线   │     →       ╱╲╱╲╱╲
  ·  ·  ·  ·                  │  点     │            ╱╲╱╲╱╲╱╲
   ·  ·  ·                    └─────────┘
```

## 从STL创建离散几何

### 基本流程

```python
import gmsh
import math

gmsh.initialize()
gmsh.model.add("discrete_geo")

# 1. 导入STL网格
gmsh.merge("model.stl")

# 2. 从网格创建几何
gmsh.model.mesh.createGeometry()

# 3. 分类网格元素到几何实体
# 参数：面角度阈值、曲线角度阈值、分割角度
gmsh.model.mesh.classifySurfaces(
    angle=math.pi / 4,        # 相邻面之间的角度阈值
    boundary=True,            # 分类边界
    forReparametrization=True # 为重参数化准备
)

# 4. 创建拓扑
gmsh.model.mesh.createTopology()

# 5. 同步
gmsh.model.geo.synchronize()

# 6. 重新网格化
gmsh.model.mesh.clear()
gmsh.option.setNumber("Mesh.MeshSizeMax", 0.5)
gmsh.model.mesh.generate(2)

gmsh.write("remeshed.msh")
gmsh.finalize()
```

### 详细控制

```python
# 更详细的分类控制
gmsh.model.mesh.classifySurfaces(
    angle=40 * math.pi / 180,        # 40度
    boundary=True,
    forReparametrization=True,
    curveAngle=40 * math.pi / 180,   # 曲线角度阈值
    splitAngle=90 * math.pi / 180    # 分割角度
)

# 创建拓扑时可以指定公差
gmsh.model.mesh.createTopology(
    makeSimplyConnected=True,  # 确保简单连接
    exportDiscrete=False       # 不导出离散实体
)
```

## 创建离散实体

### 离散曲线

```python
# 手动创建离散曲线
points = [
    gmsh.model.geo.addPoint(0, 0, 0),
    gmsh.model.geo.addPoint(1, 0, 0),
    gmsh.model.geo.addPoint(2, 0.5, 0),
    gmsh.model.geo.addPoint(3, 0, 0),
]

# 创建离散曲线（通过点）
# 首先创建常规曲线
lines = []
for i in range(len(points) - 1):
    lines.append(gmsh.model.geo.addLine(points[i], points[i+1]))

gmsh.model.geo.synchronize()
```

### 离散曲面

```python
#!/usr/bin/env python3
"""
从点云创建离散曲面
"""
import gmsh
import numpy as np

gmsh.initialize()
gmsh.model.add("discrete_surface")

# 生成点云数据（例如：地形数据）
np.random.seed(42)
n = 20
x = np.linspace(0, 10, n)
y = np.linspace(0, 10, n)
X, Y = np.meshgrid(x, y)

# 地形高度函数
Z = np.sin(X * 0.5) * np.cos(Y * 0.5) + 0.1 * np.random.randn(n, n)

# 创建点
point_tags = []
for i in range(n):
    row = []
    for j in range(n):
        tag = gmsh.model.geo.addPoint(X[i, j], Y[i, j], Z[i, j])
        row.append(tag)
    point_tags.append(row)

gmsh.model.geo.synchronize()

# 创建三角网格
triangles = []
for i in range(n - 1):
    for j in range(n - 1):
        # 两个三角形组成一个方格
        p1 = point_tags[i][j]
        p2 = point_tags[i+1][j]
        p3 = point_tags[i+1][j+1]
        p4 = point_tags[i][j+1]

        # 直接使用addSurfaceFilling或创建线和曲线环
        # 这里使用简化方法

# 更简单的方法：使用样条曲面
# 创建边界
bottom_pts = [point_tags[0][j] for j in range(n)]
right_pts = [point_tags[i][n-1] for i in range(n)]
top_pts = [point_tags[n-1][j] for j in range(n-1, -1, -1)]
left_pts = [point_tags[i][0] for i in range(n-1, -1, -1)]

bottom_spline = gmsh.model.geo.addSpline(bottom_pts)
right_spline = gmsh.model.geo.addSpline(right_pts)
top_spline = gmsh.model.geo.addSpline(top_pts)
left_spline = gmsh.model.geo.addSpline(left_pts)

loop = gmsh.model.geo.addCurveLoop([bottom_spline, right_spline,
                                     top_spline, left_spline])

# 创建曲面
surface = gmsh.model.geo.addSurfaceFilling([loop])

gmsh.model.geo.synchronize()

gmsh.option.setNumber("Mesh.MeshSizeMax", 1.0)
gmsh.model.mesh.generate(2)

gmsh.write("terrain.msh")
gmsh.finalize()
```

## 重参数化

### 曲面重参数化

```python
# 重参数化已有的离散曲面
# 这对于改善网格质量很重要

gmsh.merge("discrete_model.msh")
gmsh.model.mesh.createGeometry()

# 重参数化选项
gmsh.option.setNumber("Mesh.ReparametrizeCurves", 1)

# 分类和创建拓扑
gmsh.model.mesh.classifySurfaces(math.pi / 4)
gmsh.model.mesh.createTopology()

gmsh.model.geo.synchronize()
```

### 参数化设置

```python
# 获取参数化边界
surface_tag = 1
bounds = gmsh.model.getParametrizationBounds(2, surface_tag)
u_min, v_min = bounds[0]
u_max, v_max = bounds[1]

print(f"参数范围: u=[{u_min}, {u_max}], v=[{v_min}, {v_max}]")

# 在参数空间中获取点
u = (u_min + u_max) / 2
v = (v_min + v_max) / 2
point = gmsh.model.getValue(2, surface_tag, [u, v])
print(f"中心点: {point}")
```

## 从网格提取几何

### 提取边界

```python
#!/usr/bin/env python3
"""
从体网格提取边界面
"""
import gmsh

gmsh.initialize()
gmsh.model.add("extract_boundary")

# 创建并网格化一个实体
box = gmsh.model.occ.addBox(0, 0, 0, 1, 1, 1)
gmsh.model.occ.synchronize()
gmsh.model.mesh.generate(3)

# 获取边界元素
boundary = gmsh.model.getBoundary([(3, box)])
print(f"边界面: {boundary}")

# 获取特定面的网格
for face in boundary:
    if face[0] == 2:
        elements = gmsh.model.mesh.getElements(2, face[1])
        print(f"面 {face[1]}: {len(elements[1][0])} 个元素")

gmsh.finalize()
```

### 提取特征线

```python
# 提取几何特征线（尖锐边缘）
angle_threshold = 30  # 度

gmsh.merge("model.stl")
gmsh.model.mesh.createGeometry()

# 基于角度分类
gmsh.model.mesh.classifySurfaces(
    angle=angle_threshold * math.pi / 180,
    curveAngle=angle_threshold * math.pi / 180
)

gmsh.model.mesh.createTopology()
gmsh.model.geo.synchronize()

# 获取特征线
curves = gmsh.model.getEntities(1)
print(f"检测到 {len(curves)} 条特征线")
```

## 离散数据处理

### 网格修复

```python
#!/usr/bin/env python3
"""
修复离散网格
"""
import gmsh

gmsh.initialize()
gmsh.model.add("mesh_repair")

# 导入可能有问题的网格
gmsh.merge("broken.stl")

# 1. 合并重复节点
gmsh.option.setNumber("Geometry.Tolerance", 1e-6)

# 2. 移除退化元素
gmsh.model.mesh.removeDuplicateNodes()

# 3. 创建几何并修复拓扑
gmsh.model.mesh.createGeometry()
gmsh.model.mesh.classifySurfaces(math.pi / 4)
gmsh.model.mesh.createTopology(makeSimplyConnected=True)

gmsh.model.geo.synchronize()

# 4. 重新网格化
gmsh.model.mesh.clear()
gmsh.model.mesh.generate(2)

gmsh.write("repaired.msh")
gmsh.finalize()
```

### 网格简化

```python
# 简化高密度网格（基于特征保持）
# 使用网格尺寸控制实现简化

gmsh.merge("high_density.stl")
gmsh.model.mesh.createGeometry()
gmsh.model.mesh.classifySurfaces(math.pi / 6)  # 较小角度保留更多特征
gmsh.model.mesh.createTopology()
gmsh.model.geo.synchronize()

# 使用较大的网格尺寸
gmsh.model.mesh.clear()
gmsh.option.setNumber("Mesh.MeshSizeMax", 5.0)  # 大尺寸=简化
gmsh.model.mesh.generate(2)
```

## 点云处理

### 从点云创建曲面

```python
#!/usr/bin/env python3
"""
从点云数据创建曲面
"""
import gmsh
import numpy as np

gmsh.initialize()
gmsh.model.add("pointcloud")

# 读取点云数据（假设格式：x, y, z每行）
# points_data = np.loadtxt("pointcloud.txt")

# 示例：生成测试点云
np.random.seed(42)
n_points = 500
theta = np.random.uniform(0, 2*np.pi, n_points)
phi = np.random.uniform(0, np.pi, n_points)
r = 1 + 0.1 * np.random.randn(n_points)

x = r * np.sin(phi) * np.cos(theta)
y = r * np.sin(phi) * np.sin(theta)
z = r * np.cos(phi)

# 方法1：使用Delaunay三角化
# 创建点
point_tags = []
for i in range(n_points):
    tag = gmsh.model.geo.addPoint(x[i], y[i], z[i])
    point_tags.append(tag)

gmsh.model.geo.synchronize()

# 方法2：使用样条拟合（适用于有序点）
# 需要对点进行排序和组织

# 方法3：导出为POS格式使用后处理
with open("pointcloud.pos", "w") as f:
    f.write('View "Points" {\n')
    for i in range(n_points):
        f.write(f"SP({x[i]}, {y[i]}, {z[i]}){{0}};\n")
    f.write('};\n')

gmsh.finalize()
```

### Delaunay三角化

```python
#!/usr/bin/env python3
"""
对点集进行Delaunay三角化
"""
import gmsh
import numpy as np

gmsh.initialize()
gmsh.model.add("delaunay")

# 2D点集
np.random.seed(42)
n = 50
x = np.random.uniform(0, 10, n)
y = np.random.uniform(0, 10, n)

# 创建点
for i in range(n):
    gmsh.model.geo.addPoint(x[i], y[i], 0, meshSize=0.5)

gmsh.model.geo.synchronize()

# 创建边界
# 计算凸包作为边界
from scipy.spatial import ConvexHull
points_2d = np.column_stack([x, y])
hull = ConvexHull(points_2d)

# 创建边界线
boundary_points = []
for idx in hull.vertices:
    boundary_points.append(idx + 1)  # Gmsh tag从1开始
boundary_points.append(boundary_points[0])  # 闭合

boundary_lines = []
for i in range(len(boundary_points) - 1):
    line = gmsh.model.geo.addLine(boundary_points[i], boundary_points[i+1])
    boundary_lines.append(line)

loop = gmsh.model.geo.addCurveLoop(boundary_lines)
surface = gmsh.model.geo.addPlaneSurface([loop])

gmsh.model.geo.synchronize()

# 嵌入内部点
internal_points = [i + 1 for i in range(n) if (i + 1) not in boundary_points]
gmsh.model.mesh.embed(0, internal_points, 2, surface)

# 生成网格
gmsh.model.mesh.generate(2)

gmsh.write("delaunay.msh")
gmsh.finalize()
```

## 完整示例：地形网格

```python
#!/usr/bin/env python3
"""
从DEM数据创建地形网格
"""
import gmsh
import numpy as np

def create_terrain_mesh(dem_file=None, output_file="terrain.msh"):
    """创建地形网格"""

    gmsh.initialize()
    gmsh.model.add("terrain")

    # 模拟DEM数据（实际应用中从文件读取）
    if dem_file is None:
        # 生成测试地形
        n = 30
        x = np.linspace(0, 100, n)
        y = np.linspace(0, 100, n)
        X, Y = np.meshgrid(x, y)

        # 地形函数（山丘+山谷）
        Z = (10 * np.exp(-((X-30)**2 + (Y-30)**2) / 200) +
             8 * np.exp(-((X-70)**2 + (Y-70)**2) / 300) -
             5 * np.exp(-((X-50)**2 + (Y-50)**2) / 150))
    else:
        # 从文件读取
        # X, Y, Z = read_dem(dem_file)
        pass

    n = X.shape[0]

    # 创建点
    point_tags = np.zeros((n, n), dtype=int)
    for i in range(n):
        for j in range(n):
            point_tags[i, j] = gmsh.model.geo.addPoint(
                X[i, j], Y[i, j], Z[i, j])

    gmsh.model.geo.synchronize()

    # 创建边界曲线
    # 底边
    bottom = gmsh.model.geo.addSpline([point_tags[0, j] for j in range(n)])
    # 右边
    right = gmsh.model.geo.addSpline([point_tags[i, n-1] for i in range(n)])
    # 顶边
    top = gmsh.model.geo.addSpline([point_tags[n-1, j] for j in range(n-1, -1, -1)])
    # 左边
    left = gmsh.model.geo.addSpline([point_tags[i, 0] for i in range(n-1, -1, -1)])

    # 创建曲线环和曲面
    loop = gmsh.model.geo.addCurveLoop([bottom, right, top, left])
    surface = gmsh.model.geo.addSurfaceFilling([loop])

    gmsh.model.geo.synchronize()

    # 嵌入内部点以保证地形精度
    internal_points = []
    for i in range(1, n-1):
        for j in range(1, n-1):
            internal_points.append(point_tags[i, j])

    gmsh.model.mesh.embed(0, internal_points, 2, surface)

    # 网格设置
    gmsh.option.setNumber("Mesh.MeshSizeMin", 2)
    gmsh.option.setNumber("Mesh.MeshSizeMax", 5)
    gmsh.option.setNumber("Mesh.Algorithm", 6)

    # 生成网格
    gmsh.model.mesh.generate(2)

    # 添加物理组
    gmsh.model.addPhysicalGroup(2, [surface], name="Terrain")
    gmsh.model.addPhysicalGroup(1, [bottom], name="South")
    gmsh.model.addPhysicalGroup(1, [right], name="East")
    gmsh.model.addPhysicalGroup(1, [top], name="North")
    gmsh.model.addPhysicalGroup(1, [left], name="West")

    # 统计
    nodes = gmsh.model.mesh.getNodes()
    elements = gmsh.model.mesh.getElements(2)
    print(f"节点数: {len(nodes[0])}")
    print(f"元素数: {len(elements[1][0])}")

    # 保存
    gmsh.write(output_file)

    gmsh.finalize()

if __name__ == "__main__":
    create_terrain_mesh()
```

## 离散几何选项

| 选项 | 描述 | 默认值 |
|-----|------|-------|
| Mesh.ReparametrizeCurves | 重参数化曲线 | 0 |
| Geometry.Tolerance | 几何公差 | 1e-8 |
| Mesh.ToleranceEdgeLength | 边长公差 | 0 |
| Mesh.BoundaryLayerFanElements | 边界层扇形元素 | 0 |

## 下一步

- [06-嵌入实体](./06-嵌入实体.md) - 学习在网格中嵌入点、线、面
