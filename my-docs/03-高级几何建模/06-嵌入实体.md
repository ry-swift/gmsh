# 嵌入实体

嵌入实体允许在网格中强制包含特定的点、曲线或曲面，是实现精确边界条件和局部细化的关键技术。

## 嵌入概念

```
无嵌入                          嵌入点后
┌─────────────────┐            ┌─────────────────┐
│╲       ╱        │            │╲       ╱        │
│  ╲   ╱          │            │  ╲   • ╱        │
│    ╲            │     →      │    ╲╱ ╲         │
│   ╱  ╲          │            │   ╱ • ╲         │
│ ╱      ╲        │            │ ╱    ╱ ╲        │
└─────────────────┘            └─────────────────┘
   点不在网格中                    点成为网格节点
```

## 嵌入点

### 基本用法

```python
import gmsh

gmsh.initialize()
gmsh.model.add("embed_points")

# 创建几何
rect = gmsh.model.occ.addRectangle(0, 0, 0, 10, 10)
gmsh.model.occ.synchronize()

# 创建要嵌入的点
p1 = gmsh.model.occ.addPoint(3, 3, 0)
p2 = gmsh.model.occ.addPoint(7, 7, 0)
p3 = gmsh.model.occ.addPoint(5, 5, 0)
gmsh.model.occ.synchronize()

# 嵌入点到曲面
# embed(dim, tags, inDim, inTag)
# dim: 被嵌入实体的维度
# tags: 被嵌入实体的tag列表
# inDim: 目标实体的维度
# inTag: 目标实体的tag
gmsh.model.mesh.embed(0, [p1, p2, p3], 2, rect)

# 生成网格
gmsh.model.mesh.generate(2)

gmsh.write("embed_points.msh")
gmsh.finalize()
```

### 在3D实体中嵌入点

```python
# 创建体积
box = gmsh.model.occ.addBox(0, 0, 0, 1, 1, 1)
gmsh.model.occ.synchronize()

# 创建内部点
points = [
    gmsh.model.occ.addPoint(0.25, 0.25, 0.25),
    gmsh.model.occ.addPoint(0.75, 0.75, 0.75),
    gmsh.model.occ.addPoint(0.5, 0.5, 0.5),
]
gmsh.model.occ.synchronize()

# 嵌入到体积
gmsh.model.mesh.embed(0, points, 3, box)

gmsh.model.mesh.generate(3)
```

### 传感器位置嵌入

```python
#!/usr/bin/env python3
"""
在结构中嵌入传感器位置点
"""
import gmsh

gmsh.initialize()
gmsh.model.add("sensors")

# 创建结构（梁）
beam = gmsh.model.occ.addBox(0, 0, 0, 10, 1, 0.5)
gmsh.model.occ.synchronize()

# 传感器位置
sensor_positions = [
    (1, 0.5, 0.25),
    (3, 0.5, 0.25),
    (5, 0.5, 0.25),
    (7, 0.5, 0.25),
    (9, 0.5, 0.25),
]

# 创建传感器点
sensor_tags = []
for x, y, z in sensor_positions:
    tag = gmsh.model.occ.addPoint(x, y, z)
    sensor_tags.append(tag)
gmsh.model.occ.synchronize()

# 嵌入传感器点
gmsh.model.mesh.embed(0, sensor_tags, 3, beam)

# 为传感器点创建物理组
gmsh.model.addPhysicalGroup(0, sensor_tags, name="Sensors")
gmsh.model.addPhysicalGroup(3, [beam], name="Beam")

# 网格设置
gmsh.option.setNumber("Mesh.MeshSizeMax", 0.3)
gmsh.model.mesh.generate(3)

gmsh.write("beam_with_sensors.msh")
gmsh.finalize()
```

## 嵌入曲线

### 基本用法

```python
gmsh.initialize()
gmsh.model.add("embed_curves")

# 创建曲面
rect = gmsh.model.occ.addRectangle(0, 0, 0, 10, 10)

# 创建要嵌入的曲线
p1 = gmsh.model.occ.addPoint(2, 2, 0)
p2 = gmsh.model.occ.addPoint(8, 8, 0)
line = gmsh.model.occ.addLine(p1, p2)

gmsh.model.occ.synchronize()

# 嵌入曲线到曲面
gmsh.model.mesh.embed(1, [line], 2, rect)

# 生成网格
gmsh.model.mesh.generate(2)

gmsh.write("embed_curve.msh")
gmsh.finalize()
```

### 裂纹建模

```python
#!/usr/bin/env python3
"""
使用嵌入曲线建模裂纹
"""
import gmsh
import math

gmsh.initialize()
gmsh.model.add("crack")

# 创建板
plate = gmsh.model.occ.addRectangle(0, 0, 0, 20, 10)

# 创建裂纹（从边缘开始）
crack_start = gmsh.model.occ.addPoint(0, 5, 0)
crack_tip = gmsh.model.occ.addPoint(8, 5, 0)
crack = gmsh.model.occ.addLine(crack_start, crack_tip)

gmsh.model.occ.synchronize()

# 使用fragment确保裂纹与边界共享节点
gmsh.model.occ.fragment([(2, plate)], [(1, crack)])
gmsh.model.occ.synchronize()

# 为裂纹尖端创建局部细化
crack_tip_coords = gmsh.model.getValue(0, crack_tip, [])

# 距离场
f_dist = gmsh.model.mesh.field.add("Distance")
gmsh.model.mesh.field.setNumbers(f_dist, "PointsList", [crack_tip])

# 阈值场
f_thresh = gmsh.model.mesh.field.add("Threshold")
gmsh.model.mesh.field.setNumber(f_thresh, "InField", f_dist)
gmsh.model.mesh.field.setNumber(f_thresh, "SizeMin", 0.05)
gmsh.model.mesh.field.setNumber(f_thresh, "SizeMax", 1.0)
gmsh.model.mesh.field.setNumber(f_thresh, "DistMin", 0.2)
gmsh.model.mesh.field.setNumber(f_thresh, "DistMax", 3.0)

gmsh.model.mesh.field.setAsBackgroundMesh(f_thresh)

# 禁用默认尺寸源
gmsh.option.setNumber("Mesh.MeshSizeFromPoints", 0)
gmsh.option.setNumber("Mesh.MeshSizeExtendFromBoundary", 0)

# 生成网格
gmsh.model.mesh.generate(2)

# 添加物理组
surfaces = gmsh.model.getEntities(2)
gmsh.model.addPhysicalGroup(2, [s[1] for s in surfaces], name="Plate")

curves = gmsh.model.getEntities(1)
# 找到裂纹曲线
for c in curves:
    com = gmsh.model.occ.getCenterOfMass(1, c[1])
    if abs(com[1] - 5) < 0.1 and com[0] < 8:
        gmsh.model.addPhysicalGroup(1, [c[1]], name="Crack")

gmsh.model.addPhysicalGroup(0, [crack_tip], name="CrackTip")

gmsh.write("crack.msh")
gmsh.finalize()
```

### 内部界面嵌入

```python
#!/usr/bin/env python3
"""
嵌入材料界面
"""
import gmsh

gmsh.initialize()
gmsh.model.add("interface")

# 创建域
domain = gmsh.model.occ.addRectangle(0, 0, 0, 10, 10)

# 创建内部界面（圆形）
interface = gmsh.model.occ.addCircle(5, 5, 0, 3)
gmsh.model.occ.synchronize()

# 创建曲线环
interface_loop = gmsh.model.occ.addCurveLoop([interface])
gmsh.model.occ.synchronize()

# 使用fragment分割域
domain_dimtags = [(2, domain)]
interface_dimtags = [(1, interface)]

gmsh.model.occ.fragment(domain_dimtags, interface_dimtags)
gmsh.model.occ.synchronize()

# 现在域被分割成两部分
surfaces = gmsh.model.getEntities(2)
print(f"曲面数: {len(surfaces)}")

# 识别内外区域
for surf in surfaces:
    com = gmsh.model.occ.getCenterOfMass(2, surf[1])
    dist = ((com[0] - 5)**2 + (com[1] - 5)**2)**0.5
    if dist < 3:
        gmsh.model.addPhysicalGroup(2, [surf[1]], name="Inner")
    else:
        gmsh.model.addPhysicalGroup(2, [surf[1]], name="Outer")

# 界面物理组
curves = gmsh.model.getEntities(1)
for c in curves:
    length = gmsh.model.occ.getMass(1, c[1])
    if abs(length - 2 * 3.14159 * 3) < 1:  # 圆的周长
        gmsh.model.addPhysicalGroup(1, [c[1]], name="Interface")

gmsh.option.setNumber("Mesh.MeshSizeMax", 0.5)
gmsh.model.mesh.generate(2)

gmsh.write("interface.msh")
gmsh.finalize()
```

## 嵌入曲面

### 在3D中嵌入曲面

```python
#!/usr/bin/env python3
"""
在3D实体中嵌入内部曲面
"""
import gmsh

gmsh.initialize()
gmsh.model.add("embed_surface")

# 创建立方体
box = gmsh.model.occ.addBox(0, 0, 0, 2, 2, 2)

# 创建内部平面
internal_surface = gmsh.model.occ.addRectangle(0.5, 0.5, 1, 1, 1)

gmsh.model.occ.synchronize()

# 使用fragment将内部平面与体积关联
gmsh.model.occ.fragment([(3, box)], [(2, internal_surface)])
gmsh.model.occ.synchronize()

# 网格设置
gmsh.option.setNumber("Mesh.MeshSizeMax", 0.2)
gmsh.model.mesh.generate(3)

# 添加物理组
volumes = gmsh.model.getEntities(3)
gmsh.model.addPhysicalGroup(3, [v[1] for v in volumes], name="Domain")

# 找到内部面
surfaces = gmsh.model.getEntities(2)
for s in surfaces:
    bbox = gmsh.model.occ.getBoundingBox(2, s[1])
    if abs(bbox[2] - 1) < 0.1 and abs(bbox[5] - 1) < 0.1:
        gmsh.model.addPhysicalGroup(2, [s[1]], name="InternalSurface")

gmsh.write("embed_surface.msh")
gmsh.finalize()
```

### 层状材料建模

```python
#!/usr/bin/env python3
"""
创建层状材料模型
"""
import gmsh

gmsh.initialize()
gmsh.model.add("layers")

# 创建基础块
total_height = 10
block = gmsh.model.occ.addBox(0, 0, 0, 5, 5, total_height)

# 创建层界面
layer_heights = [2, 4, 7]  # 层界面高度
interfaces = []

for h in layer_heights:
    surf = gmsh.model.occ.addRectangle(0, 0, h, 5, 5)
    interfaces.append((2, surf))

gmsh.model.occ.synchronize()

# 使用fragment分割
gmsh.model.occ.fragment([(3, block)], interfaces)
gmsh.model.occ.synchronize()

# 识别各层
volumes = gmsh.model.getEntities(3)
layer_names = ["Layer1", "Layer2", "Layer3", "Layer4"]

for vol in volumes:
    com = gmsh.model.occ.getCenterOfMass(3, vol[1])
    z = com[2]

    if z < 2:
        layer_idx = 0
    elif z < 4:
        layer_idx = 1
    elif z < 7:
        layer_idx = 2
    else:
        layer_idx = 3

    gmsh.model.addPhysicalGroup(3, [vol[1]], name=layer_names[layer_idx])

# 网格生成
gmsh.option.setNumber("Mesh.MeshSizeMax", 0.5)
gmsh.model.mesh.generate(3)

gmsh.write("layers.msh")
gmsh.finalize()
```

## 局部细化与嵌入结合

### 点源细化

```python
#!/usr/bin/env python3
"""
在点源位置进行局部细化
"""
import gmsh

gmsh.initialize()
gmsh.model.add("point_source_refinement")

# 创建域
domain = gmsh.model.occ.addRectangle(0, 0, 0, 10, 10)

# 点源位置
source_positions = [(3, 3), (7, 3), (5, 7)]
source_tags = []

for x, y in source_positions:
    tag = gmsh.model.occ.addPoint(x, y, 0)
    source_tags.append(tag)

gmsh.model.occ.synchronize()

# 嵌入点源
gmsh.model.mesh.embed(0, source_tags, 2, domain)

# 创建尺寸场
fields = []

for i, tag in enumerate(source_tags):
    # 距离场
    f_dist = gmsh.model.mesh.field.add("Distance")
    gmsh.model.mesh.field.setNumbers(f_dist, "PointsList", [tag])

    # 阈值场
    f_thresh = gmsh.model.mesh.field.add("Threshold")
    gmsh.model.mesh.field.setNumber(f_thresh, "InField", f_dist)
    gmsh.model.mesh.field.setNumber(f_thresh, "SizeMin", 0.05)
    gmsh.model.mesh.field.setNumber(f_thresh, "SizeMax", 1e10)
    gmsh.model.mesh.field.setNumber(f_thresh, "DistMin", 0.1)
    gmsh.model.mesh.field.setNumber(f_thresh, "DistMax", 1.5)

    fields.append(f_thresh)

# 背景场
f_bg = gmsh.model.mesh.field.add("MathEval")
gmsh.model.mesh.field.setString(f_bg, "F", "0.5")
fields.append(f_bg)

# 取最小值
f_min = gmsh.model.mesh.field.add("Min")
gmsh.model.mesh.field.setNumbers(f_min, "FieldsList", fields)
gmsh.model.mesh.field.setAsBackgroundMesh(f_min)

gmsh.option.setNumber("Mesh.MeshSizeFromPoints", 0)
gmsh.option.setNumber("Mesh.MeshSizeExtendFromBoundary", 0)

# 生成网格
gmsh.model.mesh.generate(2)

# 物理组
gmsh.model.addPhysicalGroup(2, [domain], name="Domain")
gmsh.model.addPhysicalGroup(0, source_tags, name="Sources")

gmsh.write("point_sources.msh")
gmsh.finalize()
```

### 线源细化

```python
#!/usr/bin/env python3
"""
沿线进行局部细化（如管道、裂缝）
"""
import gmsh
import math

gmsh.initialize()
gmsh.model.add("line_refinement")

# 创建域
domain = gmsh.model.occ.addRectangle(0, 0, 0, 20, 10)

# 创建曲线（蛇形路径）
curve_points = []
for i in range(21):
    x = i
    y = 5 + 2 * math.sin(x * math.pi / 5)
    curve_points.append(gmsh.model.occ.addPoint(x, y, 0))

curve = gmsh.model.occ.addSpline(curve_points)
gmsh.model.occ.synchronize()

# 使用fragment
gmsh.model.occ.fragment([(2, domain)], [(1, curve)])
gmsh.model.occ.synchronize()

# 曲线细化
curves = gmsh.model.getEntities(1)
# 找到内部曲线
internal_curve = None
for c in curves:
    length = gmsh.model.occ.getMass(1, c[1])
    if length > 15:  # 长度最长的是我们的曲线
        internal_curve = c[1]
        break

if internal_curve:
    f_dist = gmsh.model.mesh.field.add("Distance")
    gmsh.model.mesh.field.setNumbers(f_dist, "CurvesList", [internal_curve])

    f_thresh = gmsh.model.mesh.field.add("Threshold")
    gmsh.model.mesh.field.setNumber(f_thresh, "InField", f_dist)
    gmsh.model.mesh.field.setNumber(f_thresh, "SizeMin", 0.1)
    gmsh.model.mesh.field.setNumber(f_thresh, "SizeMax", 1.0)
    gmsh.model.mesh.field.setNumber(f_thresh, "DistMin", 0.2)
    gmsh.model.mesh.field.setNumber(f_thresh, "DistMax", 2.0)

    gmsh.model.mesh.field.setAsBackgroundMesh(f_thresh)

gmsh.option.setNumber("Mesh.MeshSizeFromPoints", 0)
gmsh.option.setNumber("Mesh.MeshSizeExtendFromBoundary", 0)

gmsh.model.mesh.generate(2)
gmsh.write("line_refinement.msh")
gmsh.finalize()
```

## 嵌入注意事项

### 嵌入顺序

```python
# 正确顺序：
# 1. 创建主几何
# 2. 创建要嵌入的实体
# 3. 同步（synchronize）
# 4. 调用embed
# 5. 生成网格

# 错误：在synchronize之前调用embed
```

### 嵌入与布尔运算

```python
# 对于需要在边界上共享节点的情况，使用fragment而不是embed
# embed: 嵌入点在内部，但不会修改几何
# fragment: 分割几何，创建共享边界

# 使用fragment的情况：
# - 内部界面
# - 裂纹建模
# - 多材料界面

# 使用embed的情况：
# - 监测点
# - 点源
# - 不需要分割域的情况
```

### 检查嵌入结果

```python
# 检查嵌入是否成功
gmsh.model.mesh.embed(0, [p1, p2], 2, surface)
gmsh.model.mesh.generate(2)

# 获取节点
node_tags, node_coords, _ = gmsh.model.mesh.getNodes()

# 检查嵌入点是否在网格节点中
for p in [p1, p2]:
    point_coords = gmsh.model.getValue(0, p, [])
    found = False
    for i in range(0, len(node_coords), 3):
        if (abs(node_coords[i] - point_coords[0]) < 1e-10 and
            abs(node_coords[i+1] - point_coords[1]) < 1e-10 and
            abs(node_coords[i+2] - point_coords[2]) < 1e-10):
            found = True
            break
    print(f"点 {p} 嵌入成功: {found}")
```

## 完整示例：多物理场网格

```python
#!/usr/bin/env python3
"""
创建适用于多物理场仿真的网格
- 嵌入传感器点
- 嵌入热源线
- 材料界面处理
"""
import gmsh
import math

gmsh.initialize()
gmsh.model.add("multiphysics")

# 创建外部域
outer = gmsh.model.occ.addRectangle(0, 0, 0, 20, 20)

# 创建内部区域（不同材料）
inner = gmsh.model.occ.addDisk(10, 10, 0, 5, 5)

# 使用fragment分割
gmsh.model.occ.fragment([(2, outer)], [(2, inner)])
gmsh.model.occ.synchronize()

# 添加传感器点
sensor_positions = [
    (5, 10), (10, 5), (15, 10), (10, 15),  # 外围
    (10, 10),  # 中心
]
sensor_tags = []
for x, y in sensor_positions:
    tag = gmsh.model.occ.addPoint(x, y, 0)
    sensor_tags.append(tag)
gmsh.model.occ.synchronize()

# 添加热源线
heater_pts = [
    gmsh.model.occ.addPoint(2, 2, 0),
    gmsh.model.occ.addPoint(18, 2, 0),
]
heater = gmsh.model.occ.addLine(heater_pts[0], heater_pts[1])
gmsh.model.occ.synchronize()

# 获取所有曲面
surfaces = gmsh.model.getEntities(2)

# 嵌入传感器和热源到各个曲面
for surf in surfaces:
    # 嵌入传感器点
    for tag in sensor_tags:
        point_coords = gmsh.model.getValue(0, tag, [])
        # 检查点是否在此曲面内
        try:
            gmsh.model.mesh.embed(0, [tag], 2, surf[1])
        except:
            pass

# 嵌入热源线（到外部域）
for surf in surfaces:
    com = gmsh.model.occ.getCenterOfMass(2, surf[1])
    if ((com[0] - 10)**2 + (com[1] - 10)**2)**0.5 > 5:
        # 外部域
        try:
            gmsh.model.mesh.embed(1, [heater], 2, surf[1])
        except:
            pass

# 创建尺寸场
fields = []

# 传感器点周围细化
f_dist_sensors = gmsh.model.mesh.field.add("Distance")
gmsh.model.mesh.field.setNumbers(f_dist_sensors, "PointsList", sensor_tags)

f_thresh_sensors = gmsh.model.mesh.field.add("Threshold")
gmsh.model.mesh.field.setNumber(f_thresh_sensors, "InField", f_dist_sensors)
gmsh.model.mesh.field.setNumber(f_thresh_sensors, "SizeMin", 0.1)
gmsh.model.mesh.field.setNumber(f_thresh_sensors, "SizeMax", 1e10)
gmsh.model.mesh.field.setNumber(f_thresh_sensors, "DistMin", 0.2)
gmsh.model.mesh.field.setNumber(f_thresh_sensors, "DistMax", 2.0)
fields.append(f_thresh_sensors)

# 材料界面细化
interface_curves = []
for c in gmsh.model.getEntities(1):
    length = gmsh.model.occ.getMass(1, c[1])
    if abs(length - 2 * math.pi * 5) < 1:  # 圆的周长
        interface_curves.append(c[1])

if interface_curves:
    f_dist_interface = gmsh.model.mesh.field.add("Distance")
    gmsh.model.mesh.field.setNumbers(f_dist_interface, "CurvesList",
                                      interface_curves)

    f_thresh_interface = gmsh.model.mesh.field.add("Threshold")
    gmsh.model.mesh.field.setNumber(f_thresh_interface, "InField",
                                     f_dist_interface)
    gmsh.model.mesh.field.setNumber(f_thresh_interface, "SizeMin", 0.2)
    gmsh.model.mesh.field.setNumber(f_thresh_interface, "SizeMax", 1e10)
    gmsh.model.mesh.field.setNumber(f_thresh_interface, "DistMin", 0.3)
    gmsh.model.mesh.field.setNumber(f_thresh_interface, "DistMax", 3.0)
    fields.append(f_thresh_interface)

# 背景尺寸
f_bg = gmsh.model.mesh.field.add("MathEval")
gmsh.model.mesh.field.setString(f_bg, "F", "1.0")
fields.append(f_bg)

# 组合
f_min = gmsh.model.mesh.field.add("Min")
gmsh.model.mesh.field.setNumbers(f_min, "FieldsList", fields)
gmsh.model.mesh.field.setAsBackgroundMesh(f_min)

gmsh.option.setNumber("Mesh.MeshSizeFromPoints", 0)
gmsh.option.setNumber("Mesh.MeshSizeExtendFromBoundary", 0)

# 生成网格
gmsh.model.mesh.generate(2)

# 添加物理组
for surf in surfaces:
    com = gmsh.model.occ.getCenterOfMass(2, surf[1])
    if ((com[0] - 10)**2 + (com[1] - 10)**2)**0.5 < 5:
        gmsh.model.addPhysicalGroup(2, [surf[1]], name="Material_Inner")
    else:
        gmsh.model.addPhysicalGroup(2, [surf[1]], name="Material_Outer")

gmsh.model.addPhysicalGroup(0, sensor_tags, name="Sensors")
gmsh.model.addPhysicalGroup(1, [heater], name="Heater")

if interface_curves:
    gmsh.model.addPhysicalGroup(1, interface_curves, name="Interface")

# 输出信息
nodes, _, _ = gmsh.model.mesh.getNodes()
print(f"节点数: {len(nodes)}")

gmsh.write("multiphysics.msh")
gmsh.finalize()
```

## 嵌入总结

| 函数 | 用途 | 示例 |
|-----|------|-----|
| mesh.embed(0, [...], 2, surf) | 嵌入点到曲面 | 传感器位置 |
| mesh.embed(1, [...], 2, surf) | 嵌入曲线到曲面 | 裂纹、热源 |
| mesh.embed(0, [...], 3, vol) | 嵌入点到体积 | 内部测点 |
| mesh.embed(1, [...], 3, vol) | 嵌入曲线到体积 | 管道、线源 |
| mesh.embed(2, [...], 3, vol) | 嵌入曲面到体积 | 内部界面 |
| occ.fragment | 分割几何创建共享边界 | 材料界面 |

## 下一步

完成高级几何建模学习后，请继续：
- [04-后处理与可视化](../04-后处理与可视化/01-View基础.md) - 学习后处理和可视化技术
