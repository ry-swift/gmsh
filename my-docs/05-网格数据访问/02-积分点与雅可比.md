# 积分点与雅可比

积分点和雅可比矩阵是有限元数值积分的核心数据。

## 积分点基础

### 获取积分点

```python
import gmsh
import numpy as np

gmsh.initialize()
gmsh.model.add("integration")

# 创建网格
rect = gmsh.model.occ.addRectangle(0, 0, 0, 1, 1)
gmsh.model.occ.synchronize()
gmsh.model.mesh.generate(2)

# 获取积分点
# getIntegrationPoints(elementType, integrationType)
# integrationType: "Gauss1", "Gauss2", ..., "GaussN" (N阶高斯积分)

elem_type = 2  # Triangle 3
int_type = "Gauss3"  # 3阶高斯积分

local_coords, weights = gmsh.model.mesh.getIntegrationPoints(elem_type, int_type)

# local_coords: 参考元素上的积分点坐标 [u1,v1,w1, u2,v2,w2, ...]
# weights: 积分权重

local_coords = np.array(local_coords).reshape(-1, 3)
weights = np.array(weights)

print(f"积分点数: {len(weights)}")
print(f"积分点坐标:\n{local_coords}")
print(f"积分权重: {weights}")
print(f"权重和: {weights.sum()}")  # 应该等于参考元素面积/体积

gmsh.finalize()
```

### 常用积分类型

| 元素类型 | 积分类型 | 积分点数 | 精度 |
|---------|----------|---------|------|
| Triangle | Gauss1 | 1 | 线性 |
| Triangle | Gauss3 | 3 | 二次 |
| Triangle | Gauss4 | 4 | 三次 |
| Triangle | Gauss7 | 7 | 五次 |
| Quadrangle | Gauss1 | 1 | 线性 |
| Quadrangle | Gauss4 | 4 | 三次 |
| Quadrangle | Gauss9 | 9 | 五次 |
| Tetrahedron | Gauss1 | 1 | 线性 |
| Tetrahedron | Gauss4 | 4 | 二次 |
| Tetrahedron | Gauss5 | 5 | 三次 |
| Hexahedron | Gauss1 | 1 | 线性 |
| Hexahedron | Gauss8 | 8 | 三次 |
| Hexahedron | Gauss27 | 27 | 五次 |

## 雅可比矩阵

### 获取雅可比矩阵

```python
#!/usr/bin/env python3
"""
获取元素的雅可比矩阵
"""
import gmsh
import numpy as np

gmsh.initialize()
gmsh.model.add("jacobian")

# 创建网格
rect = gmsh.model.occ.addRectangle(0, 0, 0, 2, 1)
gmsh.model.occ.synchronize()
gmsh.option.setNumber("Mesh.MeshSizeMax", 0.5)
gmsh.model.mesh.generate(2)

# 获取元素
elem_types, elem_tags, elem_nodes = gmsh.model.mesh.getElements(dim=2)

for etype, etags in zip(elem_types, elem_tags):
    # 获取积分点
    local_coords, weights = gmsh.model.mesh.getIntegrationPoints(etype, "Gauss3")

    # 获取雅可比矩阵
    # getJacobians(elementType, localCoord, tag=-1, task=0, numTasks=1)
    # 返回: (jacobians, determinants, coord)
    jacobians, determinants, global_coords = gmsh.model.mesh.getJacobians(
        etype, local_coords)

    # jacobians: 雅可比矩阵 [J11,J12,J13, J21,J22,J23, J31,J32,J33, ...]
    # determinants: 雅可比行列式
    # global_coords: 积分点的全局坐标

    num_elements = len(etags)
    num_int_points = len(weights)

    # 重组数组
    jacobians = np.array(jacobians).reshape(num_elements, num_int_points, 3, 3)
    determinants = np.array(determinants).reshape(num_elements, num_int_points)
    global_coords = np.array(global_coords).reshape(num_elements, num_int_points, 3)

    print(f"元素类型: {etype}")
    print(f"元素数: {num_elements}")
    print(f"每元素积分点数: {num_int_points}")

    # 打印第一个元素的信息
    print(f"\n第一个元素:")
    for ip in range(num_int_points):
        print(f"  积分点{ip}:")
        print(f"    全局坐标: {global_coords[0, ip]}")
        print(f"    雅可比行列式: {determinants[0, ip]:.6f}")
        print(f"    雅可比矩阵:\n{jacobians[0, ip]}")

gmsh.finalize()
```

### 雅可比行列式的意义

```
参考元素                全局元素
   ξ                      x
   │                      │
   ▼                      ▼
┌──────┐               ┌──────────┐
│      │    J(ξ,η)    ╱          ╱
│      │  ────────→  ╱          ╱
│      │            ╱──────────╱
└──────┘

|J| = 面积/体积缩放因子

积分变换:
∫∫ f(x,y) dΩ = ∫∫ f(x(ξ,η), y(ξ,η)) |J| dξdη
```

## 数值积分

### 面积/体积计算

```python
#!/usr/bin/env python3
"""
使用数值积分计算面积/体积
"""
import gmsh
import numpy as np

gmsh.initialize()
gmsh.model.add("integration_example")

# 创建不规则四边形
p1 = gmsh.model.occ.addPoint(0, 0, 0)
p2 = gmsh.model.occ.addPoint(2, 0, 0)
p3 = gmsh.model.occ.addPoint(2.5, 1.5, 0)
p4 = gmsh.model.occ.addPoint(0.5, 1, 0)

l1 = gmsh.model.occ.addLine(p1, p2)
l2 = gmsh.model.occ.addLine(p2, p3)
l3 = gmsh.model.occ.addLine(p3, p4)
l4 = gmsh.model.occ.addLine(p4, p1)

loop = gmsh.model.occ.addCurveLoop([l1, l2, l3, l4])
surf = gmsh.model.occ.addPlaneSurface([loop])
gmsh.model.occ.synchronize()

gmsh.option.setNumber("Mesh.MeshSizeMax", 0.2)
gmsh.model.mesh.generate(2)

# 获取元素
elem_types, elem_tags, _ = gmsh.model.mesh.getElements(dim=2)

total_area = 0

for etype, etags in zip(elem_types, elem_tags):
    # 获取积分点
    local_coords, weights = gmsh.model.mesh.getIntegrationPoints(etype, "Gauss4")
    weights = np.array(weights)

    # 获取雅可比行列式
    _, determinants, _ = gmsh.model.mesh.getJacobians(etype, local_coords)
    determinants = np.array(determinants).reshape(len(etags), -1)

    # 计算面积
    # Area = Σ Σ w_i * |J_i|
    for elem_idx in range(len(etags)):
        elem_area = np.sum(weights * np.abs(determinants[elem_idx]))
        total_area += elem_area

print(f"数值积分计算的面积: {total_area:.6f}")

# 对比精确值
exact_area = gmsh.model.occ.getMass(2, surf)
print(f"精确面积: {exact_area:.6f}")
print(f"误差: {abs(total_area - exact_area):.2e}")

gmsh.finalize()
```

### 场量积分

```python
#!/usr/bin/env python3
"""
计算场量的积分
"""
import gmsh
import numpy as np

def integrate_field(field_func):
    """
    计算标量场在域上的积分
    ∫∫ f(x,y) dΩ
    """
    gmsh.initialize()
    gmsh.model.add("field_integration")

    # 创建网格
    disk = gmsh.model.occ.addDisk(0, 0, 0, 1, 1)
    gmsh.model.occ.synchronize()
    gmsh.option.setNumber("Mesh.MeshSizeMax", 0.05)
    gmsh.model.mesh.generate(2)

    elem_types, elem_tags, _ = gmsh.model.mesh.getElements(dim=2)

    total_integral = 0

    for etype, etags in zip(elem_types, elem_tags):
        local_coords, weights = gmsh.model.mesh.getIntegrationPoints(etype, "Gauss7")
        weights = np.array(weights)

        _, determinants, global_coords = gmsh.model.mesh.getJacobians(
            etype, local_coords)

        num_elements = len(etags)
        num_int_points = len(weights)

        determinants = np.array(determinants).reshape(num_elements, num_int_points)
        global_coords = np.array(global_coords).reshape(num_elements, num_int_points, 3)

        for elem_idx in range(num_elements):
            for ip in range(num_int_points):
                x, y, z = global_coords[elem_idx, ip]
                f_val = field_func(x, y, z)
                total_integral += weights[ip] * np.abs(determinants[elem_idx, ip]) * f_val

    gmsh.finalize()
    return total_integral

# 测试：积分 f(x,y) = 1 应该等于面积 π
result1 = integrate_field(lambda x, y, z: 1)
print(f"∫∫ 1 dΩ = {result1:.6f} (应为 π = {np.pi:.6f})")

# 测试：积分 f(x,y) = x^2 + y^2
result2 = integrate_field(lambda x, y, z: x**2 + y**2)
print(f"∫∫ (x² + y²) dΩ = {result2:.6f} (应为 π/2 = {np.pi/2:.6f})")
```

## 梯度计算

### 形函数梯度

```python
#!/usr/bin/env python3
"""
计算形函数在积分点的梯度
"""
import gmsh
import numpy as np

gmsh.initialize()
gmsh.model.add("gradients")

rect = gmsh.model.occ.addRectangle(0, 0, 0, 1, 1)
gmsh.model.occ.synchronize()
gmsh.option.setNumber("Mesh.MeshSizeMax", 0.3)
gmsh.model.mesh.generate(2)

elem_types, elem_tags, elem_nodes = gmsh.model.mesh.getElements(dim=2)

for etype, etags, enodes in zip(elem_types, elem_tags, elem_nodes):
    props = gmsh.model.mesh.getElementProperties(etype)
    num_nodes_per_elem = props[3]

    # 获取积分点
    local_coords, weights = gmsh.model.mesh.getIntegrationPoints(etype, "Gauss3")
    num_int_points = len(weights)

    # 获取形函数梯度
    # getBasisFunctions(elementType, localCoord, functionSpaceType, wantedOrientations=[])
    # functionSpaceType: "Lagrange", "GradLagrange", etc.

    _, gradients, num_comp = gmsh.model.mesh.getBasisFunctions(
        etype, local_coords, "GradLagrange")

    # gradients: [dN1/dξ, dN1/dη, dN1/dζ, dN2/dξ, ...] 对每个积分点
    gradients = np.array(gradients).reshape(num_int_points, -1, 3)

    print(f"元素类型: {props[0]}")
    print(f"每元素节点数: {num_nodes_per_elem}")
    print(f"积分点数: {num_int_points}")

    # 打印第一个积分点的梯度
    print(f"\n第一个积分点的形函数梯度:")
    for i in range(num_nodes_per_elem):
        print(f"  ∇N{i+1} = {gradients[0, i]}")

    break

gmsh.finalize()
```

### 全局梯度计算

```python
def compute_global_gradients(elem_type, local_gradients, jacobians):
    """
    从局部梯度计算全局梯度

    全局梯度 = J^(-T) * 局部梯度
    """
    # jacobians: (num_elements, num_int_points, 3, 3)
    # local_gradients: (num_int_points, num_nodes, 3)

    num_elements = jacobians.shape[0]
    num_int_points = jacobians.shape[1]
    num_nodes = local_gradients.shape[1]

    global_gradients = np.zeros((num_elements, num_int_points, num_nodes, 3))

    for e in range(num_elements):
        for ip in range(num_int_points):
            J = jacobians[e, ip]
            J_inv_T = np.linalg.inv(J).T  # 2D时只取2x2部分

            for n in range(num_nodes):
                local_grad = local_gradients[ip, n, :2]  # 2D
                global_grad = J_inv_T[:2, :2] @ local_grad
                global_gradients[e, ip, n, :2] = global_grad

    return global_gradients
```

## 完整示例：有限元刚度矩阵

```python
#!/usr/bin/env python3
"""
计算2D弹性问题的单元刚度矩阵
"""
import gmsh
import numpy as np

def compute_element_stiffness(E=1.0, nu=0.3):
    """计算平面应力问题的单元刚度矩阵"""

    gmsh.initialize()
    gmsh.model.add("stiffness")

    # 创建简单网格
    rect = gmsh.model.occ.addRectangle(0, 0, 0, 1, 1)
    gmsh.model.occ.synchronize()
    gmsh.option.setNumber("Mesh.MeshSizeMax", 1.0)  # 只有少量元素
    gmsh.model.mesh.generate(2)

    # 材料矩阵（平面应力）
    D = E / (1 - nu**2) * np.array([
        [1, nu, 0],
        [nu, 1, 0],
        [0, 0, (1-nu)/2]
    ])

    elem_types, elem_tags, elem_nodes = gmsh.model.mesh.getElements(dim=2)
    node_tags, node_coords, _ = gmsh.model.mesh.getNodes()
    node_coords = np.array(node_coords).reshape(-1, 3)

    for etype, etags, enodes in zip(elem_types, elem_tags, elem_nodes):
        props = gmsh.model.mesh.getElementProperties(etype)
        num_nodes = props[3]

        # 获取积分点
        local_coords, weights = gmsh.model.mesh.getIntegrationPoints(etype, "Gauss3")
        weights = np.array(weights)
        num_int_points = len(weights)

        # 获取雅可比和全局坐标
        jacobians, determinants, _ = gmsh.model.mesh.getJacobians(etype, local_coords)
        jacobians = np.array(jacobians).reshape(len(etags), num_int_points, 3, 3)
        determinants = np.array(determinants).reshape(len(etags), num_int_points)

        # 获取形函数梯度（局部）
        _, gradients, _ = gmsh.model.mesh.getBasisFunctions(
            etype, local_coords, "GradLagrange")
        gradients = np.array(gradients).reshape(num_int_points, num_nodes, 3)

        # 处理每个元素
        enodes = np.array(enodes).reshape(-1, num_nodes)

        for elem_idx, (elem_tag, nodes) in enumerate(zip(etags, enodes)):
            # 单元刚度矩阵 (2*num_nodes x 2*num_nodes)
            ndof = 2 * num_nodes
            Ke = np.zeros((ndof, ndof))

            for ip in range(num_int_points):
                # 雅可比逆转置
                J = jacobians[elem_idx, ip, :2, :2]
                J_inv_T = np.linalg.inv(J).T
                detJ = abs(determinants[elem_idx, ip])

                # 计算B矩阵（应变-位移矩阵）
                B = np.zeros((3, ndof))
                for n in range(num_nodes):
                    # 局部梯度
                    dN_local = gradients[ip, n, :2]
                    # 全局梯度
                    dN_global = J_inv_T @ dN_local

                    # B矩阵组装
                    B[0, 2*n] = dN_global[0]      # ε_xx
                    B[1, 2*n+1] = dN_global[1]    # ε_yy
                    B[2, 2*n] = dN_global[1]      # γ_xy
                    B[2, 2*n+1] = dN_global[0]

                # 刚度矩阵贡献
                Ke += B.T @ D @ B * detJ * weights[ip]

            print(f"\n元素 {elem_tag} 刚度矩阵:")
            print(f"大小: {Ke.shape}")
            print(f"对称性检查: {np.allclose(Ke, Ke.T)}")
            print(f"正定性检查: {np.all(np.linalg.eigvals(Ke) >= -1e-10)}")

            # 只处理第一个元素
            break
        break

    gmsh.finalize()

if __name__ == "__main__":
    compute_element_stiffness()
```

## 积分点相关API

| 函数 | 描述 |
|-----|------|
| getIntegrationPoints | 获取积分点坐标和权重 |
| getJacobians | 获取雅可比矩阵和行列式 |
| getBasisFunctions | 获取形函数及其梯度 |

## 下一步

- [03-基函数](./03-基函数.md) - 学习形函数详解
