# 节点与元素

获取网格的节点坐标和元素连接性是有限元分析的基础。

## 节点访问

### 获取所有节点

```python
import gmsh
import numpy as np

gmsh.initialize()
gmsh.model.add("nodes_elements")

# 创建和网格化几何
gmsh.model.occ.addBox(0, 0, 0, 1, 1, 1)
gmsh.model.occ.synchronize()
gmsh.model.mesh.generate(3)

# 获取所有节点
# getNodes(dim=-1, tag=-1, includeBoundary=False, returnParametricCoord=True)
# 返回: (nodeTags, coord, parametricCoord)
node_tags, node_coords, param_coords = gmsh.model.mesh.getNodes()

# node_tags: 节点tag数组
# node_coords: 坐标数组 [x1,y1,z1, x2,y2,z2, ...]
# param_coords: 参数坐标（用于曲面上的点）

print(f"节点数: {len(node_tags)}")
print(f"第一个节点tag: {node_tags[0]}")
print(f"第一个节点坐标: ({node_coords[0]}, {node_coords[1]}, {node_coords[2]})")

gmsh.finalize()
```

### 获取特定实体的节点

```python
# 获取指定维度和tag的实体上的节点
# dim: 维度 (0=点, 1=线, 2=面, 3=体)
# tag: 实体tag

# 获取曲面1上的节点
surface_nodes, surface_coords, _ = gmsh.model.mesh.getNodes(dim=2, tag=1)

# 获取所有曲面上的节点（tag=-1）
all_surface_nodes, all_surface_coords, _ = gmsh.model.mesh.getNodes(dim=2, tag=-1)

# 包含边界节点
nodes_with_boundary, coords, _ = gmsh.model.mesh.getNodes(
    dim=3, tag=1, includeBoundary=True)
```

### 节点坐标重组

```python
# 将坐标数组重组为(N, 3)形状
node_coords = np.array(node_coords).reshape(-1, 3)

# 创建节点字典
node_dict = {tag: coords for tag, coords in zip(node_tags, node_coords)}

# 获取特定节点的坐标
node_id = 1
if node_id in node_dict:
    print(f"节点{node_id}坐标: {node_dict[node_id]}")
```

### 添加节点

```python
# addNodes(dim, tag, nodeTags, coord, parametricCoord=[])
# 手动添加节点到实体

new_node_tags = [1001, 1002, 1003]
new_coords = [0.5, 0.5, 0,  0.6, 0.5, 0,  0.5, 0.6, 0]

gmsh.model.mesh.addNodes(2, surface_tag, new_node_tags, new_coords)
```

## 元素访问

### 获取所有元素

```python
# getElements(dim=-1, tag=-1)
# 返回: (elementTypes, elementTags, nodeTags)

elem_types, elem_tags, elem_node_tags = gmsh.model.mesh.getElements()

# elem_types: 元素类型列表
# elem_tags: 每种类型的元素tag列表
# elem_node_tags: 每种类型的节点连接性列表

for etype, etags, enodes in zip(elem_types, elem_tags, elem_node_tags):
    props = gmsh.model.mesh.getElementProperties(etype)
    name = props[0]
    dim = props[1]
    order = props[2]
    num_nodes = props[3]

    print(f"类型: {name}, 维度: {dim}, 阶数: {order}, "
          f"每元素节点数: {num_nodes}, 元素数: {len(etags)}")
```

### 获取特定维度的元素

```python
# 获取3D元素（四面体、六面体等）
elem_types_3d, elem_tags_3d, elem_nodes_3d = gmsh.model.mesh.getElements(dim=3)

# 获取2D元素（三角形、四边形）
elem_types_2d, elem_tags_2d, elem_nodes_2d = gmsh.model.mesh.getElements(dim=2)

# 获取特定曲面上的元素
elem_types_surf, elem_tags_surf, elem_nodes_surf = gmsh.model.mesh.getElements(
    dim=2, tag=surface_tag)
```

### 元素连接性

```python
#!/usr/bin/env python3
"""
获取元素连接性信息
"""
import gmsh
import numpy as np

gmsh.initialize()
gmsh.model.add("connectivity")

# 创建简单网格
rect = gmsh.model.occ.addRectangle(0, 0, 0, 1, 1)
gmsh.model.occ.synchronize()
gmsh.option.setNumber("Mesh.MeshSizeMax", 0.3)
gmsh.model.mesh.generate(2)

# 获取节点和元素
node_tags, node_coords, _ = gmsh.model.mesh.getNodes()
node_coords = np.array(node_coords).reshape(-1, 3)
node_dict = {tag: coord for tag, coord in zip(node_tags, node_coords)}

elem_types, elem_tags, elem_node_tags = gmsh.model.mesh.getElements(2)

# 处理每种元素类型
for etype, etags, enodes in zip(elem_types, elem_tags, elem_node_tags):
    props = gmsh.model.mesh.getElementProperties(etype)
    num_nodes = props[3]

    # 重组节点连接性
    enodes = np.array(enodes).reshape(-1, num_nodes)

    print(f"\n元素类型: {props[0]}")
    print(f"元素数: {len(etags)}")

    # 打印前3个元素的信息
    for i, (elem_tag, nodes) in enumerate(zip(etags[:3], enodes[:3])):
        print(f"\n  元素 {elem_tag}:")
        print(f"    节点tags: {nodes}")
        for n in nodes:
            print(f"    节点{n}: {node_dict[n]}")

gmsh.finalize()
```

### 元素类型

| 类型码 | 名称 | 节点数 | 维度 |
|-------|------|--------|------|
| 1 | Line 2 | 2 | 1 |
| 2 | Triangle 3 | 3 | 2 |
| 3 | Quadrangle 4 | 4 | 2 |
| 4 | Tetrahedron 4 | 4 | 3 |
| 5 | Hexahedron 8 | 8 | 3 |
| 6 | Prism 6 | 6 | 3 |
| 7 | Pyramid 5 | 5 | 3 |
| 8 | Line 3 | 3 | 1 |
| 9 | Triangle 6 | 6 | 2 |
| 10 | Quadrangle 9 | 9 | 2 |
| 11 | Tetrahedron 10 | 10 | 3 |
| 15 | Point 1 | 1 | 0 |

### 获取元素属性

```python
# getElementProperties(elementType)
# 返回: (name, dim, order, numNodes, localNodeCoord, numPrimaryNodes)

props = gmsh.model.mesh.getElementProperties(4)  # 四面体
print(f"名称: {props[0]}")
print(f"维度: {props[1]}")
print(f"阶数: {props[2]}")
print(f"节点数: {props[3]}")
print(f"局部节点坐标: {props[4]}")
print(f"主节点数: {props[5]}")
```

## 元素操作

### 添加元素

```python
# addElements(dim, tag, elementTypes, elementTags, nodeTags)

# 添加三角形元素
elem_type = 2  # Triangle 3
elem_tags = [1001, 1002]
node_tags = [1, 2, 3,   # 第一个三角形
             2, 4, 3]    # 第二个三角形

gmsh.model.mesh.addElements(2, surface_tag, [elem_type], [elem_tags], [node_tags])
```

### 重新编号

```python
# 重新编号节点
gmsh.model.mesh.renumberNodes()

# 重新编号元素
gmsh.model.mesh.renumberElements()
```

### 删除重复节点

```python
# 删除重复节点
gmsh.model.mesh.removeDuplicateNodes()
```

## 边界获取

### 获取边界元素

```python
# 获取3D体积的边界（2D元素）
boundary_entities = gmsh.model.getBoundary([(3, volume_tag)])

# 获取边界元素
for dim, tag in boundary_entities:
    if dim == 2:
        elem_types, elem_tags, elem_nodes = gmsh.model.mesh.getElements(dim, tag)
```

### 获取元素的边和面

```python
# getElementEdgeNodes(elementType, tag=-1, primary=False)
# 获取元素的边节点

edge_nodes = gmsh.model.mesh.getElementEdgeNodes(4)  # 四面体的边

# getElementFaceNodes(elementType, tag=-1, faceType=-1, primary=False)
# 获取元素的面节点

face_nodes = gmsh.model.mesh.getElementFaceNodes(4, faceType=2)  # 四面体的三角形面
```

## 完整示例：网格信息提取

```python
#!/usr/bin/env python3
"""
完整的网格信息提取示例
"""
import gmsh
import numpy as np

def extract_mesh_info(mesh_file=None):
    """提取网格的完整信息"""

    gmsh.initialize()

    if mesh_file:
        gmsh.merge(mesh_file)
    else:
        # 创建测试网格
        gmsh.model.add("mesh_info")
        box = gmsh.model.occ.addBox(0, 0, 0, 1, 1, 1)
        gmsh.model.occ.synchronize()
        gmsh.option.setNumber("Mesh.MeshSizeMax", 0.2)
        gmsh.model.mesh.generate(3)

    # 1. 节点信息
    print("=" * 50)
    print("节点信息")
    print("=" * 50)

    node_tags, node_coords, _ = gmsh.model.mesh.getNodes()
    node_coords = np.array(node_coords).reshape(-1, 3)

    print(f"总节点数: {len(node_tags)}")
    print(f"节点tag范围: [{min(node_tags)}, {max(node_tags)}]")
    print(f"坐标范围:")
    print(f"  X: [{node_coords[:, 0].min():.4f}, {node_coords[:, 0].max():.4f}]")
    print(f"  Y: [{node_coords[:, 1].min():.4f}, {node_coords[:, 1].max():.4f}]")
    print(f"  Z: [{node_coords[:, 2].min():.4f}, {node_coords[:, 2].max():.4f}]")

    # 2. 元素信息
    print("\n" + "=" * 50)
    print("元素信息")
    print("=" * 50)

    total_elements = 0
    elem_info = {}

    for dim in range(4):
        elem_types, elem_tags, elem_nodes = gmsh.model.mesh.getElements(dim=dim)

        for etype, etags, enodes in zip(elem_types, elem_tags, elem_nodes):
            props = gmsh.model.mesh.getElementProperties(etype)
            name = props[0]
            num_elems = len(etags)
            total_elements += num_elems

            elem_info[name] = {
                'count': num_elems,
                'dim': props[1],
                'order': props[2],
                'nodes_per_elem': props[3]
            }

    print(f"总元素数: {total_elements}")
    print("\n各类型元素:")
    for name, info in elem_info.items():
        print(f"  {name}:")
        print(f"    数量: {info['count']}")
        print(f"    维度: {info['dim']}")
        print(f"    阶数: {info['order']}")
        print(f"    节点数/元素: {info['nodes_per_elem']}")

    # 3. 几何实体信息
    print("\n" + "=" * 50)
    print("几何实体信息")
    print("=" * 50)

    for dim in range(4):
        entities = gmsh.model.getEntities(dim)
        if entities:
            print(f"维度{dim}实体数: {len(entities)}")
            for d, tag in entities[:5]:  # 只显示前5个
                # 获取该实体上的节点数
                n_tags, _, _ = gmsh.model.mesh.getNodes(dim, tag)
                print(f"  实体({d}, {tag}): {len(n_tags)}个节点")

    # 4. 物理组信息
    print("\n" + "=" * 50)
    print("物理组信息")
    print("=" * 50)

    for dim in range(-1, 4):
        groups = gmsh.model.getPhysicalGroups(dim)
        if groups:
            for d, tag in groups:
                name = gmsh.model.getPhysicalName(d, tag)
                entities = gmsh.model.getEntitiesForPhysicalGroup(d, tag)
                print(f"  物理组({d}, {tag}) '{name}': {len(entities)}个实体")

    # 5. 网格质量
    print("\n" + "=" * 50)
    print("网格质量")
    print("=" * 50)

    try:
        qualities = gmsh.model.mesh.getElementQualities([], "minSJ")
        if qualities:
            q = np.array(qualities)
            print(f"质量指标 (minSJ):")
            print(f"  最小值: {q.min():.4f}")
            print(f"  最大值: {q.max():.4f}")
            print(f"  平均值: {q.mean():.4f}")
            print(f"  标准差: {q.std():.4f}")
            print(f"  质量<0.1: {np.sum(q < 0.1)}个元素")
            print(f"  质量<0.3: {np.sum(q < 0.3)}个元素")
    except:
        print("无法获取质量信息")

    gmsh.finalize()

    return {
        'num_nodes': len(node_tags),
        'num_elements': total_elements,
        'element_types': elem_info
    }

if __name__ == "__main__":
    info = extract_mesh_info()
```

## 节点和元素遍历

```python
#!/usr/bin/env python3
"""
遍历网格节点和元素
"""
import gmsh
import numpy as np

gmsh.initialize()
gmsh.model.add("traverse")

gmsh.model.occ.addSphere(0, 0, 0, 1)
gmsh.model.occ.synchronize()
gmsh.model.mesh.generate(3)

# 创建节点坐标字典
node_tags, node_coords, _ = gmsh.model.mesh.getNodes()
node_coords = np.array(node_coords).reshape(-1, 3)
node_dict = {t: c for t, c in zip(node_tags, node_coords)}

# 遍历所有3D元素
elem_types, elem_tags, elem_node_tags = gmsh.model.mesh.getElements(dim=3)

for etype, etags, enodes in zip(elem_types, elem_tags, elem_node_tags):
    props = gmsh.model.mesh.getElementProperties(etype)
    num_nodes = props[3]
    enodes = np.array(enodes).reshape(-1, num_nodes)

    print(f"\n处理 {props[0]} 元素...")

    for i, (elem_tag, nodes) in enumerate(zip(etags, enodes)):
        # 获取元素顶点坐标
        vertices = np.array([node_dict[n] for n in nodes])

        # 计算元素中心
        centroid = vertices.mean(axis=0)

        # 计算元素体积（简化）
        if num_nodes == 4:  # 四面体
            v0, v1, v2, v3 = vertices
            volume = abs(np.dot(v1-v0, np.cross(v2-v0, v3-v0))) / 6

        if i < 3:  # 只打印前3个
            print(f"  元素{elem_tag}: 中心={centroid}, 体积={volume:.6f}")

gmsh.finalize()
```

## 下一步

- [02-积分点与雅可比](./02-积分点与雅可比.md) - 学习有限元积分数据
