# 周期性网格

周期性边界条件在电磁、晶体结构和周期性结构分析中广泛使用。

## 周期性概念

```
周期性单元胞
┌─────────────────────┐
│                     │
│    ○     ○     ○    │ ←→ 重复
│                     │
│    ○     ○     ○    │
│                     │
└─────────────────────┘
  左边界    =    右边界
  下边界    =    上边界
```

## 设置周期性约束

### 基本方法

```python
import gmsh

gmsh.initialize()
gmsh.model.add("periodic")

# 创建周期性单元
rect = gmsh.model.occ.addRectangle(0, 0, 0, 1, 1)
gmsh.model.occ.synchronize()

# 获取边界曲线
# 假设: 曲线1=底边, 曲线2=右边, 曲线3=顶边, 曲线4=左边
curves = gmsh.model.getEntities(1)

# 设置周期性约束
# setPeriodic(dim, tags, tagsMaster, affineTransform)
# affineTransform: 4x4仿射变换矩阵（展开为16元素数组）

# 左右周期性 (左=右平移1)
# 变换矩阵: 平移(1, 0, 0)
transform_x = [
    1, 0, 0, 1,   # x' = x + 1
    0, 1, 0, 0,   # y' = y
    0, 0, 1, 0,   # z' = z
    0, 0, 0, 1    # 齐次坐标
]
gmsh.model.mesh.setPeriodic(1, [4], [2], transform_x)

# 上下周期性 (底=顶平移1)
transform_y = [
    1, 0, 0, 0,
    0, 1, 0, 1,   # y' = y + 1
    0, 0, 1, 0,
    0, 0, 0, 1
]
gmsh.model.mesh.setPeriodic(1, [1], [3], transform_y)

gmsh.model.mesh.generate(2)
gmsh.write("periodic.msh")
gmsh.finalize()
```

### 获取边界实体

```python
#!/usr/bin/env python3
"""
自动识别和设置周期性边界
"""
import gmsh
import numpy as np

gmsh.initialize()
gmsh.model.add("auto_periodic")

# 创建几何
rect = gmsh.model.occ.addRectangle(0, 0, 0, 2, 1)
gmsh.model.occ.synchronize()

# 获取边界曲线
curves = gmsh.model.getEntities(1)

# 分类边界
left_curves = []
right_curves = []
bottom_curves = []
top_curves = []

for dim, tag in curves:
    bbox = gmsh.model.occ.getBoundingBox(dim, tag)
    xmin, ymin, zmin, xmax, ymax, zmax = bbox

    # 判断曲线位置
    tol = 1e-6
    if abs(xmax - xmin) < tol:  # 垂直线
        if abs(xmin - 0) < tol:
            left_curves.append(tag)
        elif abs(xmin - 2) < tol:
            right_curves.append(tag)
    elif abs(ymax - ymin) < tol:  # 水平线
        if abs(ymin - 0) < tol:
            bottom_curves.append(tag)
        elif abs(ymin - 1) < tol:
            top_curves.append(tag)

print(f"左边界: {left_curves}")
print(f"右边界: {right_curves}")
print(f"下边界: {bottom_curves}")
print(f"上边界: {top_curves}")

# 设置X方向周期性
if left_curves and right_curves:
    transform_x = [
        1, 0, 0, 2,  # 平移2
        0, 1, 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 1
    ]
    gmsh.model.mesh.setPeriodic(1, left_curves, right_curves, transform_x)

# 设置Y方向周期性
if bottom_curves and top_curves:
    transform_y = [
        1, 0, 0, 0,
        0, 1, 0, 1,  # 平移1
        0, 0, 1, 0,
        0, 0, 0, 1
    ]
    gmsh.model.mesh.setPeriodic(1, bottom_curves, top_curves, transform_y)

gmsh.model.mesh.generate(2)
gmsh.write("auto_periodic.msh")
gmsh.finalize()
```

## 3D周期性

### 立方体周期性

```python
#!/usr/bin/env python3
"""
3D周期性单元胞
"""
import gmsh

gmsh.initialize()
gmsh.model.add("periodic_3d")

# 创建立方体
box = gmsh.model.occ.addBox(0, 0, 0, 1, 1, 1)
gmsh.model.occ.synchronize()

# 获取边界面
surfaces = gmsh.model.getEntities(2)

# 分类面
faces = {'xmin': [], 'xmax': [], 'ymin': [], 'ymax': [], 'zmin': [], 'zmax': []}

for dim, tag in surfaces:
    com = gmsh.model.occ.getCenterOfMass(dim, tag)
    tol = 1e-6

    if abs(com[0] - 0) < tol:
        faces['xmin'].append(tag)
    elif abs(com[0] - 1) < tol:
        faces['xmax'].append(tag)
    elif abs(com[1] - 0) < tol:
        faces['ymin'].append(tag)
    elif abs(com[1] - 1) < tol:
        faces['ymax'].append(tag)
    elif abs(com[2] - 0) < tol:
        faces['zmin'].append(tag)
    elif abs(com[2] - 1) < tol:
        faces['zmax'].append(tag)

# X方向周期性
transform_x = [1,0,0,1, 0,1,0,0, 0,0,1,0, 0,0,0,1]
for slave, master in zip(faces['xmin'], faces['xmax']):
    gmsh.model.mesh.setPeriodic(2, [slave], [master], transform_x)

# Y方向周期性
transform_y = [1,0,0,0, 0,1,0,1, 0,0,1,0, 0,0,0,1]
for slave, master in zip(faces['ymin'], faces['ymax']):
    gmsh.model.mesh.setPeriodic(2, [slave], [master], transform_y)

# Z方向周期性
transform_z = [1,0,0,0, 0,1,0,0, 0,0,1,1, 0,0,0,1]
for slave, master in zip(faces['zmin'], faces['zmax']):
    gmsh.model.mesh.setPeriodic(2, [slave], [master], transform_z)

gmsh.option.setNumber("Mesh.MeshSizeMax", 0.2)
gmsh.model.mesh.generate(3)
gmsh.write("periodic_3d.msh")
gmsh.finalize()
```

### 带内部结构的周期性

```python
#!/usr/bin/env python3
"""
带内部孔洞的周期性结构
"""
import gmsh

gmsh.initialize()
gmsh.model.add("periodic_with_holes")

# 创建外框
box = gmsh.model.occ.addBox(0, 0, 0, 2, 2, 2)

# 创建内部孔洞（确保与边界对称）
hole = gmsh.model.occ.addSphere(1, 1, 1, 0.3)

# 布尔差集
gmsh.model.occ.cut([(3, box)], [(3, hole)])
gmsh.model.occ.synchronize()

# 识别并设置周期性边界
surfaces = gmsh.model.getEntities(2)

xmin_faces, xmax_faces = [], []
ymin_faces, ymax_faces = [], []
zmin_faces, zmax_faces = [], []

for dim, tag in surfaces:
    bbox = gmsh.model.occ.getBoundingBox(dim, tag)
    tol = 1e-6

    # X边界
    if abs(bbox[0] - 0) < tol and abs(bbox[3] - 0) < tol:
        xmin_faces.append(tag)
    elif abs(bbox[0] - 2) < tol and abs(bbox[3] - 2) < tol:
        xmax_faces.append(tag)

    # Y边界
    if abs(bbox[1] - 0) < tol and abs(bbox[4] - 0) < tol:
        ymin_faces.append(tag)
    elif abs(bbox[1] - 2) < tol and abs(bbox[4] - 2) < tol:
        ymax_faces.append(tag)

    # Z边界
    if abs(bbox[2] - 0) < tol and abs(bbox[5] - 0) < tol:
        zmin_faces.append(tag)
    elif abs(bbox[2] - 2) < tol and abs(bbox[5] - 2) < tol:
        zmax_faces.append(tag)

# 设置周期性
transform_x = [1,0,0,2, 0,1,0,0, 0,0,1,0, 0,0,0,1]
transform_y = [1,0,0,0, 0,1,0,2, 0,0,1,0, 0,0,0,1]
transform_z = [1,0,0,0, 0,1,0,0, 0,0,1,2, 0,0,0,1]

if xmin_faces and xmax_faces:
    gmsh.model.mesh.setPeriodic(2, xmin_faces, xmax_faces, transform_x)
if ymin_faces and ymax_faces:
    gmsh.model.mesh.setPeriodic(2, ymin_faces, ymax_faces, transform_y)
if zmin_faces and zmax_faces:
    gmsh.model.mesh.setPeriodic(2, zmin_faces, zmax_faces, transform_z)

gmsh.option.setNumber("Mesh.MeshSizeMax", 0.2)
gmsh.model.mesh.generate(3)
gmsh.write("periodic_with_holes.msh")
gmsh.finalize()
```

## 获取周期性信息

### 查询周期性约束

```python
# getPeriodicNodes(dim, tag, tagMaster=-1, includeBoundary=True)
# 获取周期性节点对

periodic_nodes = gmsh.model.mesh.getPeriodicNodes(2, slave_tag)
# 返回: (nodeTagsMaster, affineTransform)
```

### 周期性节点对

```python
#!/usr/bin/env python3
"""
获取周期性节点对应关系
"""
import gmsh
import numpy as np

gmsh.initialize()
gmsh.model.add("periodic_pairs")

# 创建网格
rect = gmsh.model.occ.addRectangle(0, 0, 0, 1, 1)
gmsh.model.occ.synchronize()

# 设置周期性
curves = gmsh.model.getEntities(1)
# 假设曲线tag已知
transform_x = [1,0,0,1, 0,1,0,0, 0,0,1,0, 0,0,0,1]

# 找到左右边界
left_curve = None
right_curve = None
for dim, tag in curves:
    bbox = gmsh.model.occ.getBoundingBox(dim, tag)
    if abs(bbox[0] - 0) < 1e-6 and abs(bbox[3] - 0) < 1e-6:
        left_curve = tag
    elif abs(bbox[0] - 1) < 1e-6 and abs(bbox[3] - 1) < 1e-6:
        right_curve = tag

if left_curve and right_curve:
    gmsh.model.mesh.setPeriodic(1, [left_curve], [right_curve], transform_x)

gmsh.option.setNumber("Mesh.MeshSizeMax", 0.2)
gmsh.model.mesh.generate(2)

# 获取周期性节点信息
if left_curve:
    try:
        master_nodes, transform = gmsh.model.mesh.getPeriodicNodes(1, left_curve)
        slave_nodes, _, _ = gmsh.model.mesh.getNodes(1, left_curve)

        print(f"从属节点数: {len(slave_nodes)}")
        print(f"主节点数: {len(master_nodes)}")

        # 验证对应关系
        node_tags, node_coords, _ = gmsh.model.mesh.getNodes()
        node_coords = np.array(node_coords).reshape(-1, 3)
        node_dict = {t: c for t, c in zip(node_tags, node_coords)}

        for i, (slave, master) in enumerate(zip(slave_nodes[:3], master_nodes[:3])):
            slave_coord = node_dict.get(slave, [0,0,0])
            master_coord = node_dict.get(master, [0,0,0])
            print(f"对 {i+1}: 从属节点{slave}{slave_coord} <-> 主节点{master}{master_coord}")

    except Exception as e:
        print(f"获取周期性节点失败: {e}")

gmsh.finalize()
```

## 复杂周期性

### 旋转周期性

```python
#!/usr/bin/env python3
"""
旋转周期性（如风扇叶片）
"""
import gmsh
import numpy as np

gmsh.initialize()
gmsh.model.add("rotational_periodic")

# 创建扇形区域（1/4圆）
disk = gmsh.model.occ.addDisk(0, 0, 0, 1, 1)
box = gmsh.model.occ.addRectangle(0, 0, 0, 2, 2)
gmsh.model.occ.intersect([(2, disk)], [(2, box)])
gmsh.model.occ.synchronize()

# 找到径向边界
curves = gmsh.model.getEntities(1)
radial_curves = []

for dim, tag in curves:
    com = gmsh.model.occ.getCenterOfMass(dim, tag)
    # 判断是否是径向边界
    length = gmsh.model.occ.getMass(dim, tag)
    if abs(length - 1) < 0.1:  # 半径为1的直线
        radial_curves.append(tag)

print(f"找到 {len(radial_curves)} 条径向曲线")

# 90度旋转变换矩阵
theta = np.pi / 2
cos_t, sin_t = np.cos(theta), np.sin(theta)
transform_rot = [
    cos_t, -sin_t, 0, 0,
    sin_t, cos_t, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1
]

# 设置旋转周期性（需要确定从属和主边界）
# 这需要根据具体几何确定

gmsh.option.setNumber("Mesh.MeshSizeMax", 0.1)
gmsh.model.mesh.generate(2)
gmsh.write("rotational_periodic.msh")
gmsh.finalize()
```

### 斜向周期性

```python
#!/usr/bin/env python3
"""
斜向周期性（平行四边形单元胞）
"""
import gmsh

gmsh.initialize()
gmsh.model.add("skew_periodic")

# 创建平行四边形
p1 = gmsh.model.occ.addPoint(0, 0, 0)
p2 = gmsh.model.occ.addPoint(2, 0, 0)
p3 = gmsh.model.occ.addPoint(3, 1, 0)  # 斜向
p4 = gmsh.model.occ.addPoint(1, 1, 0)

l1 = gmsh.model.occ.addLine(p1, p2)
l2 = gmsh.model.occ.addLine(p2, p3)
l3 = gmsh.model.occ.addLine(p3, p4)
l4 = gmsh.model.occ.addLine(p4, p1)

loop = gmsh.model.occ.addCurveLoop([l1, l2, l3, l4])
surf = gmsh.model.occ.addPlaneSurface([loop])
gmsh.model.occ.synchronize()

# 设置周期性
# X方向: l4(左) -> l2(右), 平移(2, 0, 0)
transform_x = [1,0,0,2, 0,1,0,0, 0,0,1,0, 0,0,0,1]
gmsh.model.mesh.setPeriodic(1, [l4], [l2], transform_x)

# Y方向（斜向）: l1(底) -> l3(顶), 平移(1, 1, 0)
transform_y = [1,0,0,1, 0,1,0,1, 0,0,1,0, 0,0,0,1]
gmsh.model.mesh.setPeriodic(1, [l1], [l3], transform_y)

gmsh.option.setNumber("Mesh.MeshSizeMax", 0.1)
gmsh.model.mesh.generate(2)
gmsh.write("skew_periodic.msh")
gmsh.finalize()
```

## 完整示例：光子晶体

```python
#!/usr/bin/env python3
"""
2D光子晶体周期性单元胞
"""
import gmsh
import numpy as np

def create_photonic_crystal():
    gmsh.initialize()
    gmsh.model.add("photonic_crystal")

    # 参数
    a = 1.0         # 晶格常数
    r = 0.3 * a     # 圆柱半径

    # 创建正方形单元胞
    rect = gmsh.model.occ.addRectangle(0, 0, 0, a, a)

    # 创建中心圆柱
    cylinder = gmsh.model.occ.addDisk(a/2, a/2, 0, r, r)

    # 布尔差集
    gmsh.model.occ.cut([(2, rect)], [(2, cylinder)])
    gmsh.model.occ.synchronize()

    # 识别边界
    curves = gmsh.model.getEntities(1)
    left, right, bottom, top = [], [], [], []

    for dim, tag in curves:
        bbox = gmsh.model.occ.getBoundingBox(dim, tag)
        tol = 1e-6

        if abs(bbox[0] - 0) < tol and abs(bbox[3] - 0) < tol:
            left.append(tag)
        elif abs(bbox[0] - a) < tol and abs(bbox[3] - a) < tol:
            right.append(tag)
        elif abs(bbox[1] - 0) < tol and abs(bbox[4] - 0) < tol:
            bottom.append(tag)
        elif abs(bbox[1] - a) < tol and abs(bbox[4] - a) < tol:
            top.append(tag)

    # 设置周期性
    transform_x = [1,0,0,a, 0,1,0,0, 0,0,1,0, 0,0,0,1]
    transform_y = [1,0,0,0, 0,1,0,a, 0,0,1,0, 0,0,0,1]

    if left and right:
        gmsh.model.mesh.setPeriodic(1, left, right, transform_x)
    if bottom and top:
        gmsh.model.mesh.setPeriodic(1, bottom, top, transform_y)

    # 物理组
    surfaces = gmsh.model.getEntities(2)
    gmsh.model.addPhysicalGroup(2, [s[1] for s in surfaces], name="Dielectric")

    # 边界
    all_curves = [c[1] for c in curves]
    gmsh.model.addPhysicalGroup(1, all_curves, name="Boundary")

    # 网格
    gmsh.option.setNumber("Mesh.MeshSizeMax", 0.05)
    gmsh.option.setNumber("Mesh.MeshSizeFromCurvature", 20)
    gmsh.model.mesh.generate(2)

    # 统计
    nodes, _, _ = gmsh.model.mesh.getNodes()
    print(f"节点数: {len(nodes)}")

    gmsh.write("photonic_crystal.msh")
    gmsh.finalize()

if __name__ == "__main__":
    create_photonic_crystal()
```

## 周期性选项汇总

| 函数 | 描述 |
|-----|------|
| setPeriodic | 设置周期性约束 |
| getPeriodicNodes | 获取周期性节点对 |
| getPeriodicKeys | 获取周期性键 |

## 变换矩阵格式

```
4x4仿射变换矩阵（行主序展开）:
[a11, a12, a13, tx,
 a21, a22, a23, ty,
 a31, a32, a33, tz,
   0,   0,   0,  1]

常用变换：
- 平移: aij = δij, (tx, ty, tz) = 平移向量
- 旋转: 旋转矩阵在aij中, (tx, ty, tz) = 0
- 缩放: aii = 缩放因子, 其他aij = 0
```

## 下一步

完成网格数据访问学习后，请继续：
- [06-API编程指南](../06-API编程指南/01-Python-API完整指南.md) - 学习API编程的完整指南
