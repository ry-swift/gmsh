# 基函数

Gmsh提供了完整的有限元基函数（形函数）访问接口。

## 基函数类型

```
线性基函数            二次基函数            三次基函数
    •                    •                    •
   /│\                  /│\                  /│\
  / │ \                / │ \                / │ \
 /  │  \              /  │  \              /  •  \
•───•───•            •──•──•              •─•─•─•─•
                       │                    │   │
3节点三角形          6节点三角形          10节点三角形
```

## 获取基函数

### 基本用法

```python
import gmsh
import numpy as np

gmsh.initialize()

# getBasisFunctions(elementType, localCoord, functionSpaceType, wantedOrientations=[])
# functionSpaceType:
#   "Lagrange" - Lagrange基函数值
#   "GradLagrange" - Lagrange基函数梯度
#   "HcurlLagrange" - H(curl)基函数
#   "HdivLagrange" - H(div)基函数

elem_type = 2  # Triangle 3
local_coords = [0.25, 0.25, 0]  # 参考元素上的点

# 获取形函数值
num_comp, basis_values, num_orient = gmsh.model.mesh.getBasisFunctions(
    elem_type, local_coords, "Lagrange")

print(f"分量数: {num_comp}")
print(f"基函数值: {basis_values}")
print(f"方向数: {num_orient}")

gmsh.finalize()
```

### 在多点评估

```python
# 在多个点评估基函数
local_coords = [
    0, 0, 0,        # 点1
    1, 0, 0,        # 点2
    0, 1, 0,        # 点3
    0.33, 0.33, 0   # 重心
]

num_comp, basis_values, _ = gmsh.model.mesh.getBasisFunctions(
    elem_type, local_coords, "Lagrange")

num_points = len(local_coords) // 3
num_funcs = len(basis_values) // num_points

basis_values = np.array(basis_values).reshape(num_points, num_funcs)
print(f"基函数矩阵形状: {basis_values.shape}")
print(f"基函数值:\n{basis_values}")
```

## Lagrange基函数

### 线性元素

```python
#!/usr/bin/env python3
"""
线性三角形基函数
"""
import gmsh
import numpy as np

gmsh.initialize()

elem_type = 2  # Triangle 3 (线性)

# 在参考三角形上均匀采样
n = 10
points = []
for i in range(n + 1):
    for j in range(n + 1 - i):
        xi = i / n
        eta = j / n
        points.extend([xi, eta, 0])

# 评估基函数
num_comp, basis, _ = gmsh.model.mesh.getBasisFunctions(
    elem_type, points, "Lagrange")

num_points = len(points) // 3
num_funcs = len(basis) // num_points
basis = np.array(basis).reshape(num_points, num_funcs)

print(f"线性三角形:")
print(f"  节点数: {num_funcs}")
print(f"  采样点数: {num_points}")

# 验证分区性质: Σ N_i = 1
sums = basis.sum(axis=1)
print(f"  基函数和检查: {np.allclose(sums, 1)}")

# 验证节点性质: N_i(x_j) = δ_ij
vertices = [0, 0, 0,  1, 0, 0,  0, 1, 0]
_, vertex_basis, _ = gmsh.model.mesh.getBasisFunctions(
    elem_type, vertices, "Lagrange")
vertex_basis = np.array(vertex_basis).reshape(3, 3)
print(f"  顶点处基函数值:\n{vertex_basis}")

gmsh.finalize()
```

### 二次元素

```python
#!/usr/bin/env python3
"""
二次三角形基函数
"""
import gmsh
import numpy as np

gmsh.initialize()

elem_type = 9  # Triangle 6 (二次)

# 获取节点位置
props = gmsh.model.mesh.getElementProperties(elem_type)
node_coords = np.array(props[4]).reshape(-1, 3)
print(f"二次三角形节点位置:\n{node_coords}")

# 在节点处评估
node_list = node_coords.flatten().tolist()
_, basis, _ = gmsh.model.mesh.getBasisFunctions(
    elem_type, node_list, "Lagrange")

basis = np.array(basis).reshape(6, 6)
print(f"\n节点处基函数值（应为单位矩阵）:\n{np.round(basis, 4)}")

gmsh.finalize()
```

### 高阶元素

```python
# 不同阶数的三角形元素
triangle_types = {
    2: "Triangle 3 (P1)",
    9: "Triangle 6 (P2)",
    21: "Triangle 10 (P3)",
    23: "Triangle 15 (P4)",
}

for etype, name in triangle_types.items():
    props = gmsh.model.mesh.getElementProperties(etype)
    print(f"{name}: {props[3]}个节点, {props[2]}阶")
```

## 基函数梯度

### 获取梯度

```python
#!/usr/bin/env python3
"""
获取基函数梯度
"""
import gmsh
import numpy as np

gmsh.initialize()

elem_type = 2  # Triangle 3

# 积分点
local_coords = [0.5, 0.25, 0]

# 获取梯度
num_comp, gradients, _ = gmsh.model.mesh.getBasisFunctions(
    elem_type, local_coords, "GradLagrange")

# gradients: [dN1/dxi, dN1/deta, dN1/dzeta, dN2/dxi, ...]
num_funcs = len(gradients) // 3
gradients = np.array(gradients).reshape(num_funcs, 3)

print(f"线性三角形基函数梯度:")
for i in range(num_funcs):
    print(f"  ∇N{i+1} = ({gradients[i, 0]:.4f}, {gradients[i, 1]:.4f})")

# 验证：线性元素梯度应为常数
other_point = [0.2, 0.3, 0]
_, gradients2, _ = gmsh.model.mesh.getBasisFunctions(
    elem_type, other_point, "GradLagrange")
gradients2 = np.array(gradients2).reshape(num_funcs, 3)

print(f"\n另一点的梯度:")
for i in range(num_funcs):
    print(f"  ∇N{i+1} = ({gradients2[i, 0]:.4f}, {gradients2[i, 1]:.4f})")

print(f"\n梯度恒定: {np.allclose(gradients, gradients2)}")

gmsh.finalize()
```

### 二次元素梯度

```python
elem_type = 9  # Triangle 6

local_coords = [0.5, 0.25, 0]
_, gradients, _ = gmsh.model.mesh.getBasisFunctions(
    elem_type, local_coords, "GradLagrange")

num_funcs = len(gradients) // 3
gradients = np.array(gradients).reshape(num_funcs, 3)

print(f"二次三角形基函数梯度:")
for i in range(num_funcs):
    print(f"  ∇N{i+1} = ({gradients[i, 0]:.4f}, {gradients[i, 1]:.4f})")
```

## 特殊基函数

### H(curl)基函数

用于电磁场问题（边元素）。

```python
# H(curl) 基函数（Nédélec元素）
elem_type = 2  # Triangle
local_coords = [0.33, 0.33, 0]

try:
    _, hcurl_basis, _ = gmsh.model.mesh.getBasisFunctions(
        elem_type, local_coords, "HcurlLagrange")
    print(f"H(curl)基函数: {hcurl_basis}")
except:
    print("此元素类型可能不支持H(curl)基函数")
```

### H(div)基函数

用于流体力学（面元素）。

```python
# H(div) 基函数（Raviart-Thomas元素）
try:
    _, hdiv_basis, _ = gmsh.model.mesh.getBasisFunctions(
        elem_type, local_coords, "HdivLagrange")
    print(f"H(div)基函数: {hdiv_basis}")
except:
    print("此元素类型可能不支持H(div)基函数")
```

## 基函数插值

### 节点值插值

```python
#!/usr/bin/env python3
"""
使用基函数进行插值
"""
import gmsh
import numpy as np

def interpolate(node_values, elem_type, local_coord):
    """
    在参考元素的指定点插值

    node_values: 节点上的值
    elem_type: 元素类型
    local_coord: 局部坐标 [xi, eta, zeta]
    """
    _, basis, _ = gmsh.model.mesh.getBasisFunctions(
        elem_type, local_coord, "Lagrange")

    basis = np.array(basis)
    return np.dot(basis, node_values)

gmsh.initialize()

# 三角形节点值
node_values = np.array([1.0, 2.0, 3.0])  # 三个顶点的值

# 在中心点插值
center = [1/3, 1/3, 0]
value_at_center = interpolate(node_values, 2, center)
print(f"中心点插值: {value_at_center:.4f}")
print(f"期望值（平均）: {node_values.mean():.4f}")

# 在顶点插值（验证）
vertices = [[0, 0, 0], [1, 0, 0], [0, 1, 0]]
for i, v in enumerate(vertices):
    val = interpolate(node_values, 2, v)
    print(f"顶点{i+1}插值: {val:.4f}, 节点值: {node_values[i]:.4f}")

gmsh.finalize()
```

### 梯度插值

```python
def interpolate_gradient(node_values, elem_type, local_coord):
    """
    插值梯度

    返回: [df/dxi, df/deta]
    """
    _, gradients, _ = gmsh.model.mesh.getBasisFunctions(
        elem_type, local_coord, "GradLagrange")

    num_funcs = len(node_values)
    gradients = np.array(gradients).reshape(num_funcs, 3)

    grad = np.zeros(3)
    for i in range(num_funcs):
        grad += node_values[i] * gradients[i]

    return grad[:2]  # 2D

# 测试
node_values = np.array([0.0, 1.0, 0.0])  # f = x
grad = interpolate_gradient(node_values, 2, [0.5, 0.25, 0])
print(f"梯度: {grad}")  # 应该是 [1, 0]
```

## 完整示例：FEM场插值

```python
#!/usr/bin/env python3
"""
完整的有限元场插值示例
"""
import gmsh
import numpy as np

def create_mesh_and_field():
    """创建网格并定义节点场"""
    gmsh.initialize()
    gmsh.model.add("interpolation")

    # 创建网格
    disk = gmsh.model.occ.addDisk(0, 0, 0, 1, 1)
    gmsh.model.occ.synchronize()
    gmsh.option.setNumber("Mesh.MeshSizeMax", 0.2)
    gmsh.model.mesh.generate(2)

    # 获取节点
    node_tags, node_coords, _ = gmsh.model.mesh.getNodes()
    node_coords = np.array(node_coords).reshape(-1, 3)

    # 定义节点场（例如温度）
    node_values = {}
    for tag, coord in zip(node_tags, node_coords):
        x, y, z = coord
        # 温度场: T = 100 * exp(-r^2)
        T = 100 * np.exp(-(x**2 + y**2))
        node_values[tag] = T

    return node_tags, node_coords, node_values

def interpolate_at_point(x, y, node_values, elem_type, elem_nodes, node_dict):
    """
    在给定点(x,y)进行场插值

    需要先找到包含该点的元素
    """
    # 简化：假设点在某个元素内，使用该元素的形函数

    # 获取元素节点坐标
    elem_coords = np.array([node_dict[n] for n in elem_nodes])

    # 计算局部坐标（对于三角形使用面积坐标）
    x1, y1, _ = elem_coords[0]
    x2, y2, _ = elem_coords[1]
    x3, y3, _ = elem_coords[2]

    # 面积
    A = 0.5 * ((x2-x1)*(y3-y1) - (x3-x1)*(y2-y1))

    # 面积坐标
    L1 = 0.5 * ((x2*y3-x3*y2) + (y2-y3)*x + (x3-x2)*y) / A
    L2 = 0.5 * ((x3*y1-x1*y3) + (y3-y1)*x + (x1-x3)*y) / A
    L3 = 1 - L1 - L2

    local_coord = [L2, L3, 0]  # 转换为参考坐标

    # 获取基函数值
    _, basis, _ = gmsh.model.mesh.getBasisFunctions(
        elem_type, local_coord, "Lagrange")

    # 插值
    values = [node_values[n] for n in elem_nodes]
    return np.dot(basis, values)

def main():
    node_tags, node_coords, node_values = create_mesh_and_field()
    node_dict = {t: c for t, c in zip(node_tags, node_coords)}

    # 获取元素
    elem_types, elem_tags, elem_node_tags = gmsh.model.mesh.getElements(dim=2)

    for etype, etags, enodes in zip(elem_types, elem_tags, elem_node_tags):
        props = gmsh.model.mesh.getElementProperties(etype)
        num_nodes = props[3]
        enodes = np.array(enodes).reshape(-1, num_nodes)

        # 在第一个元素的中心插值
        elem_nodes = enodes[0]
        elem_coords = np.array([node_dict[n] for n in elem_nodes])
        center = elem_coords.mean(axis=0)

        value = interpolate_at_point(
            center[0], center[1],
            node_values, etype, elem_nodes, node_dict)

        # 精确值
        exact = 100 * np.exp(-(center[0]**2 + center[1]**2))

        print(f"中心点 ({center[0]:.3f}, {center[1]:.3f}):")
        print(f"  插值值: {value:.4f}")
        print(f"  精确值: {exact:.4f}")
        print(f"  误差: {abs(value - exact):.4f}")

        break

    gmsh.finalize()

if __name__ == "__main__":
    main()
```

## 基函数类型汇总

| 函数空间 | 用途 | 连续性 |
|---------|------|--------|
| Lagrange | 标量场（温度、位移） | C0连续 |
| GradLagrange | Lagrange基函数梯度 | - |
| HcurlLagrange | 向量场（电场、磁场） | 切向连续 |
| HdivLagrange | 通量（速度、热流） | 法向连续 |

## 下一步

- [04-网格分割](./04-网格分割.md) - 学习网格分区用于并行计算
