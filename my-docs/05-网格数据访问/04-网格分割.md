# 网格分割

网格分割（分区）是并行计算的基础，Gmsh提供多种分区方法。

## 分区基础

### 基本分区

```python
import gmsh

gmsh.initialize()
gmsh.model.add("partition")

# 创建网格
box = gmsh.model.occ.addBox(0, 0, 0, 2, 2, 2)
gmsh.model.occ.synchronize()
gmsh.model.mesh.generate(3)

# 分区
# partition(numPartitions)
gmsh.model.mesh.partition(4)  # 分为4个部分

gmsh.write("partitioned.msh")
gmsh.finalize()
```

### 分区选项

```python
# 分区算法
# 1: Metis (默认)
# 2: Simple (简单切分)
gmsh.option.setNumber("Mesh.PartitionAlgorithm", 1)

# 其他选项
gmsh.option.setNumber("Mesh.PartitionCreatePhysicals", 1)
gmsh.option.setNumber("Mesh.PartitionCreateTopology", 1)
gmsh.option.setNumber("Mesh.PartitionOldStyleMsh2", 0)
```

## METIS分区

### 配置METIS

```python
# METIS是默认的分区算法
gmsh.option.setNumber("Mesh.PartitionAlgorithm", 1)

# METIS优化目标
# 1: 边切割最小化
# 2: 通信体积最小化
gmsh.option.setNumber("Mesh.MetisAlgorithm", 1)

# METIS边权重
# 0: 无权重
# 1: 使用边权重
gmsh.option.setNumber("Mesh.MetisEdgeMatching", 0)

# METIS细化迭代
gmsh.option.setNumber("Mesh.MetisRefinementIterations", 10)
```

### 完整METIS示例

```python
#!/usr/bin/env python3
"""
使用METIS进行网格分区
"""
import gmsh
import numpy as np

gmsh.initialize()
gmsh.model.add("metis_partition")

# 创建复杂几何
box = gmsh.model.occ.addBox(0, 0, 0, 10, 10, 10)
sphere = gmsh.model.occ.addSphere(5, 5, 5, 3)
gmsh.model.occ.cut([(3, box)], [(3, sphere)])
gmsh.model.occ.synchronize()

# 网格生成
gmsh.option.setNumber("Mesh.MeshSizeMax", 1.0)
gmsh.model.mesh.generate(3)

# 分区前的统计
elem_types, elem_tags, _ = gmsh.model.mesh.getElements(dim=3)
total_elements = sum(len(t) for t in elem_tags)
print(f"分区前总元素数: {total_elements}")

# 配置METIS
gmsh.option.setNumber("Mesh.PartitionAlgorithm", 1)
gmsh.option.setNumber("Mesh.PartitionCreateTopology", 1)

# 执行分区
num_partitions = 8
gmsh.model.mesh.partition(num_partitions)

# 分区后信息
print(f"\n分为 {num_partitions} 个分区")

# 保存分区网格
gmsh.write("metis_partitioned.msh")

gmsh.finalize()
```

## 简单分区

### 几何分区

```python
# 简单分区算法（基于坐标）
gmsh.option.setNumber("Mesh.PartitionAlgorithm", 2)

# 分割方向
# 0: 自动
# 1: X方向
# 2: Y方向
# 3: Z方向
gmsh.option.setNumber("Mesh.PartitionSplitDirection", 0)

gmsh.model.mesh.partition(4)
```

## 获取分区信息

### 查询分区

```python
#!/usr/bin/env python3
"""
获取分区信息
"""
import gmsh
import numpy as np

gmsh.initialize()
gmsh.merge("partitioned.msh")

# 获取所有分区实体
partitions = gmsh.model.getPartitions()
print(f"分区数: {len(partitions)}")

# 获取每个分区的元素
for partition_tag in partitions:
    # 获取该分区的实体
    entities = gmsh.model.getEntitiesForPhysicalGroup(3, partition_tag)
    print(f"分区 {partition_tag}: {len(entities)} 个实体")

gmsh.finalize()
```

### 分区元素统计

```python
#!/usr/bin/env python3
"""
统计各分区的元素数
"""
import gmsh
import numpy as np
from collections import defaultdict

gmsh.initialize()
gmsh.model.add("partition_stats")

# 创建网格
gmsh.model.occ.addBox(0, 0, 0, 1, 1, 1)
gmsh.model.occ.synchronize()
gmsh.option.setNumber("Mesh.MeshSizeMax", 0.1)
gmsh.model.mesh.generate(3)

# 分区
num_parts = 4
gmsh.model.mesh.partition(num_parts)

# 统计
# 获取元素的分区信息
elem_types, elem_tags, elem_nodes = gmsh.model.mesh.getElements(dim=3)

# 获取分区标签（如果支持）
# 这需要通过物理组或其他方式获取

# 通过保存和重新加载获取分区信息
gmsh.write("temp_partition.msh")
gmsh.clear()
gmsh.merge("temp_partition.msh")

# 检查物理组（分区会创建物理组）
physical_groups = gmsh.model.getPhysicalGroups()
print(f"物理组: {physical_groups}")

gmsh.finalize()
```

## 分区边界

### 共享边界处理

```python
#!/usr/bin/env python3
"""
处理分区边界
"""
import gmsh

gmsh.initialize()
gmsh.model.add("partition_boundary")

# 创建网格
rect = gmsh.model.occ.addRectangle(0, 0, 0, 2, 1)
gmsh.model.occ.synchronize()
gmsh.option.setNumber("Mesh.MeshSizeMax", 0.1)
gmsh.model.mesh.generate(2)

# 分区
gmsh.option.setNumber("Mesh.PartitionCreateTopology", 1)
gmsh.model.mesh.partition(4)

# 获取边界
# 分区边界是分区之间的共享实体

# 保存并重新加载以获取完整拓扑
gmsh.write("part_boundary.msh")

gmsh.finalize()
```

### Ghost元素

对于某些求解器，需要ghost元素（幽灵元素）来处理分区边界。

```python
# 创建带ghost元素的分区
gmsh.option.setNumber("Mesh.PartitionCreateGhostCells", 1)
gmsh.option.setNumber("Mesh.GhostCellLayers", 1)  # ghost层数

gmsh.model.mesh.partition(4)
```

## 并行网格生成

### MPI并行

```python
# Gmsh支持并行网格生成
# 通过OpenMP或MPI

# 设置线程数
gmsh.option.setNumber("General.NumThreads", 8)

# 使用并行算法
gmsh.option.setNumber("Mesh.Algorithm3D", 10)  # HXT（并行）
```

### 分布式网格

```python
#!/usr/bin/env python3
"""
为分布式计算准备网格
"""
import gmsh
import os

def create_distributed_mesh(num_parts):
    """创建分布式网格文件"""

    gmsh.initialize()
    gmsh.model.add("distributed")

    # 创建大型网格
    gmsh.model.occ.addBox(0, 0, 0, 10, 10, 10)
    gmsh.model.occ.synchronize()
    gmsh.option.setNumber("Mesh.MeshSizeMax", 0.5)
    gmsh.model.mesh.generate(3)

    # 分区
    gmsh.model.mesh.partition(num_parts)

    # 创建输出目录
    os.makedirs("mesh_parts", exist_ok=True)

    # 保存完整网格（用于调试）
    gmsh.write("mesh_parts/full_mesh.msh")

    # 可以根据需要为每个分区保存单独文件
    # （需要手动提取）

    gmsh.finalize()

if __name__ == "__main__":
    create_distributed_mesh(16)
```

## 负载均衡

### 元素权重

```python
# 使用元素权重进行负载均衡
# 对于非均匀计算负载很有用

# 设置元素权重（通过用户定义）
# 目前Gmsh主要通过METIS自动处理

# 可以考虑基于元素大小的权重
# 或基于物理性质的权重
```

### 自定义分区

```python
#!/usr/bin/env python3
"""
自定义分区策略
"""
import gmsh
import numpy as np

def custom_partition(num_parts):
    """基于坐标的自定义分区"""

    gmsh.initialize()
    gmsh.model.add("custom_partition")

    # 创建网格
    gmsh.model.occ.addBox(0, 0, 0, 4, 2, 2)
    gmsh.model.occ.synchronize()
    gmsh.model.mesh.generate(3)

    # 获取元素中心
    elem_types, elem_tags, elem_nodes = gmsh.model.mesh.getElements(dim=3)
    node_tags, node_coords, _ = gmsh.model.mesh.getNodes()
    node_coords = np.array(node_coords).reshape(-1, 3)
    node_dict = {t: c for t, c in zip(node_tags, node_coords)}

    # 为每个元素计算分区
    for etype, etags, enodes in zip(elem_types, elem_tags, elem_nodes):
        props = gmsh.model.mesh.getElementProperties(etype)
        num_nodes = props[3]
        enodes = np.array(enodes).reshape(-1, num_nodes)

        for elem_tag, nodes in zip(etags, enodes):
            # 计算元素中心
            center = np.mean([node_dict[n] for n in nodes], axis=0)

            # 基于X坐标分区
            partition_id = int(center[0] / 4 * num_parts)
            partition_id = min(partition_id, num_parts - 1)

            # 这里只是示例，实际需要使用适当的API设置分区

    gmsh.finalize()

custom_partition(4)
```

## 完整示例：并行求解准备

```python
#!/usr/bin/env python3
"""
为并行有限元求解准备网格
"""
import gmsh
import numpy as np
import json

def prepare_parallel_mesh(geometry_file, num_processes):
    """
    准备并行求解的网格

    返回每个进程需要的数据
    """

    gmsh.initialize()
    gmsh.model.add("parallel_prep")

    # 加载几何（或创建）
    if geometry_file:
        gmsh.merge(geometry_file)
    else:
        # 创建测试几何
        gmsh.model.occ.addBox(0, 0, 0, 1, 1, 1)
        gmsh.model.occ.synchronize()

    # 网格生成
    gmsh.option.setNumber("Mesh.MeshSizeMax", 0.1)
    gmsh.option.setNumber("Mesh.Algorithm3D", 10)  # HXT并行
    gmsh.option.setNumber("General.NumThreads", 4)
    gmsh.model.mesh.generate(3)

    # 分区
    gmsh.option.setNumber("Mesh.PartitionAlgorithm", 1)  # METIS
    gmsh.option.setNumber("Mesh.PartitionCreateTopology", 1)
    gmsh.model.mesh.partition(num_processes)

    # 收集网格信息
    mesh_info = {
        'num_processes': num_processes,
        'partitions': []
    }

    # 获取节点和元素
    node_tags, node_coords, _ = gmsh.model.mesh.getNodes()
    node_coords = np.array(node_coords).reshape(-1, 3)

    mesh_info['total_nodes'] = len(node_tags)
    mesh_info['total_elements'] = 0

    elem_types, elem_tags, _ = gmsh.model.mesh.getElements(dim=3)
    for etags in elem_tags:
        mesh_info['total_elements'] += len(etags)

    # 保存网格
    gmsh.write("parallel_mesh.msh")

    # 创建分区信息文件
    with open("partition_info.json", "w") as f:
        json.dump(mesh_info, f, indent=2)

    print(f"网格准备完成:")
    print(f"  总节点数: {mesh_info['total_nodes']}")
    print(f"  总元素数: {mesh_info['total_elements']}")
    print(f"  分区数: {num_processes}")

    gmsh.finalize()

    return mesh_info

if __name__ == "__main__":
    info = prepare_parallel_mesh(None, 8)
```

## 分区选项汇总

| 选项 | 描述 | 默认值 |
|-----|------|-------|
| PartitionAlgorithm | 分区算法(1=METIS,2=Simple) | 1 |
| PartitionCreateTopology | 创建分区拓扑 | 1 |
| PartitionCreatePhysicals | 创建分区物理组 | 1 |
| PartitionCreateGhostCells | 创建ghost元素 | 0 |
| GhostCellLayers | ghost层数 | 1 |

## 下一步

- [05-周期性网格](./05-周期性网格.md) - 学习周期边界条件的网格处理
