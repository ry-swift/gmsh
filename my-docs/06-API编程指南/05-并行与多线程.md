# 并行与多线程

Gmsh支持多种并行计算方法来加速网格生成。

## OpenMP多线程

### 设置线程数

```python
import gmsh

gmsh.initialize()

# 设置全局线程数
gmsh.option.setNumber("General.NumThreads", 8)

# 或者使用系统所有核心
import os
num_cores = os.cpu_count()
gmsh.option.setNumber("General.NumThreads", num_cores)

print(f"使用 {num_cores} 个线程")

gmsh.finalize()
```

### 支持多线程的操作

```python
#!/usr/bin/env python3
"""
多线程网格生成示例
"""
import gmsh
import time
import os

gmsh.initialize()
gmsh.model.add("parallel_mesh")

# 创建大型几何
gmsh.model.occ.addBox(0, 0, 0, 10, 10, 10)
for i in range(5):
    for j in range(5):
        for k in range(5):
            if (i + j + k) % 2 == 0:
                sphere = gmsh.model.occ.addSphere(
                    i * 2 + 1, j * 2 + 1, k * 2 + 1, 0.4)
                gmsh.model.occ.cut([(3, 1)], [(3, sphere)], removeObject=True, removeTool=True)

gmsh.model.occ.synchronize()

# 网格尺寸
gmsh.option.setNumber("Mesh.MeshSizeMax", 0.3)

# 测试不同线程数
for num_threads in [1, 2, 4, 8]:
    gmsh.option.setNumber("General.NumThreads", num_threads)

    # 清除现有网格
    gmsh.model.mesh.clear()

    # 使用支持并行的算法
    gmsh.option.setNumber("Mesh.Algorithm3D", 10)  # HXT (并行)

    start_time = time.time()
    gmsh.model.mesh.generate(3)
    elapsed = time.time() - start_time

    # 统计
    elem_types, elem_tags, _ = gmsh.model.mesh.getElements(dim=3)
    num_elems = sum(len(t) for t in elem_tags)

    print(f"线程数: {num_threads}, 时间: {elapsed:.2f}秒, "
          f"元素数: {num_elems}")

gmsh.finalize()
```

### 并行3D网格算法

```python
# HXT算法 - 支持多线程的3D Delaunay
gmsh.option.setNumber("Mesh.Algorithm3D", 10)  # HXT

# HXT专用选项
gmsh.option.setNumber("Mesh.MaxNumThreads3D", 8)  # 3D网格最大线程数

# 对于2D网格
gmsh.option.setNumber("Mesh.MaxNumThreads2D", 8)  # 2D网格最大线程数
```

## Python多进程

### 多进程网格生成

```python
#!/usr/bin/env python3
"""
使用Python多进程并行生成多个网格
"""
import gmsh
import multiprocessing as mp
import time
import os

def generate_mesh(params):
    """在独立进程中生成网格"""
    model_name, size, output_file = params

    # 每个进程需要独立初始化Gmsh
    gmsh.initialize()
    gmsh.model.add(model_name)

    # 创建几何
    gmsh.model.occ.addSphere(0, 0, 0, 1)
    gmsh.model.occ.synchronize()

    # 设置尺寸
    gmsh.option.setNumber("Mesh.MeshSizeMax", size)

    # 生成网格
    gmsh.model.mesh.generate(3)

    # 获取统计
    elem_types, elem_tags, _ = gmsh.model.mesh.getElements(dim=3)
    num_elems = sum(len(t) for t in elem_tags)

    # 保存
    gmsh.write(output_file)

    gmsh.finalize()

    return model_name, num_elems

def main():
    # 准备任务
    tasks = [
        ("mesh_1", 0.1, "mesh_1.msh"),
        ("mesh_2", 0.08, "mesh_2.msh"),
        ("mesh_3", 0.06, "mesh_3.msh"),
        ("mesh_4", 0.05, "mesh_4.msh"),
    ]

    print(f"启动 {len(tasks)} 个网格生成任务...")
    start_time = time.time()

    # 使用进程池
    with mp.Pool(processes=4) as pool:
        results = pool.map(generate_mesh, tasks)

    elapsed = time.time() - start_time

    print(f"\n结果:")
    for name, num_elems in results:
        print(f"  {name}: {num_elems} 个元素")

    print(f"\n总耗时: {elapsed:.2f} 秒")

if __name__ == "__main__":
    main()
```

### 参数扫描

```python
#!/usr/bin/env python3
"""
并行参数扫描示例
"""
import gmsh
import multiprocessing as mp
import numpy as np
import json

def mesh_quality_study(mesh_size):
    """研究不同网格尺寸的质量"""
    gmsh.initialize()
    gmsh.model.add(f"study_{mesh_size}")

    # 创建测试几何
    gmsh.model.occ.addBox(0, 0, 0, 1, 1, 1)
    sphere = gmsh.model.occ.addSphere(0.5, 0.5, 0.5, 0.3)
    gmsh.model.occ.cut([(3, 1)], [(3, sphere)])
    gmsh.model.occ.synchronize()

    # 设置网格尺寸
    gmsh.option.setNumber("Mesh.MeshSizeMax", mesh_size)
    gmsh.option.setNumber("Mesh.Optimize", 1)

    # 生成网格
    gmsh.model.mesh.generate(3)

    # 获取质量数据
    qualities = gmsh.model.mesh.getElementQualities([], "minSJ")

    # 统计
    q = np.array(qualities) if qualities else np.array([0])
    result = {
        'mesh_size': mesh_size,
        'num_elements': len(q),
        'min_quality': float(q.min()),
        'max_quality': float(q.max()),
        'mean_quality': float(q.mean()),
        'std_quality': float(q.std()),
        'bad_elements': int(np.sum(q < 0.3))
    }

    gmsh.finalize()
    return result

def main():
    # 网格尺寸范围
    mesh_sizes = [0.2, 0.15, 0.1, 0.08, 0.06, 0.05]

    print(f"开始参数扫描: {len(mesh_sizes)} 个尺寸...")

    # 并行计算
    with mp.Pool(processes=4) as pool:
        results = pool.map(mesh_quality_study, mesh_sizes)

    # 输出结果
    print("\n网格质量研究结果:")
    print("-" * 80)
    print(f"{'尺寸':>8} {'元素数':>10} {'最小质量':>10} {'平均质量':>10} {'差质量元素':>12}")
    print("-" * 80)

    for r in results:
        print(f"{r['mesh_size']:>8.3f} {r['num_elements']:>10} "
              f"{r['min_quality']:>10.4f} {r['mean_quality']:>10.4f} "
              f"{r['bad_elements']:>12}")

    # 保存结果
    with open("mesh_study_results.json", "w") as f:
        json.dump(results, f, indent=2)

    print(f"\n结果已保存到 mesh_study_results.json")

if __name__ == "__main__":
    main()
```

## 分布式网格生成

### 网格分区

```python
#!/usr/bin/env python3
"""
为分布式计算分区网格
"""
import gmsh
import numpy as np

gmsh.initialize()
gmsh.model.add("distributed")

# 创建大型网格
gmsh.model.occ.addBox(0, 0, 0, 10, 10, 10)
gmsh.model.occ.synchronize()

gmsh.option.setNumber("Mesh.MeshSizeMax", 0.5)
gmsh.model.mesh.generate(3)

# 分区前统计
node_tags, _, _ = gmsh.model.mesh.getNodes()
elem_types, elem_tags, _ = gmsh.model.mesh.getElements(dim=3)
num_elems = sum(len(t) for t in elem_tags)

print(f"分区前:")
print(f"  节点数: {len(node_tags)}")
print(f"  元素数: {num_elems}")

# 分区设置
num_partitions = 8
gmsh.option.setNumber("Mesh.PartitionAlgorithm", 1)  # METIS
gmsh.option.setNumber("Mesh.PartitionCreateTopology", 1)
gmsh.option.setNumber("Mesh.PartitionCreateGhostCells", 1)

# 执行分区
gmsh.model.mesh.partition(num_partitions)

print(f"\n分区为 {num_partitions} 个部分")

# 保存分区网格
gmsh.write("distributed_mesh.msh")

# 获取分区信息
entities = gmsh.model.getEntities()
for dim, tag in entities:
    partitions = gmsh.model.getPartitions(dim, tag)
    if partitions:
        print(f"  实体 ({dim}, {tag}): 分区 {partitions}")

gmsh.finalize()
```

### 为MPI准备网格

```python
#!/usr/bin/env python3
"""
为MPI并行计算准备网格
"""
import gmsh
import numpy as np
import os
import json

def prepare_mpi_mesh(num_processes):
    """准备MPI分布式网格"""

    gmsh.initialize()
    gmsh.model.add("mpi_mesh")

    # 创建几何
    gmsh.model.occ.addBox(0, 0, 0, 10, 10, 10)
    gmsh.model.occ.synchronize()

    # 生成网格
    gmsh.option.setNumber("Mesh.MeshSizeMax", 0.5)
    gmsh.option.setNumber("Mesh.Algorithm3D", 10)  # HXT
    gmsh.option.setNumber("General.NumThreads", 4)
    gmsh.model.mesh.generate(3)

    # 分区
    gmsh.option.setNumber("Mesh.PartitionAlgorithm", 1)  # METIS
    gmsh.option.setNumber("Mesh.PartitionCreateTopology", 1)
    gmsh.option.setNumber("Mesh.PartitionCreateGhostCells", 1)
    gmsh.model.mesh.partition(num_processes)

    # 创建输出目录
    os.makedirs("mpi_mesh", exist_ok=True)

    # 保存完整网格
    gmsh.write("mpi_mesh/full_mesh.msh")

    # 收集分区信息
    partition_info = {
        'num_partitions': num_processes,
        'partitions': []
    }

    # 获取节点和元素
    node_tags, node_coords, _ = gmsh.model.mesh.getNodes()
    node_coords = np.array(node_coords).reshape(-1, 3)

    elem_types, elem_tags, elem_nodes = gmsh.model.mesh.getElements(dim=3)

    partition_info['total_nodes'] = len(node_tags)
    partition_info['total_elements'] = sum(len(t) for t in elem_tags)

    # 保存分区信息
    with open("mpi_mesh/partition_info.json", "w") as f:
        json.dump(partition_info, f, indent=2)

    print(f"MPI网格准备完成:")
    print(f"  分区数: {num_processes}")
    print(f"  总节点数: {partition_info['total_nodes']}")
    print(f"  总元素数: {partition_info['total_elements']}")

    gmsh.finalize()

if __name__ == "__main__":
    prepare_mpi_mesh(8)
```

## 异步网格生成

### 使用asyncio

```python
#!/usr/bin/env python3
"""
异步网格生成示例
"""
import asyncio
import gmsh
from concurrent.futures import ProcessPoolExecutor

def generate_mesh_sync(params):
    """同步网格生成函数"""
    name, size = params

    gmsh.initialize()
    gmsh.model.add(name)

    gmsh.model.occ.addSphere(0, 0, 0, 1)
    gmsh.model.occ.synchronize()

    gmsh.option.setNumber("Mesh.MeshSizeMax", size)
    gmsh.model.mesh.generate(3)

    elem_types, elem_tags, _ = gmsh.model.mesh.getElements(dim=3)
    num_elems = sum(len(t) for t in elem_tags)

    gmsh.write(f"{name}.msh")
    gmsh.finalize()

    return name, num_elems

async def generate_mesh_async(executor, params):
    """异步包装器"""
    loop = asyncio.get_event_loop()
    return await loop.run_in_executor(executor, generate_mesh_sync, params)

async def main():
    tasks_params = [
        ("mesh_a", 0.1),
        ("mesh_b", 0.08),
        ("mesh_c", 0.06),
        ("mesh_d", 0.05),
    ]

    with ProcessPoolExecutor(max_workers=4) as executor:
        tasks = [generate_mesh_async(executor, p) for p in tasks_params]
        results = await asyncio.gather(*tasks)

    print("\n异步网格生成结果:")
    for name, num_elems in results:
        print(f"  {name}: {num_elems} 个元素")

if __name__ == "__main__":
    asyncio.run(main())
```

## 性能优化技巧

### 内存优化

```python
#!/usr/bin/env python3
"""
内存优化技巧
"""
import gmsh
import gc

def generate_large_mesh_optimized():
    gmsh.initialize()
    gmsh.model.add("large_mesh")

    # 使用OCC内核（更高效）
    gmsh.model.occ.addBox(0, 0, 0, 100, 100, 100)
    gmsh.model.occ.synchronize()

    # 优化内存设置
    gmsh.option.setNumber("Mesh.SaveAll", 0)  # 不保存所有元素

    # 使用高效算法
    gmsh.option.setNumber("Mesh.Algorithm3D", 10)  # HXT
    gmsh.option.setNumber("General.NumThreads", 4)

    # 分步生成
    gmsh.model.mesh.generate(1)
    gc.collect()  # 清理内存

    gmsh.model.mesh.generate(2)
    gc.collect()

    gmsh.model.mesh.generate(3)

    # 保存时使用二进制格式
    gmsh.option.setNumber("Mesh.Binary", 1)
    gmsh.write("large_mesh.msh")

    gmsh.finalize()

if __name__ == "__main__":
    generate_large_mesh_optimized()
```

### 增量网格更新

```python
#!/usr/bin/env python3
"""
增量网格更新（避免完全重生成）
"""
import gmsh

gmsh.initialize()
gmsh.model.add("incremental")

# 初始几何
gmsh.model.occ.addBox(0, 0, 0, 1, 1, 1)
gmsh.model.occ.synchronize()

# 初始网格
gmsh.option.setNumber("Mesh.MeshSizeMax", 0.1)
gmsh.model.mesh.generate(3)

print("初始网格生成完成")

# 添加新几何（例如在现有网格上添加特征）
# 注意：这需要谨慎处理，通常需要重新生成

# 局部细化
# 使用尺寸场进行局部控制
field = gmsh.model.mesh.field.add("Box")
gmsh.model.mesh.field.setNumber(field, "VIn", 0.02)
gmsh.model.mesh.field.setNumber(field, "VOut", 0.1)
gmsh.model.mesh.field.setNumber(field, "XMin", 0.3)
gmsh.model.mesh.field.setNumber(field, "XMax", 0.7)
gmsh.model.mesh.field.setNumber(field, "YMin", 0.3)
gmsh.model.mesh.field.setNumber(field, "YMax", 0.7)
gmsh.model.mesh.field.setNumber(field, "ZMin", 0.3)
gmsh.model.mesh.field.setNumber(field, "ZMax", 0.7)

gmsh.model.mesh.field.setAsBackgroundMesh(field)

# 重新生成（带有局部细化）
gmsh.model.mesh.clear()
gmsh.model.mesh.generate(3)

print("局部细化完成")

gmsh.write("incremental.msh")
gmsh.finalize()
```

## 并行性能测试

```python
#!/usr/bin/env python3
"""
并行性能测试脚本
"""
import gmsh
import time
import os
import numpy as np

def benchmark(num_threads, mesh_size, algorithm_3d=10):
    """基准测试"""
    gmsh.initialize()
    gmsh.model.add("benchmark")

    # 创建测试几何
    gmsh.model.occ.addBox(0, 0, 0, 10, 10, 10)
    for i in range(3):
        for j in range(3):
            for k in range(3):
                sphere = gmsh.model.occ.addSphere(
                    i * 3 + 1.5, j * 3 + 1.5, k * 3 + 1.5, 0.8)
                try:
                    gmsh.model.occ.cut([(3, 1)], [(3, sphere)],
                                       removeObject=True, removeTool=True)
                except:
                    pass

    gmsh.model.occ.synchronize()

    # 设置参数
    gmsh.option.setNumber("General.NumThreads", num_threads)
    gmsh.option.setNumber("Mesh.MeshSizeMax", mesh_size)
    gmsh.option.setNumber("Mesh.Algorithm3D", algorithm_3d)
    gmsh.option.setNumber("Mesh.Optimize", 1)

    # 测量时间
    start_time = time.time()
    gmsh.model.mesh.generate(3)
    mesh_time = time.time() - start_time

    # 获取统计
    elem_types, elem_tags, _ = gmsh.model.mesh.getElements(dim=3)
    num_elems = sum(len(t) for t in elem_tags)

    gmsh.finalize()

    return {
        'threads': num_threads,
        'mesh_size': mesh_size,
        'algorithm': algorithm_3d,
        'time': mesh_time,
        'elements': num_elems,
        'throughput': num_elems / mesh_time
    }

def main():
    print("=" * 60)
    print("Gmsh 并行性能测试")
    print("=" * 60)

    # 测试不同线程数
    print("\n测试不同线程数 (HXT算法):")
    print("-" * 60)

    mesh_size = 0.3
    results = []

    for threads in [1, 2, 4, 8]:
        result = benchmark(threads, mesh_size, algorithm_3d=10)
        results.append(result)
        print(f"线程: {result['threads']:2d}, "
              f"时间: {result['time']:6.2f}s, "
              f"元素: {result['elements']:8d}, "
              f"吞吐: {result['throughput']:8.0f} elem/s")

    # 计算加速比
    base_time = results[0]['time']
    print("\n加速比:")
    for r in results:
        speedup = base_time / r['time']
        efficiency = speedup / r['threads'] * 100
        print(f"  {r['threads']} 线程: {speedup:.2f}x (效率: {efficiency:.1f}%)")

    # 测试不同算法
    print("\n测试不同3D算法 (4线程):")
    print("-" * 60)

    algorithms = {
        1: "Delaunay",
        4: "Frontal",
        10: "HXT"
    }

    for alg_id, alg_name in algorithms.items():
        try:
            result = benchmark(4, mesh_size, algorithm_3d=alg_id)
            print(f"算法: {alg_name:10s}, "
                  f"时间: {result['time']:6.2f}s, "
                  f"元素: {result['elements']:8d}")
        except Exception as e:
            print(f"算法: {alg_name:10s}, 错误: {e}")

if __name__ == "__main__":
    main()
```

## 最佳实践

### 并行策略选择

```python
"""
并行策略选择指南
"""

# 1. 单个大网格 - 使用OpenMP多线程
# - 设置 General.NumThreads
# - 使用 HXT 算法 (Algorithm3D = 10)
# - 适用于单个大型几何

# 2. 多个独立网格 - 使用Python多进程
# - 使用 multiprocessing.Pool
# - 每个进程独立初始化Gmsh
# - 适用于参数扫描、批量处理

# 3. 分布式计算 - 使用网格分区
# - 使用 gmsh.model.mesh.partition()
# - 配合 MPI 使用
# - 适用于大规模并行求解

# 4. 实时更新 - 使用异步处理
# - 使用 asyncio + ProcessPoolExecutor
# - GUI线程与计算线程分离
# - 适用于交互式应用
```

### 线程数建议

```python
import os
import gmsh

def get_optimal_threads():
    """获取最优线程数"""
    cpu_count = os.cpu_count()

    # 一般建议使用物理核心数
    # 对于超线程CPU，使用一半的逻辑核心数可能更好
    optimal = max(1, cpu_count // 2)

    return optimal

gmsh.initialize()

# 使用最优线程数
optimal = get_optimal_threads()
gmsh.option.setNumber("General.NumThreads", optimal)

print(f"CPU核心数: {os.cpu_count()}")
print(f"使用线程数: {optimal}")

gmsh.finalize()
```

## 并行选项汇总

| 选项 | 描述 | 默认值 |
|------|------|--------|
| General.NumThreads | 全局线程数 | 1 |
| Mesh.MaxNumThreads1D | 1D网格最大线程数 | 0 (自动) |
| Mesh.MaxNumThreads2D | 2D网格最大线程数 | 0 (自动) |
| Mesh.MaxNumThreads3D | 3D网格最大线程数 | 0 (自动) |
| Mesh.Algorithm3D | 3D算法 (10=HXT并行) | 1 |
| Mesh.PartitionAlgorithm | 分区算法 (1=METIS) | 1 |

## 下一步

- [07-实战案例](../07-实战案例/01-2D矩形网格.md) - 开始实战案例学习
