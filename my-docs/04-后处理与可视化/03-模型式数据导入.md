# 模型式数据导入

模型式数据（Model-based data）基于现有网格的节点或单元存储数据，是有限元后处理的标准方式。

## 数据类型

```
模型式数据类型：
┌──────────────────────────────────┐
│ NodeData      节点数据           │
│ ElementData   单元数据           │
│ ElementNodeData 单元节点数据     │
└──────────────────────────────────┘
```

| 类型 | 描述 | 用途 |
|-----|------|------|
| NodeData | 每个节点一个值 | 位移、温度 |
| ElementData | 每个单元一个值 | 单元平均应力 |
| ElementNodeData | 每个单元的每个节点一个值 | 节点应力（不连续） |

## 添加节点数据

### 基本方法

```python
#!/usr/bin/env python3
"""
添加节点数据到View
"""
import gmsh
import numpy as np

gmsh.initialize()
gmsh.model.add("node_data")

# 创建网格
rect = gmsh.model.occ.addRectangle(0, 0, 0, 2, 1)
gmsh.model.occ.synchronize()
gmsh.option.setNumber("Mesh.MeshSizeMax", 0.1)
gmsh.model.mesh.generate(2)

# 获取节点
node_tags, node_coords, _ = gmsh.model.mesh.getNodes()
node_coords = np.array(node_coords).reshape(-1, 3)

# 创建View
view = gmsh.view.add("NodalTemperature")

# 计算节点数据
data = []
for i, coords in enumerate(node_coords):
    x, y, z = coords
    # 温度分布
    T = 100 * np.exp(-((x-1)**2 + (y-0.5)**2))
    data.append([T])

# 添加模型数据
# addModelData(tag, step, modelName, dataType, tags, data, time=0, numComponents=1, partition=0)
gmsh.view.addModelData(
    view,
    0,                    # 时间步
    "",                   # 模型名（空=当前模型）
    "NodeData",           # 数据类型
    list(node_tags),      # 节点tag列表
    data                  # 数据：[[v1], [v2], ...]
)

gmsh.write("node_data.msh")
gmsh.finalize()
```

### 向量节点数据

```python
#!/usr/bin/env python3
"""
添加向量节点数据
"""
import gmsh
import numpy as np

gmsh.initialize()
gmsh.model.add("vector_node_data")

# 创建网格
disk = gmsh.model.occ.addDisk(0, 0, 0, 1, 1)
gmsh.model.occ.synchronize()
gmsh.option.setNumber("Mesh.MeshSizeMax", 0.1)
gmsh.model.mesh.generate(2)

# 获取节点
node_tags, node_coords, _ = gmsh.model.mesh.getNodes()
node_coords = np.array(node_coords).reshape(-1, 3)

# 创建速度场View
view = gmsh.view.add("Velocity")

# 计算向量数据（旋转流场）
data = []
for coords in node_coords:
    x, y, z = coords
    # 旋转速度场
    vx = -y
    vy = x
    vz = 0
    data.append([vx, vy, vz])

gmsh.view.addModelData(
    view, 0, "", "NodeData",
    list(node_tags), data,
    numComponents=3  # 向量有3个分量
)

# 设置向量显示
gmsh.option.setNumber("View[0].VectorType", 4)
gmsh.option.setNumber("View[0].ArrowSizeMax", 30)

gmsh.write("vector_node_data.msh")
gmsh.finalize()
```

### 张量节点数据

```python
# 张量数据（9个分量）
data = []
for coords in node_coords:
    x, y, z = coords
    # 应力张量
    sxx, syy, szz = 100*x, 50*y, 0
    sxy, sxz, syz = 10*x*y, 0, 0
    tensor = [sxx, sxy, sxz, sxy, syy, syz, sxz, syz, szz]
    data.append(tensor)

gmsh.view.addModelData(
    view, 0, "", "NodeData",
    list(node_tags), data,
    numComponents=9
)
```

## 添加单元数据

### 标量单元数据

```python
#!/usr/bin/env python3
"""
添加单元数据到View
"""
import gmsh
import numpy as np

gmsh.initialize()
gmsh.model.add("element_data")

# 创建网格
rect = gmsh.model.occ.addRectangle(0, 0, 0, 2, 1)
gmsh.model.occ.synchronize()
gmsh.option.setNumber("Mesh.MeshSizeMax", 0.1)
gmsh.model.mesh.generate(2)

# 获取单元
elem_types, elem_tags, elem_node_tags = gmsh.model.mesh.getElements(2)

# 获取节点坐标（用于计算单元中心）
node_tags, node_coords, _ = gmsh.model.mesh.getNodes()
node_coords = np.array(node_coords).reshape(-1, 3)
node_dict = {tag: coords for tag, coords in zip(node_tags, node_coords)}

# 创建View
view = gmsh.view.add("ElementStress")

# 处理每种单元类型
for etype, etags, enodes in zip(elem_types, elem_tags, elem_node_tags):
    props = gmsh.model.mesh.getElementProperties(etype)
    num_nodes_per_elem = props[3]

    # 计算每个单元的数据
    data = []
    enodes = np.array(enodes).reshape(-1, num_nodes_per_elem)

    for nodes in enodes:
        # 计算单元中心
        center = np.mean([node_dict[n] for n in nodes], axis=0)
        x, y, z = center

        # 单元应力（示例）
        stress = 100 * (1 - x) + 50 * np.sin(np.pi * y)
        data.append([stress])

    # 添加单元数据
    gmsh.view.addModelData(
        view, 0, "", "ElementData",
        list(etags), data
    )

gmsh.write("element_data.msh")
gmsh.finalize()
```

### 向量单元数据

```python
# 单元向量数据（如单元平均速度）
data = []
for nodes in enodes:
    center = np.mean([node_dict[n] for n in nodes], axis=0)
    x, y, z = center

    # 单元平均速度
    vx = -y
    vy = x
    vz = 0
    data.append([vx, vy, vz])

gmsh.view.addModelData(
    view, 0, "", "ElementData",
    list(etags), data,
    numComponents=3
)
```

## 添加单元节点数据

单元节点数据在每个单元的每个节点都有值，允许在单元边界处不连续。

```python
#!/usr/bin/env python3
"""
添加单元节点数据
"""
import gmsh
import numpy as np

gmsh.initialize()
gmsh.model.add("element_node_data")

# 创建网格
rect = gmsh.model.occ.addRectangle(0, 0, 0, 1, 1)
gmsh.model.occ.synchronize()
gmsh.option.setNumber("Mesh.MeshSizeMax", 0.2)
gmsh.model.mesh.generate(2)

# 获取单元
elem_types, elem_tags, elem_node_tags = gmsh.model.mesh.getElements(2)

# 获取节点坐标
node_tags, node_coords, _ = gmsh.model.mesh.getNodes()
node_coords = np.array(node_coords).reshape(-1, 3)
node_dict = {tag: coords for tag, coords in zip(node_tags, node_coords)}

# 创建View
view = gmsh.view.add("DiscontinuousStress")

for etype, etags, enodes in zip(elem_types, elem_tags, elem_node_tags):
    props = gmsh.model.mesh.getElementProperties(etype)
    num_nodes_per_elem = props[3]

    data = []
    enodes = np.array(enodes).reshape(-1, num_nodes_per_elem)

    for elem_nodes in enodes:
        # 每个单元的节点数据
        elem_data = []
        for node_tag in elem_nodes:
            coords = node_dict[node_tag]
            x, y, z = coords
            # 不连续应力（每个单元独立计算）
            stress = 100 * x * y + np.random.uniform(-10, 10)
            elem_data.append(stress)
        data.append(elem_data)

    gmsh.view.addModelData(
        view, 0, "", "ElementNodeData",
        list(etags), data,
        numComponents=1
    )

gmsh.write("element_node_data.msh")
gmsh.finalize()
```

## 时间序列数据

### 多时间步

```python
#!/usr/bin/env python3
"""
添加时间序列模型数据
"""
import gmsh
import numpy as np

gmsh.initialize()
gmsh.model.add("time_series")

# 创建网格
disk = gmsh.model.occ.addDisk(0, 0, 0, 1, 1)
gmsh.model.occ.synchronize()
gmsh.option.setNumber("Mesh.MeshSizeMax", 0.1)
gmsh.model.mesh.generate(2)

# 获取节点
node_tags, node_coords, _ = gmsh.model.mesh.getNodes()
node_coords = np.array(node_coords).reshape(-1, 3)

# 创建View
view = gmsh.view.add("WavePropagation")

# 添加多个时间步
num_steps = 30
for step in range(num_steps):
    time = step * 0.1

    data = []
    for coords in node_coords:
        x, y, z = coords
        r = np.sqrt(x**2 + y**2)
        # 波动
        value = np.sin(2 * np.pi * (r - time)) * np.exp(-r**2)
        data.append([value])

    gmsh.view.addModelData(
        view, step, "", "NodeData",
        list(node_tags), data,
        time=time
    )

# 设置动画选项
gmsh.option.setNumber("View[0].ShowTime", 1)
gmsh.option.setNumber("View[0].Time", 0)

gmsh.write("wave_propagation.msh")
gmsh.finalize()
```

### 获取时间步信息

```python
# 获取View中的时间步数
# 通过option获取
num_steps = int(gmsh.option.getNumber("View[0].NbTimeStep"))
print(f"时间步数: {num_steps}")

# 获取当前时间步
current_step = int(gmsh.option.getNumber("View[0].TimeStep"))
```

## 从外部数据导入

### 从NumPy数组

```python
#!/usr/bin/env python3
"""
从NumPy数组导入数据
"""
import gmsh
import numpy as np

def import_from_numpy(mesh_file, data_array, data_name="Data"):
    """
    从NumPy数组导入数据到View

    参数:
        mesh_file: 网格文件路径
        data_array: 形状为(num_nodes,) 或 (num_nodes, num_components)的数组
        data_name: View名称
    """
    gmsh.initialize()
    gmsh.merge(mesh_file)

    # 获取节点
    node_tags, _, _ = gmsh.model.mesh.getNodes()

    if len(data_array) != len(node_tags):
        raise ValueError(f"数据长度({len(data_array)})与节点数({len(node_tags)})不匹配")

    # 确定分量数
    if data_array.ndim == 1:
        data = [[v] for v in data_array]
        num_components = 1
    else:
        data = data_array.tolist()
        num_components = data_array.shape[1]

    # 创建View
    view = gmsh.view.add(data_name)
    gmsh.view.addModelData(
        view, 0, "", "NodeData",
        list(node_tags), data,
        numComponents=num_components
    )

    return view

# 示例使用
if __name__ == "__main__":
    # 创建测试网格
    gmsh.initialize()
    gmsh.model.add("test")
    gmsh.model.occ.addBox(0, 0, 0, 1, 1, 1)
    gmsh.model.occ.synchronize()
    gmsh.model.mesh.generate(3)
    gmsh.write("test.msh")
    gmsh.finalize()

    # 读取并添加数据
    gmsh.initialize()
    gmsh.merge("test.msh")
    node_tags, node_coords, _ = gmsh.model.mesh.getNodes()

    # 创建测试数据
    data = np.sin(node_coords[::3]) * np.cos(node_coords[1::3])

    view = import_from_numpy.__wrapped__("test.msh", data, "Temperature")
    gmsh.write("with_data.msh")
    gmsh.finalize()
```

### 从CSV文件

```python
#!/usr/bin/env python3
"""
从CSV文件导入数据
"""
import gmsh
import numpy as np
import csv

def import_from_csv(mesh_file, csv_file, node_id_col=0, value_cols=[1]):
    """
    从CSV文件导入节点数据

    CSV格式: node_id, value1, value2, ...
    """
    gmsh.initialize()
    gmsh.merge(mesh_file)

    # 读取CSV
    node_data = {}
    with open(csv_file, 'r') as f:
        reader = csv.reader(f)
        next(reader)  # 跳过标题行
        for row in reader:
            node_id = int(row[node_id_col])
            values = [float(row[c]) for c in value_cols]
            node_data[node_id] = values

    # 获取网格节点
    node_tags, _, _ = gmsh.model.mesh.getNodes()

    # 匹配数据
    data = []
    valid_tags = []
    for tag in node_tags:
        if tag in node_data:
            data.append(node_data[tag])
            valid_tags.append(tag)

    if not valid_tags:
        raise ValueError("没有匹配的节点数据")

    # 创建View
    view = gmsh.view.add("CSVData")
    gmsh.view.addModelData(
        view, 0, "", "NodeData",
        valid_tags, data,
        numComponents=len(value_cols)
    )

    gmsh.write("from_csv.msh")
    gmsh.finalize()
```

## 完整示例：有限元结果后处理

```python
#!/usr/bin/env python3
"""
完整的有限元结果后处理流程
"""
import gmsh
import numpy as np

def fem_postprocess():
    gmsh.initialize()
    gmsh.model.add("fem_post")

    # 1. 创建几何和网格（悬臂梁）
    L, H, W = 10, 1, 0.5
    beam = gmsh.model.occ.addBox(0, 0, 0, L, H, W)
    gmsh.model.occ.synchronize()

    gmsh.option.setNumber("Mesh.MeshSizeMax", 0.3)
    gmsh.model.mesh.generate(3)

    # 2. 获取网格数据
    node_tags, node_coords, _ = gmsh.model.mesh.getNodes()
    node_coords = np.array(node_coords).reshape(-1, 3)

    elem_types, elem_tags, elem_nodes = gmsh.model.mesh.getElements(3)

    # 创建节点字典
    node_dict = {tag: coords for tag, coords in zip(node_tags, node_coords)}

    # 3. 模拟FEM结果

    # 位移场（悬臂梁变形）
    view_disp = gmsh.view.add("Displacement")
    disp_data = []
    for coords in node_coords:
        x, y, z = coords
        # 简化的悬臂梁位移
        ux = 0.001 * x
        uy = -0.05 * (x/L)**2 * (y - H/2)
        uz = 0
        disp_data.append([ux, uy, uz])

    gmsh.view.addModelData(
        view_disp, 0, "", "NodeData",
        list(node_tags), disp_data,
        numComponents=3
    )

    # 应力场（von Mises）
    view_stress = gmsh.view.add("VonMises")
    stress_data = []
    for coords in node_coords:
        x, y, z = coords
        # 简化的应力计算
        sigma = 200 * (L - x) / L * abs(y - H/2) / (H/2)
        stress_data.append([sigma])

    gmsh.view.addModelData(
        view_stress, 0, "", "NodeData",
        list(node_tags), stress_data
    )

    # 单元应变能密度
    view_energy = gmsh.view.add("StrainEnergy")
    for etype, etags, enodes in zip(elem_types, elem_tags, elem_nodes):
        props = gmsh.model.mesh.getElementProperties(etype)
        num_nodes = props[3]
        enodes_arr = np.array(enodes).reshape(-1, num_nodes)

        energy_data = []
        for elem_nodes in enodes_arr:
            center = np.mean([node_dict[n] for n in elem_nodes], axis=0)
            x, y, z = center
            # 简化的应变能密度
            energy = 100 * (L - x) / L * (1 - abs(y - H/2) / (H/2))
            energy_data.append([energy])

        gmsh.view.addModelData(
            view_energy, 0, "", "ElementData",
            list(etags), energy_data
        )

    # 4. 设置显示选项
    # 位移场
    gmsh.option.setNumber("View[0].VectorType", 5)  # 位移
    gmsh.option.setNumber("View[0].DisplacementFactor", 10)  # 放大10倍

    # 应力场
    gmsh.option.setNumber("View[1].ColorTable", 2)  # Jet
    gmsh.option.setNumber("View[1].IntervalsType", 1)

    # 应变能
    gmsh.option.setNumber("View[2].ColorTable", 3)  # Hot

    # 5. 保存
    gmsh.write("fem_results.msh")

    # 单独保存各View
    gmsh.view.write(view_disp, "displacement.pos")
    gmsh.view.write(view_stress, "stress.pos")
    gmsh.view.write(view_energy, "energy.pos")

    print("后处理完成")
    print(f"节点数: {len(node_tags)}")
    print(f"单元数: {sum(len(t) for t in elem_tags)}")

    gmsh.finalize()

if __name__ == "__main__":
    fem_postprocess()
```

## 数据导出

### 导出到VTK

```python
# 导出网格和View数据到VTK格式
gmsh.write("results.vtk")
```

### 导出到其他格式

```python
# 导出View数据
gmsh.view.write(view_tag, "data.pos")   # POS格式
gmsh.view.write(view_tag, "data.msh")   # MSH格式

# 导出为文本
gmsh.view.write(view_tag, "data.txt", append=False)
```

## 下一步

- [04-可视化选项](./04-可视化选项.md) - 学习详细的可视化控制
