# 动画与导出

Gmsh支持创建动画和导出各种格式的图像和视频。

## 时间步动画

### 创建时间序列数据

```python
#!/usr/bin/env python3
"""
创建带时间步的动画数据
"""
import gmsh
import numpy as np

gmsh.initialize()
gmsh.model.add("animation")

# 创建网格
disk = gmsh.model.occ.addDisk(0, 0, 0, 1, 1)
gmsh.model.occ.synchronize()
gmsh.option.setNumber("Mesh.MeshSizeMax", 0.05)
gmsh.model.mesh.generate(2)

# 获取节点
node_tags, node_coords, _ = gmsh.model.mesh.getNodes()
node_coords = np.array(node_coords).reshape(-1, 3)

# 创建View
view = gmsh.view.add("Wave")

# 创建多个时间步
num_steps = 60
for step in range(num_steps):
    time = step * 0.1

    data = []
    for coords in node_coords:
        x, y, z = coords
        r = np.sqrt(x**2 + y**2)
        # 传播波
        value = np.sin(2*np.pi*(r - 0.5*time)) * np.exp(-r**2)
        data.append([value])

    gmsh.view.addModelData(
        view, step, "", "NodeData",
        list(node_tags), data,
        time=time
    )

# 设置动画选项
gmsh.option.setNumber("View[0].ShowTime", 1)
gmsh.option.setNumber("View[0].ColorTable", 2)

gmsh.write("animation_data.msh")
gmsh.finalize()
```

### 播放控制

```python
# 时间步控制
gmsh.option.setNumber("View[0].TimeStep", 0)  # 当前时间步

# 获取时间步数
num_steps = int(gmsh.option.getNumber("View[0].NbTimeStep"))

# 循环播放
for step in range(num_steps):
    gmsh.option.setNumber("View[0].TimeStep", step)
    # 可以在此添加绘制代码
```

## GUI动画（FLTK）

### 使用GUI播放动画

```python
#!/usr/bin/env python3
"""
使用FLTK GUI播放动画
"""
import gmsh

gmsh.initialize()

# 加载带时间步的数据
gmsh.merge("animation_data.msh")

# 启动GUI
if gmsh.fltk.isAvailable():
    # 设置动画参数
    gmsh.option.setNumber("View[0].ShowTime", 1)

    # 运行GUI
    gmsh.fltk.run()

gmsh.finalize()
```

### 动画选项

```python
# 动画速度
gmsh.option.setNumber("General.AnimationDelay", 100)  # 毫秒

# 动画类型
# 0: 无
# 1: 前进
# 2: 后退
# 3: 往返
gmsh.option.setNumber("View[0].AnimationType", 3)

# 循环
gmsh.option.setNumber("View[0].AnimationCycle", 1)
```

## 图像导出

### PNG导出

```python
#!/usr/bin/env python3
"""
导出PNG图像
"""
import gmsh

gmsh.initialize()

# 创建/加载模型
gmsh.model.add("export")
gmsh.model.occ.addSphere(0, 0, 0, 1)
gmsh.model.occ.synchronize()
gmsh.model.mesh.generate(3)

# 设置渲染选项
gmsh.option.setNumber("General.GraphicsWidth", 1920)
gmsh.option.setNumber("General.GraphicsHeight", 1080)

# 背景颜色
gmsh.option.setColor("General.Background", 255, 255, 255)

# 导出PNG
# write方法会根据扩展名选择格式
gmsh.write("output.png")

gmsh.finalize()
```

### 批量导出

```python
#!/usr/bin/env python3
"""
批量导出动画帧
"""
import gmsh
import os

gmsh.initialize()
gmsh.merge("animation_data.msh")

# 创建输出目录
os.makedirs("frames", exist_ok=True)

# 设置图像尺寸
gmsh.option.setNumber("General.GraphicsWidth", 800)
gmsh.option.setNumber("General.GraphicsHeight", 600)

# 获取时间步数
num_steps = int(gmsh.option.getNumber("View[0].NbTimeStep"))

# 导出每一帧
for step in range(num_steps):
    gmsh.option.setNumber("View[0].TimeStep", step)

    # 更新显示
    if gmsh.fltk.isAvailable():
        gmsh.fltk.update()

    # 导出
    filename = f"frames/frame_{step:04d}.png"
    gmsh.write(filename)
    print(f"导出: {filename}")

gmsh.finalize()
```

### 其他图像格式

```python
# 支持的图像格式
gmsh.write("output.png")   # PNG
gmsh.write("output.jpg")   # JPEG
gmsh.write("output.gif")   # GIF
gmsh.write("output.pdf")   # PDF（矢量）
gmsh.write("output.svg")   # SVG（矢量）
gmsh.write("output.ps")    # PostScript
gmsh.write("output.eps")   # EPS
gmsh.write("output.tex")   # LaTeX/TikZ
```

### 矢量图导出

```python
# PDF矢量图
gmsh.option.setNumber("Print.PostScriptFormat", 1)  # PDF
gmsh.option.setNumber("Print.TexAsEquation", 1)     # 公式处理
gmsh.write("output.pdf")

# SVG矢量图
gmsh.option.setNumber("Print.PostScriptFormat", 2)  # SVG
gmsh.write("output.svg")
```

## 视频导出

### 使用FLTK录制

```python
#!/usr/bin/env python3
"""
录制动画视频
"""
import gmsh

gmsh.initialize()
gmsh.merge("animation_data.msh")

if gmsh.fltk.isAvailable():
    # 设置视频选项
    gmsh.option.setNumber("General.MovieWidth", 1280)
    gmsh.option.setNumber("General.MovieHeight", 720)

    # 开始录制（需要FFmpeg或其他编码器）
    gmsh.option.setString("General.MovieFileName", "animation.mp4")

    # 手动控制帧
    num_steps = int(gmsh.option.getNumber("View[0].NbTimeStep"))

    for step in range(num_steps):
        gmsh.option.setNumber("View[0].TimeStep", step)
        gmsh.fltk.update()
        # 写入帧（如果支持）

gmsh.finalize()
```

### 使用外部工具创建视频

```python
#!/usr/bin/env python3
"""
导出帧后使用FFmpeg创建视频
"""
import gmsh
import os
import subprocess

def export_frames(data_file, output_dir="frames"):
    """导出所有帧为PNG"""
    gmsh.initialize()
    gmsh.merge(data_file)

    os.makedirs(output_dir, exist_ok=True)

    # 设置渲染
    gmsh.option.setNumber("General.GraphicsWidth", 1280)
    gmsh.option.setNumber("General.GraphicsHeight", 720)
    gmsh.option.setColor("General.Background", 255, 255, 255)

    num_steps = int(gmsh.option.getNumber("View[0].NbTimeStep"))

    for step in range(num_steps):
        gmsh.option.setNumber("View[0].TimeStep", step)
        filename = f"{output_dir}/frame_{step:04d}.png"
        gmsh.write(filename)

    gmsh.finalize()
    return num_steps

def create_video(frame_dir, output_file, fps=30):
    """使用FFmpeg创建视频"""
    cmd = [
        "ffmpeg",
        "-y",  # 覆盖输出
        "-framerate", str(fps),
        "-i", f"{frame_dir}/frame_%04d.png",
        "-c:v", "libx264",
        "-pix_fmt", "yuv420p",
        "-crf", "18",  # 质量（0-51，越小越好）
        output_file
    ]

    subprocess.run(cmd, check=True)
    print(f"视频已创建: {output_file}")

if __name__ == "__main__":
    num_frames = export_frames("animation_data.msh")
    create_video("frames", "animation.mp4", fps=30)
```

## 相机动画

### 旋转动画

```python
#!/usr/bin/env python3
"""
创建旋转视角动画
"""
import gmsh
import numpy as np
import os

gmsh.initialize()
gmsh.model.add("rotation")

# 创建模型
gmsh.model.occ.addBox(0, 0, 0, 1, 1, 1)
gmsh.model.occ.synchronize()
gmsh.model.mesh.generate(3)

# 创建数据View
view = gmsh.view.add("Data")
node_tags, node_coords, _ = gmsh.model.mesh.getNodes()
node_coords = np.array(node_coords).reshape(-1, 3)

data = [[np.sin(np.pi*c[0])*np.cos(np.pi*c[1])] for c in node_coords]
gmsh.view.addModelData(view, 0, "", "NodeData", list(node_tags), data)

# 设置选项
gmsh.option.setNumber("View[0].ColorTable", 2)
gmsh.option.setNumber("General.GraphicsWidth", 800)
gmsh.option.setNumber("General.GraphicsHeight", 600)

os.makedirs("rotation_frames", exist_ok=True)

# 旋转动画
num_frames = 120
for i in range(num_frames):
    angle = 360 * i / num_frames

    # 设置旋转
    gmsh.option.setNumber("General.RotationX", 20)
    gmsh.option.setNumber("General.RotationY", angle)
    gmsh.option.setNumber("General.RotationZ", 0)

    # 导出帧
    gmsh.write(f"rotation_frames/frame_{i:04d}.png")

print("帧导出完成")
gmsh.finalize()
```

### 缩放动画

```python
# 缩放动画
num_frames = 60
for i in range(num_frames):
    # 缩放因子（从远到近再到远）
    t = i / num_frames
    scale = 1 + 0.5 * np.sin(2 * np.pi * t)

    gmsh.option.setNumber("General.ScaleX", scale)
    gmsh.option.setNumber("General.ScaleY", scale)
    gmsh.option.setNumber("General.ScaleZ", scale)

    gmsh.write(f"zoom_frames/frame_{i:04d}.png")
```

## 高级导出选项

### 渲染质量

```python
# 抗锯齿
gmsh.option.setNumber("General.Antialiasing", 1)

# 光线追踪（如果支持）
gmsh.option.setNumber("General.Trackball", 1)

# 快速重绘
gmsh.option.setNumber("General.FastRedraw", 0)  # 关闭以获得更好质量
```

### 打印选项

```python
# 背景透明（PNG）
gmsh.option.setNumber("Print.Background", 0)

# EPS/PDF选项
gmsh.option.setNumber("Print.EpsLineWidthFactor", 1)
gmsh.option.setNumber("Print.EpsPointSizeFactor", 1)

# 文本处理
gmsh.option.setNumber("Print.Text", 1)
```

### 分辨率控制

```python
# 图像分辨率
gmsh.option.setNumber("General.GraphicsWidth", 3840)   # 4K
gmsh.option.setNumber("General.GraphicsHeight", 2160)

# 缩放因子（用于高DPI显示）
gmsh.option.setNumber("General.HighResolutionGraphics", 1)
```

## 完整示例：专业动画制作

```python
#!/usr/bin/env python3
"""
完整的专业动画制作流程
"""
import gmsh
import numpy as np
import os
import subprocess

class AnimationMaker:
    def __init__(self, width=1920, height=1080):
        self.width = width
        self.height = height
        gmsh.initialize()

    def setup_graphics(self):
        """设置图形选项"""
        gmsh.option.setNumber("General.GraphicsWidth", self.width)
        gmsh.option.setNumber("General.GraphicsHeight", self.height)
        gmsh.option.setNumber("General.Antialiasing", 1)
        gmsh.option.setNumber("General.FastRedraw", 0)

        # 背景
        gmsh.option.setColor("General.Background", 30, 30, 40)
        gmsh.option.setColor("General.Foreground", 255, 255, 255)

        # 光照
        gmsh.option.setNumber("General.Light0", 1)
        gmsh.option.setNumber("General.Light1", 1)

    def create_model(self):
        """创建示例模型"""
        gmsh.model.add("professional_animation")

        # 创建复杂模型
        box = gmsh.model.occ.addBox(-0.5, -0.5, -0.5, 1, 1, 1)
        sphere = gmsh.model.occ.addSphere(0.5, 0, 0, 0.3)
        cylinder = gmsh.model.occ.addCylinder(0, 0, -0.5, 0, 0, 1, 0.2)

        gmsh.model.occ.cut([(3, box)], [(3, sphere), (3, cylinder)])
        gmsh.model.occ.synchronize()

        gmsh.option.setNumber("Mesh.MeshSizeMax", 0.05)
        gmsh.model.mesh.generate(3)

    def add_data(self, num_steps=100):
        """添加时间序列数据"""
        node_tags, node_coords, _ = gmsh.model.mesh.getNodes()
        node_coords = np.array(node_coords).reshape(-1, 3)

        self.view = gmsh.view.add("EvolvingField")

        for step in range(num_steps):
            t = step / num_steps

            data = []
            for coords in node_coords:
                x, y, z = coords
                r = np.sqrt(x**2 + y**2 + z**2)
                # 时变场
                value = np.sin(4*np.pi*(r - t)) * np.exp(-2*r**2)
                data.append([value])

            gmsh.view.addModelData(
                self.view, step, "", "NodeData",
                list(node_tags), data,
                time=t
            )

        # View设置
        gmsh.option.setNumber("View[0].ColorTable", 2)
        gmsh.option.setNumber("View[0].RangeType", 2)
        gmsh.option.setNumber("View[0].CustomMin", -1)
        gmsh.option.setNumber("View[0].CustomMax", 1)
        gmsh.option.setNumber("View[0].ShowTime", 1)
        gmsh.option.setNumber("View[0].Light", 1)

        return num_steps

    def export_frames(self, output_dir, num_steps, with_rotation=True):
        """导出所有帧"""
        os.makedirs(output_dir, exist_ok=True)

        for step in range(num_steps):
            # 设置时间步
            gmsh.option.setNumber("View[0].TimeStep", step)

            # 可选：添加相机旋转
            if with_rotation:
                angle = 360 * step / num_steps
                gmsh.option.setNumber("General.RotationY", angle)

            # 导出
            filename = f"{output_dir}/frame_{step:04d}.png"
            gmsh.write(filename)

            if step % 10 == 0:
                print(f"导出进度: {step+1}/{num_steps}")

    def create_video(self, frame_dir, output_file, fps=30):
        """创建视频"""
        try:
            cmd = [
                "ffmpeg", "-y",
                "-framerate", str(fps),
                "-i", f"{frame_dir}/frame_%04d.png",
                "-c:v", "libx264",
                "-pix_fmt", "yuv420p",
                "-crf", "18",
                output_file
            ]
            subprocess.run(cmd, check=True)
            print(f"视频创建成功: {output_file}")
        except FileNotFoundError:
            print("警告: FFmpeg未找到，跳过视频创建")
            print("请手动使用以下命令创建视频:")
            print(f"ffmpeg -framerate {fps} -i {frame_dir}/frame_%04d.png "
                  f"-c:v libx264 -pix_fmt yuv420p {output_file}")

    def cleanup(self):
        """清理"""
        gmsh.finalize()

    def run(self):
        """运行完整流程"""
        self.setup_graphics()
        self.create_model()
        num_steps = self.add_data(100)
        self.export_frames("pro_frames", num_steps, with_rotation=True)
        self.create_video("pro_frames", "professional_animation.mp4", fps=30)
        self.cleanup()

if __name__ == "__main__":
    maker = AnimationMaker(width=1920, height=1080)
    maker.run()
```

## 导出格式汇总

| 格式 | 扩展名 | 类型 | 用途 |
|-----|-------|------|------|
| PNG | .png | 位图 | 通用图像 |
| JPEG | .jpg | 位图 | 压缩图像 |
| GIF | .gif | 位图 | 简单动画 |
| PDF | .pdf | 矢量 | 文档嵌入 |
| SVG | .svg | 矢量 | Web显示 |
| EPS | .eps | 矢量 | 出版物 |
| PS | .ps | 矢量 | 打印 |

## 下一步

- [06-插件系统](./06-插件系统.md) - 学习使用Gmsh插件扩展功能
