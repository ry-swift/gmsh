# 2D矩形网格

本案例演示最基础的2D网格生成方法。

## 案例目标

- 创建简单的2D矩形几何
- 生成三角形和四边形网格
- 设置物理组用于边界条件
- 导出网格文件

## 方法一：使用内置几何内核

```python
#!/usr/bin/env python3
"""
案例1: 2D矩形网格 - 使用内置几何内核(geo)
"""
import gmsh
import sys

def create_rectangle_geo():
    """使用内置几何内核创建矩形"""
    gmsh.initialize(sys.argv)
    gmsh.model.add("rectangle_geo")

    # 几何参数
    Lx = 2.0  # X方向长度
    Ly = 1.0  # Y方向长度
    lc = 0.1  # 网格尺寸

    # 创建点
    p1 = gmsh.model.geo.addPoint(0, 0, 0, lc)
    p2 = gmsh.model.geo.addPoint(Lx, 0, 0, lc)
    p3 = gmsh.model.geo.addPoint(Lx, Ly, 0, lc)
    p4 = gmsh.model.geo.addPoint(0, Ly, 0, lc)

    # 创建线
    l1 = gmsh.model.geo.addLine(p1, p2)  # 底边
    l2 = gmsh.model.geo.addLine(p2, p3)  # 右边
    l3 = gmsh.model.geo.addLine(p3, p4)  # 顶边
    l4 = gmsh.model.geo.addLine(p4, p1)  # 左边

    # 创建曲线环和平面
    cl = gmsh.model.geo.addCurveLoop([l1, l2, l3, l4])
    s = gmsh.model.geo.addPlaneSurface([cl])

    # 同步几何
    gmsh.model.geo.synchronize()

    # 定义物理组
    gmsh.model.addPhysicalGroup(1, [l1], tag=1, name="Bottom")
    gmsh.model.addPhysicalGroup(1, [l2], tag=2, name="Right")
    gmsh.model.addPhysicalGroup(1, [l3], tag=3, name="Top")
    gmsh.model.addPhysicalGroup(1, [l4], tag=4, name="Left")
    gmsh.model.addPhysicalGroup(2, [s], tag=10, name="Domain")

    # 生成网格
    gmsh.model.mesh.generate(2)

    # 保存
    gmsh.write("rectangle_geo.msh")

    # 显示GUI (可选)
    if "-nopopup" not in sys.argv:
        gmsh.fltk.run()

    gmsh.finalize()

if __name__ == "__main__":
    create_rectangle_geo()
```

## 方法二：使用OpenCASCADE内核

```python
#!/usr/bin/env python3
"""
案例1: 2D矩形网格 - 使用OpenCASCADE内核(occ)
"""
import gmsh
import sys

def create_rectangle_occ():
    """使用OCC内核创建矩形"""
    gmsh.initialize(sys.argv)
    gmsh.model.add("rectangle_occ")

    # 几何参数
    Lx = 2.0
    Ly = 1.0

    # 使用OCC的addRectangle函数
    # addRectangle(x, y, z, dx, dy, tag=-1, roundedRadius=0)
    rect = gmsh.model.occ.addRectangle(0, 0, 0, Lx, Ly)

    # 同步几何
    gmsh.model.occ.synchronize()

    # 获取边界曲线
    boundary = gmsh.model.getBoundary([(2, rect)], oriented=False)
    curve_tags = [tag for dim, tag in boundary]

    # 根据位置分类边界
    bottom, right, top, left = [], [], [], []
    for tag in curve_tags:
        com = gmsh.model.occ.getCenterOfMass(1, tag)
        x, y = com[0], com[1]
        if abs(y) < 1e-6:
            bottom.append(tag)
        elif abs(y - Ly) < 1e-6:
            top.append(tag)
        elif abs(x) < 1e-6:
            left.append(tag)
        elif abs(x - Lx) < 1e-6:
            right.append(tag)

    # 定义物理组
    gmsh.model.addPhysicalGroup(1, bottom, name="Bottom")
    gmsh.model.addPhysicalGroup(1, right, name="Right")
    gmsh.model.addPhysicalGroup(1, top, name="Top")
    gmsh.model.addPhysicalGroup(1, left, name="Left")
    gmsh.model.addPhysicalGroup(2, [rect], name="Domain")

    # 网格尺寸
    gmsh.option.setNumber("Mesh.MeshSizeMax", 0.1)

    # 生成网格
    gmsh.model.mesh.generate(2)

    # 保存
    gmsh.write("rectangle_occ.msh")

    if "-nopopup" not in sys.argv:
        gmsh.fltk.run()

    gmsh.finalize()

if __name__ == "__main__":
    create_rectangle_occ()
```

## 结构化四边形网格

```python
#!/usr/bin/env python3
"""
案例1: 结构化四边形网格
"""
import gmsh
import sys

def create_structured_quad_mesh():
    """创建结构化四边形网格"""
    gmsh.initialize(sys.argv)
    gmsh.model.add("structured_quad")

    # 几何参数
    Lx, Ly = 2.0, 1.0
    Nx, Ny = 20, 10  # 各方向节点数

    # 创建点
    p1 = gmsh.model.geo.addPoint(0, 0, 0)
    p2 = gmsh.model.geo.addPoint(Lx, 0, 0)
    p3 = gmsh.model.geo.addPoint(Lx, Ly, 0)
    p4 = gmsh.model.geo.addPoint(0, Ly, 0)

    # 创建线
    l1 = gmsh.model.geo.addLine(p1, p2)
    l2 = gmsh.model.geo.addLine(p2, p3)
    l3 = gmsh.model.geo.addLine(p3, p4)
    l4 = gmsh.model.geo.addLine(p4, p1)

    # 创建曲线环和平面
    cl = gmsh.model.geo.addCurveLoop([l1, l2, l3, l4])
    s = gmsh.model.geo.addPlaneSurface([cl])

    gmsh.model.geo.synchronize()

    # 设置Transfinite曲线（结构化）
    gmsh.model.mesh.setTransfiniteCurve(l1, Nx + 1)  # 底边
    gmsh.model.mesh.setTransfiniteCurve(l3, Nx + 1)  # 顶边
    gmsh.model.mesh.setTransfiniteCurve(l2, Ny + 1)  # 右边
    gmsh.model.mesh.setTransfiniteCurve(l4, Ny + 1)  # 左边

    # 设置Transfinite曲面
    gmsh.model.mesh.setTransfiniteSurface(s)

    # 重组为四边形
    gmsh.model.mesh.setRecombine(2, s)

    # 物理组
    gmsh.model.addPhysicalGroup(2, [s], name="Domain")

    # 生成网格
    gmsh.model.mesh.generate(2)

    # 保存
    gmsh.write("structured_quad.msh")

    if "-nopopup" not in sys.argv:
        gmsh.fltk.run()

    gmsh.finalize()

if __name__ == "__main__":
    create_structured_quad_mesh()
```

## 渐变网格

```python
#!/usr/bin/env python3
"""
案例1: 渐变网格（网格从左到右逐渐变粗）
"""
import gmsh
import sys

def create_graded_mesh():
    """创建渐变网格"""
    gmsh.initialize(sys.argv)
    gmsh.model.add("graded_mesh")

    Lx, Ly = 2.0, 1.0

    # 创建几何
    p1 = gmsh.model.geo.addPoint(0, 0, 0)
    p2 = gmsh.model.geo.addPoint(Lx, 0, 0)
    p3 = gmsh.model.geo.addPoint(Lx, Ly, 0)
    p4 = gmsh.model.geo.addPoint(0, Ly, 0)

    l1 = gmsh.model.geo.addLine(p1, p2)
    l2 = gmsh.model.geo.addLine(p2, p3)
    l3 = gmsh.model.geo.addLine(p3, p4)
    l4 = gmsh.model.geo.addLine(p4, p1)

    cl = gmsh.model.geo.addCurveLoop([l1, l2, l3, l4])
    s = gmsh.model.geo.addPlaneSurface([cl])

    gmsh.model.geo.synchronize()

    # 使用Progression实现渐变
    # Progression: 相邻单元尺寸比
    progression = 1.1  # 每个单元比前一个大10%

    gmsh.model.mesh.setTransfiniteCurve(l1, 20, "Progression", progression)
    gmsh.model.mesh.setTransfiniteCurve(l3, 20, "Progression", -progression)
    gmsh.model.mesh.setTransfiniteCurve(l2, 10)
    gmsh.model.mesh.setTransfiniteCurve(l4, 10)

    gmsh.model.mesh.setTransfiniteSurface(s)
    gmsh.model.mesh.setRecombine(2, s)

    gmsh.model.addPhysicalGroup(2, [s], name="Domain")

    gmsh.model.mesh.generate(2)
    gmsh.write("graded_mesh.msh")

    if "-nopopup" not in sys.argv:
        gmsh.fltk.run()

    gmsh.finalize()

if __name__ == "__main__":
    create_graded_mesh()
```

## 使用尺寸场控制网格

```python
#!/usr/bin/env python3
"""
案例1: 使用尺寸场控制网格密度
"""
import gmsh
import sys

def create_mesh_with_size_field():
    """使用尺寸场"""
    gmsh.initialize(sys.argv)
    gmsh.model.add("size_field")

    Lx, Ly = 2.0, 1.0

    # 创建矩形
    rect = gmsh.model.occ.addRectangle(0, 0, 0, Lx, Ly)
    gmsh.model.occ.synchronize()

    # 创建距离场（从左边界）
    dist = gmsh.model.mesh.field.add("Distance")
    # 获取左边界
    boundary = gmsh.model.getBoundary([(2, rect)], oriented=False)
    left_curve = []
    for dim, tag in boundary:
        com = gmsh.model.occ.getCenterOfMass(dim, tag)
        if abs(com[0]) < 1e-6:
            left_curve.append(tag)

    gmsh.model.mesh.field.setNumbers(dist, "CurvesList", left_curve)

    # 创建阈值场
    thresh = gmsh.model.mesh.field.add("Threshold")
    gmsh.model.mesh.field.setNumber(thresh, "InField", dist)
    gmsh.model.mesh.field.setNumber(thresh, "SizeMin", 0.02)
    gmsh.model.mesh.field.setNumber(thresh, "SizeMax", 0.2)
    gmsh.model.mesh.field.setNumber(thresh, "DistMin", 0.1)
    gmsh.model.mesh.field.setNumber(thresh, "DistMax", 1.0)

    gmsh.model.mesh.field.setAsBackgroundMesh(thresh)

    # 禁用默认尺寸计算
    gmsh.option.setNumber("Mesh.MeshSizeExtendFromBoundary", 0)
    gmsh.option.setNumber("Mesh.MeshSizeFromPoints", 0)
    gmsh.option.setNumber("Mesh.MeshSizeFromCurvature", 0)

    gmsh.model.addPhysicalGroup(2, [rect], name="Domain")

    gmsh.model.mesh.generate(2)
    gmsh.write("size_field.msh")

    if "-nopopup" not in sys.argv:
        gmsh.fltk.run()

    gmsh.finalize()

if __name__ == "__main__":
    create_mesh_with_size_field()
```

## 网格统计和验证

```python
#!/usr/bin/env python3
"""
案例1: 网格统计和验证
"""
import gmsh
import numpy as np

def mesh_statistics():
    """生成网格并输出统计信息"""
    gmsh.initialize()
    gmsh.model.add("statistics")

    # 创建矩形
    rect = gmsh.model.occ.addRectangle(0, 0, 0, 2, 1)
    gmsh.model.occ.synchronize()

    gmsh.option.setNumber("Mesh.MeshSizeMax", 0.1)
    gmsh.model.mesh.generate(2)

    # 获取节点
    node_tags, coords, _ = gmsh.model.mesh.getNodes()
    coords = np.array(coords).reshape(-1, 3)

    print("=" * 50)
    print("网格统计信息")
    print("=" * 50)

    print(f"\n节点数: {len(node_tags)}")
    print(f"坐标范围:")
    print(f"  X: [{coords[:, 0].min():.4f}, {coords[:, 0].max():.4f}]")
    print(f"  Y: [{coords[:, 1].min():.4f}, {coords[:, 1].max():.4f}]")

    # 获取元素
    elem_types, elem_tags, elem_nodes = gmsh.model.mesh.getElements(dim=2)

    total_elements = 0
    for etype, etags, enodes in zip(elem_types, elem_tags, elem_nodes):
        props = gmsh.model.mesh.getElementProperties(etype)
        name = props[0]
        num_nodes = props[3]
        num_elems = len(etags)
        total_elements += num_elems

        print(f"\n元素类型: {name}")
        print(f"  元素数: {num_elems}")
        print(f"  每元素节点数: {num_nodes}")

    print(f"\n总元素数: {total_elements}")

    # 网格质量
    qualities = gmsh.model.mesh.getElementQualities([], "minSJ")
    if qualities:
        q = np.array(qualities)
        print(f"\n网格质量 (scaled Jacobian):")
        print(f"  最小: {q.min():.4f}")
        print(f"  最大: {q.max():.4f}")
        print(f"  平均: {q.mean():.4f}")
        print(f"  标准差: {q.std():.4f}")

        # 质量分布
        bins = [0, 0.3, 0.5, 0.7, 0.9, 1.0]
        hist, _ = np.histogram(q, bins=bins)
        print(f"\n质量分布:")
        for i in range(len(bins) - 1):
            pct = hist[i] / len(q) * 100
            print(f"  [{bins[i]:.1f}, {bins[i+1]:.1f}): {hist[i]:5d} ({pct:.1f}%)")

    gmsh.write("statistics.msh")
    gmsh.finalize()

if __name__ == "__main__":
    mesh_statistics()
```

## 输出格式

```python
#!/usr/bin/env python3
"""
案例1: 多种输出格式
"""
import gmsh

gmsh.initialize()
gmsh.model.add("output_formats")

rect = gmsh.model.occ.addRectangle(0, 0, 0, 2, 1)
gmsh.model.occ.synchronize()
gmsh.model.addPhysicalGroup(2, [rect], name="Domain")

gmsh.option.setNumber("Mesh.MeshSizeMax", 0.1)
gmsh.model.mesh.generate(2)

# 不同格式导出
formats = [
    ("output.msh", "Gmsh MSH格式"),
    ("output.vtk", "VTK格式"),
    ("output.stl", "STL格式"),
    ("output.mesh", "MEDIT格式"),
    ("output.unv", "I-DEAS UNV格式"),
]

print("导出格式:")
for filename, desc in formats:
    try:
        gmsh.write(filename)
        print(f"  {filename}: {desc} - 成功")
    except Exception as e:
        print(f"  {filename}: {desc} - 失败: {e}")

gmsh.finalize()
```

## 总结

本案例涵盖了：

1. **两种几何内核**: geo（内置）和occ（OpenCASCADE）
2. **非结构化三角形网格**: 默认网格类型
3. **结构化四边形网格**: 使用Transfinite
4. **渐变网格**: 使用Progression
5. **尺寸场控制**: 灵活的网格密度控制
6. **网格统计**: 质量检查和验证
7. **多种输出格式**: MSH、VTK、STL等

## 下一步

- [02-带孔平面网格](./02-带孔平面网格.md) - 学习孔洞处理
