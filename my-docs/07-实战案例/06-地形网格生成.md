# 地形网格生成

本案例演示从离散高程数据生成地形网格。

## 案例目标

- 从点云数据创建地形曲面
- 处理DEM（数字高程模型）数据
- 创建自适应地形网格
- 添加地表特征

## 从点云生成地形

```python
#!/usr/bin/env python3
"""
案例6: 从点云数据生成地形网格
"""
import gmsh
import sys
import numpy as np

def create_terrain_from_points():
    """从点云创建地形"""
    gmsh.initialize(sys.argv)
    gmsh.model.add("terrain")

    # 生成示例地形数据
    # 实际应用中从文件读取
    nx, ny = 20, 20
    Lx, Ly = 100.0, 100.0

    x = np.linspace(0, Lx, nx)
    y = np.linspace(0, Ly, ny)
    X, Y = np.meshgrid(x, y)

    # 地形高度函数（模拟山丘）
    Z = 10 * np.sin(X * 0.1) * np.cos(Y * 0.1) + \
        5 * np.sin(X * 0.05 + 1) * np.sin(Y * 0.08)

    # 添加一些随机噪声
    Z += np.random.randn(ny, nx) * 0.5

    # 网格尺寸（基于高度变化）
    lc_base = 5.0

    # 创建点
    point_tags = []
    for i in range(ny):
        row = []
        for j in range(nx):
            z = Z[i, j]
            p = gmsh.model.geo.addPoint(X[i, j], Y[i, j], z, lc_base)
            row.append(p)
        point_tags.append(row)

    # 创建曲面（使用样条网格）
    # 方法1: 创建结构化曲面

    # 创建X方向样条
    x_splines = []
    for i in range(ny):
        spline = gmsh.model.geo.addSpline(point_tags[i])
        x_splines.append(spline)

    # 创建Y方向样条（连接各行的端点）
    left_spline = gmsh.model.geo.addSpline([point_tags[i][0] for i in range(ny)])
    right_spline = gmsh.model.geo.addSpline([point_tags[i][-1] for i in range(ny)])

    # 创建曲线环
    loop = gmsh.model.geo.addCurveLoop([x_splines[0], right_spline,
                                         -x_splines[-1], -left_spline])

    # 创建曲面
    surface = gmsh.model.geo.addSurfaceFilling([loop])

    gmsh.model.geo.synchronize()

    # 物理组
    gmsh.model.addPhysicalGroup(2, [surface], name="Terrain")

    # 生成网格
    gmsh.option.setNumber("Mesh.MeshSizeMax", 10.0)
    gmsh.model.mesh.generate(2)

    gmsh.write("terrain_points.msh")

    if "-nopopup" not in sys.argv:
        gmsh.fltk.run()

    gmsh.finalize()

if __name__ == "__main__":
    create_terrain_from_points()
```

## 使用OCC的曲面拟合

```python
#!/usr/bin/env python3
"""
案例6: 使用OCC创建地形曲面
"""
import gmsh
import sys
import numpy as np

def create_terrain_occ():
    """使用OCC创建地形"""
    gmsh.initialize(sys.argv)
    gmsh.model.add("terrain_occ")

    # 地形参数
    Lx, Ly = 100.0, 100.0
    nx, ny = 15, 15

    # 生成地形高度
    x = np.linspace(0, Lx, nx)
    y = np.linspace(0, Ly, ny)
    X, Y = np.meshgrid(x, y)

    # 地形函数
    Z = 5 * np.sin(X * 0.08) * np.sin(Y * 0.08) + \
        3 * np.exp(-((X - 50)**2 + (Y - 50)**2) / 500)

    # 创建B样条曲面控制点
    # 将点展平为列表
    points = []
    for i in range(ny):
        for j in range(nx):
            points.extend([X[i, j], Y[i, j], Z[i, j]])

    # 使用OCC的B样条曲面
    # addBSplineSurface(pointTags, numPointsU, degreeU=3, degreeV=3,
    #                   weights=[], knotsU=[], knotsV=[], multiplicitiesU=[],
    #                   multiplicitiesV=[], tag=-1, wireTags=[])

    # 先创建点
    point_tags = []
    for i in range(ny):
        for j in range(nx):
            p = gmsh.model.occ.addPoint(X[i, j], Y[i, j], Z[i, j])
            point_tags.append(p)

    # 创建B样条曲面
    surface = gmsh.model.occ.addBSplineSurface(point_tags, nx)

    gmsh.model.occ.synchronize()

    # 物理组
    gmsh.model.addPhysicalGroup(2, [surface], name="Terrain")

    # 根据曲率自适应网格
    gmsh.option.setNumber("Mesh.MeshSizeFromCurvature", 20)
    gmsh.option.setNumber("Mesh.MeshSizeMax", 10.0)
    gmsh.option.setNumber("Mesh.MeshSizeMin", 1.0)

    gmsh.model.mesh.generate(2)

    gmsh.write("terrain_occ.msh")

    if "-nopopup" not in sys.argv:
        gmsh.fltk.run()

    gmsh.finalize()

if __name__ == "__main__":
    create_terrain_occ()
```

## 带河流的地形

```python
#!/usr/bin/env python3
"""
案例6: 带河流的地形
"""
import gmsh
import sys
import numpy as np

def create_terrain_with_river():
    """创建带河流的地形"""
    gmsh.initialize(sys.argv)
    gmsh.model.add("terrain_river")

    # 参数
    Lx, Ly = 100.0, 80.0

    # 创建基础地形
    terrain = gmsh.model.occ.addRectangle(0, 0, 0, Lx, Ly)

    # 创建河流路径（曲线）
    river_width = 5.0

    # 河流中心线点
    river_points = [
        (0, Ly * 0.3),
        (Lx * 0.3, Ly * 0.4),
        (Lx * 0.5, Ly * 0.35),
        (Lx * 0.7, Ly * 0.5),
        (Lx, Ly * 0.6)
    ]

    # 创建河流区域（简化为矩形带）
    p1 = gmsh.model.occ.addPoint(river_points[0][0], river_points[0][1] - river_width/2, 0)
    p2 = gmsh.model.occ.addPoint(river_points[0][0], river_points[0][1] + river_width/2, 0)

    # 创建河流样条
    river_upper = []
    river_lower = []

    for x, y in river_points:
        pu = gmsh.model.occ.addPoint(x, y + river_width/2, 0)
        pl = gmsh.model.occ.addPoint(x, y - river_width/2, 0)
        river_upper.append(pu)
        river_lower.append(pl)

    # 创建河流区域
    spline_upper = gmsh.model.occ.addSpline(river_upper)
    spline_lower = gmsh.model.occ.addSpline(river_lower)
    line_start = gmsh.model.occ.addLine(river_lower[0], river_upper[0])
    line_end = gmsh.model.occ.addLine(river_upper[-1], river_lower[-1])

    loop = gmsh.model.occ.addCurveLoop([line_start, spline_upper, line_end, -spline_lower])
    river_surface = gmsh.model.occ.addPlaneSurface([loop])

    # 从地形中减去河流
    result, _ = gmsh.model.occ.cut([(2, terrain)], [(2, river_surface)],
                                    removeObject=True, removeTool=False)

    gmsh.model.occ.synchronize()

    # 获取所有曲面
    surfaces = gmsh.model.getEntities(dim=2)

    land_surfaces = []
    river_surf = []

    for dim, tag in surfaces:
        com = gmsh.model.occ.getCenterOfMass(dim, tag)
        # 简单判断：根据面积或位置
        bbox = gmsh.model.getBoundingBox(dim, tag)
        area = (bbox[3] - bbox[0]) * (bbox[4] - bbox[1])

        if area < Lx * river_width * 2:
            river_surf.append(tag)
        else:
            land_surfaces.append(tag)

    # 物理组
    if land_surfaces:
        gmsh.model.addPhysicalGroup(2, land_surfaces, name="Land")
    if river_surf:
        gmsh.model.addPhysicalGroup(2, river_surf, name="River")

    # 在河流边界加密
    boundary = gmsh.model.getBoundary([(2, s) for s in river_surf], oriented=False)
    river_boundary = [tag for dim, tag in boundary]

    if river_boundary:
        dist = gmsh.model.mesh.field.add("Distance")
        gmsh.model.mesh.field.setNumbers(dist, "CurvesList", river_boundary)

        thresh = gmsh.model.mesh.field.add("Threshold")
        gmsh.model.mesh.field.setNumber(thresh, "InField", dist)
        gmsh.model.mesh.field.setNumber(thresh, "SizeMin", 0.5)
        gmsh.model.mesh.field.setNumber(thresh, "SizeMax", 5.0)
        gmsh.model.mesh.field.setNumber(thresh, "DistMin", 1.0)
        gmsh.model.mesh.field.setNumber(thresh, "DistMax", 10.0)

        gmsh.model.mesh.field.setAsBackgroundMesh(thresh)

    gmsh.option.setNumber("Mesh.MeshSizeExtendFromBoundary", 0)

    gmsh.model.mesh.generate(2)

    gmsh.write("terrain_river.msh")

    if "-nopopup" not in sys.argv:
        gmsh.fltk.run()

    gmsh.finalize()

if __name__ == "__main__":
    create_terrain_with_river()
```

## 从DEM文件加载

```python
#!/usr/bin/env python3
"""
案例6: 从DEM文件加载地形
"""
import gmsh
import sys
import numpy as np

def load_dem_data(filename):
    """
    加载DEM数据

    支持格式：
    - ASCII Grid (.asc)
    - GeoTIFF (.tif) - 需要rasterio库
    - 简单文本文件 (.txt)
    """
    # 这里提供一个简化的示例
    # 实际应用中应根据具体格式读取

    # 模拟DEM数据
    nx, ny = 50, 50
    x = np.linspace(0, 1000, nx)
    y = np.linspace(0, 1000, ny)
    X, Y = np.meshgrid(x, y)

    # 模拟地形
    Z = 100 + 50 * np.sin(X * 0.01) * np.cos(Y * 0.01) + \
        30 * np.exp(-((X - 500)**2 + (Y - 500)**2) / 50000)

    return X, Y, Z

def create_terrain_from_dem():
    """从DEM创建地形网格"""
    gmsh.initialize(sys.argv)
    gmsh.model.add("terrain_dem")

    # 加载DEM数据
    X, Y, Z = load_dem_data("dem.tif")
    ny, nx = X.shape

    # 降采样（如果数据太大）
    step = max(1, nx // 30)
    X_s = X[::step, ::step]
    Y_s = Y[::step, ::step]
    Z_s = Z[::step, ::step]
    ny_s, nx_s = X_s.shape

    print(f"原始尺寸: {nx}x{ny}")
    print(f"采样后尺寸: {nx_s}x{ny_s}")

    # 创建点
    point_tags = []
    for i in range(ny_s):
        row = []
        for j in range(nx_s):
            p = gmsh.model.occ.addPoint(X_s[i, j], Y_s[i, j], Z_s[i, j])
            row.append(p)
        point_tags.append(row)

    # 创建B样条曲面
    flat_points = [p for row in point_tags for p in row]
    surface = gmsh.model.occ.addBSplineSurface(flat_points, nx_s)

    gmsh.model.occ.synchronize()

    # 基于曲率的自适应网格
    gmsh.option.setNumber("Mesh.MeshSizeFromCurvature", 15)
    gmsh.option.setNumber("Mesh.MeshSizeMax", 50.0)
    gmsh.option.setNumber("Mesh.MeshSizeMin", 5.0)

    gmsh.model.addPhysicalGroup(2, [surface], name="Terrain")

    gmsh.model.mesh.generate(2)

    # 统计
    node_tags, _, _ = gmsh.model.mesh.getNodes()
    elem_types, elem_tags, _ = gmsh.model.mesh.getElements(dim=2)
    num_elems = sum(len(t) for t in elem_tags)

    print(f"节点数: {len(node_tags)}")
    print(f"元素数: {num_elems}")

    gmsh.write("terrain_dem.msh")

    if "-nopopup" not in sys.argv:
        gmsh.fltk.run()

    gmsh.finalize()

if __name__ == "__main__":
    create_terrain_from_dem()
```

## 3D地形体网格

```python
#!/usr/bin/env python3
"""
案例6: 3D地形体网格
"""
import gmsh
import sys
import numpy as np

def create_3d_terrain():
    """创建3D地形体网格"""
    gmsh.initialize(sys.argv)
    gmsh.model.add("terrain_3d")

    # 参数
    Lx, Ly = 100.0, 100.0
    depth = 20.0  # 地下深度

    # 地形高度
    nx, ny = 15, 15
    x = np.linspace(0, Lx, nx)
    y = np.linspace(0, Ly, ny)
    X, Y = np.meshgrid(x, y)

    Z = 10 * np.sin(X * 0.1) * np.cos(Y * 0.1)

    # 创建顶面（地形）点
    top_points = []
    for i in range(ny):
        row = []
        for j in range(nx):
            p = gmsh.model.occ.addPoint(X[i, j], Y[i, j], Z[i, j])
            row.append(p)
        top_points.append(row)

    # 创建顶面B样条
    flat_top = [p for row in top_points for p in row]
    top_surface = gmsh.model.occ.addBSplineSurface(flat_top, nx)

    # 创建底面（平面）
    bottom_surface = gmsh.model.occ.addRectangle(0, 0, -depth, Lx, Ly)

    # 创建侧面
    # 获取顶面和底面的边界
    gmsh.model.occ.synchronize()

    # 使用extrude会更简单
    # 重新开始，使用另一种方法

    gmsh.clear()
    gmsh.model.add("terrain_3d_v2")

    # 创建底面
    bottom = gmsh.model.occ.addRectangle(0, 0, -depth, Lx, Ly)

    # 拉伸到平均高度
    avg_height = np.mean(Z)
    extrusion = gmsh.model.occ.extrude([(2, bottom)], 0, 0, depth + avg_height)

    gmsh.model.occ.synchronize()

    # 获取体积
    volumes = gmsh.model.getEntities(dim=3)
    boundary = gmsh.model.getBoundary(volumes, oriented=False)

    top_faces = []
    bottom_faces = []
    side_faces = []

    for dim, tag in boundary:
        com = gmsh.model.occ.getCenterOfMass(dim, tag)
        z = com[2]

        if z < -depth + 0.1:
            bottom_faces.append(tag)
        elif z > avg_height - 0.1:
            top_faces.append(tag)
        else:
            side_faces.append(tag)

    # 物理组
    if top_faces:
        gmsh.model.addPhysicalGroup(2, top_faces, name="Surface")
    if bottom_faces:
        gmsh.model.addPhysicalGroup(2, bottom_faces, name="Bottom")
    if side_faces:
        gmsh.model.addPhysicalGroup(2, side_faces, name="Sides")

    gmsh.model.addPhysicalGroup(3, [v[1] for v in volumes], name="Ground")

    # 网格
    gmsh.option.setNumber("Mesh.MeshSizeMax", 10.0)
    gmsh.option.setNumber("Mesh.Algorithm3D", 10)

    gmsh.model.mesh.generate(3)

    gmsh.write("terrain_3d.msh")

    if "-nopopup" not in sys.argv:
        gmsh.fltk.run()

    gmsh.finalize()

if __name__ == "__main__":
    create_3d_terrain()
```

## 自适应地形网格

```python
#!/usr/bin/env python3
"""
案例6: 基于地形特征的自适应网格
"""
import gmsh
import sys
import numpy as np

def create_adaptive_terrain():
    """创建自适应地形网格"""
    gmsh.initialize(sys.argv)
    gmsh.model.add("terrain_adaptive")

    # 参数
    Lx, Ly = 200.0, 200.0

    # 创建基础地形
    terrain = gmsh.model.occ.addRectangle(0, 0, 0, Lx, Ly)
    gmsh.model.occ.synchronize()

    # 定义感兴趣区域
    poi_x, poi_y = 100.0, 100.0  # 关注点
    poi_radius = 30.0

    # 创建多个尺寸场

    # 1. 关注区域加密
    box_field = gmsh.model.mesh.field.add("Box")
    gmsh.model.mesh.field.setNumber(box_field, "VIn", 2.0)
    gmsh.model.mesh.field.setNumber(box_field, "VOut", 10.0)
    gmsh.model.mesh.field.setNumber(box_field, "XMin", poi_x - poi_radius)
    gmsh.model.mesh.field.setNumber(box_field, "XMax", poi_x + poi_radius)
    gmsh.model.mesh.field.setNumber(box_field, "YMin", poi_y - poi_radius)
    gmsh.model.mesh.field.setNumber(box_field, "YMax", poi_y + poi_radius)

    # 2. 边界加密
    boundary = gmsh.model.getBoundary([(2, terrain)], oriented=False)
    boundary_tags = [tag for dim, tag in boundary]

    dist_field = gmsh.model.mesh.field.add("Distance")
    gmsh.model.mesh.field.setNumbers(dist_field, "CurvesList", boundary_tags)

    thresh_field = gmsh.model.mesh.field.add("Threshold")
    gmsh.model.mesh.field.setNumber(thresh_field, "InField", dist_field)
    gmsh.model.mesh.field.setNumber(thresh_field, "SizeMin", 3.0)
    gmsh.model.mesh.field.setNumber(thresh_field, "SizeMax", 10.0)
    gmsh.model.mesh.field.setNumber(thresh_field, "DistMin", 5.0)
    gmsh.model.mesh.field.setNumber(thresh_field, "DistMax", 30.0)

    # 3. 组合场（取最小值）
    min_field = gmsh.model.mesh.field.add("Min")
    gmsh.model.mesh.field.setNumbers(min_field, "FieldsList", [box_field, thresh_field])

    gmsh.model.mesh.field.setAsBackgroundMesh(min_field)

    gmsh.option.setNumber("Mesh.MeshSizeExtendFromBoundary", 0)
    gmsh.option.setNumber("Mesh.MeshSizeFromPoints", 0)

    gmsh.model.addPhysicalGroup(2, [terrain], name="Terrain")

    gmsh.model.mesh.generate(2)

    gmsh.write("terrain_adaptive.msh")

    if "-nopopup" not in sys.argv:
        gmsh.fltk.run()

    gmsh.finalize()

if __name__ == "__main__":
    create_adaptive_terrain()
```

## 总结

本案例涵盖了：

1. **点云数据处理**: 从离散点生成曲面
2. **B样条曲面**: 使用OCC的曲面拟合
3. **地形特征**: 河流、山谷等
4. **DEM数据加载**: 处理大规模地形数据
5. **3D体网格**: 从曲面生成体积
6. **自适应网格**: 根据特征调整密度

## 下一步

- [07-STL重划分](./07-STL重划分.md) - 处理STL文件
