# 3D立方体网格

本案例演示3D网格生成的基础方法。

## 案例目标

- 创建3D立方体几何
- 生成四面体和六面体网格
- 设置面和体的物理组
- 控制3D网格质量

## 基础四面体网格

```python
#!/usr/bin/env python3
"""
案例3: 3D立方体四面体网格
"""
import gmsh
import sys

def create_cube_tet_mesh():
    """创建立方体四面体网格"""
    gmsh.initialize(sys.argv)
    gmsh.model.add("cube_tet")

    # 几何参数
    L = 1.0  # 边长

    # 创建立方体
    box = gmsh.model.occ.addBox(0, 0, 0, L, L, L)
    gmsh.model.occ.synchronize()

    # 获取边界面
    boundary = gmsh.model.getBoundary([(3, box)], oriented=False)

    # 分类面
    faces = {"xmin": [], "xmax": [], "ymin": [], "ymax": [], "zmin": [], "zmax": []}

    for dim, tag in boundary:
        com = gmsh.model.occ.getCenterOfMass(dim, tag)
        x, y, z = com

        if abs(x) < 1e-6:
            faces["xmin"].append(tag)
        elif abs(x - L) < 1e-6:
            faces["xmax"].append(tag)
        elif abs(y) < 1e-6:
            faces["ymin"].append(tag)
        elif abs(y - L) < 1e-6:
            faces["ymax"].append(tag)
        elif abs(z) < 1e-6:
            faces["zmin"].append(tag)
        elif abs(z - L) < 1e-6:
            faces["zmax"].append(tag)

    # 定义物理组
    for name, tags in faces.items():
        if tags:
            gmsh.model.addPhysicalGroup(2, tags, name=name.capitalize())

    gmsh.model.addPhysicalGroup(3, [box], name="Volume")

    # 网格尺寸
    gmsh.option.setNumber("Mesh.MeshSizeMax", 0.1)

    # 生成网格
    gmsh.model.mesh.generate(3)

    # 输出统计
    elem_types, elem_tags, _ = gmsh.model.mesh.getElements(dim=3)
    total = sum(len(t) for t in elem_tags)
    print(f"四面体数量: {total}")

    gmsh.write("cube_tet.msh")

    if "-nopopup" not in sys.argv:
        gmsh.fltk.run()

    gmsh.finalize()

if __name__ == "__main__":
    create_cube_tet_mesh()
```

## 结构化六面体网格

```python
#!/usr/bin/env python3
"""
案例3: 结构化六面体网格
"""
import gmsh
import sys

def create_structured_hex_mesh():
    """创建结构化六面体网格"""
    gmsh.initialize(sys.argv)
    gmsh.model.add("cube_hex")

    L = 1.0
    N = 10  # 每边节点数

    # 使用geo内核创建几何（便于设置transfinite）
    # 创建8个顶点
    p1 = gmsh.model.geo.addPoint(0, 0, 0)
    p2 = gmsh.model.geo.addPoint(L, 0, 0)
    p3 = gmsh.model.geo.addPoint(L, L, 0)
    p4 = gmsh.model.geo.addPoint(0, L, 0)
    p5 = gmsh.model.geo.addPoint(0, 0, L)
    p6 = gmsh.model.geo.addPoint(L, 0, L)
    p7 = gmsh.model.geo.addPoint(L, L, L)
    p8 = gmsh.model.geo.addPoint(0, L, L)

    # 创建12条边
    # 底面
    l1 = gmsh.model.geo.addLine(p1, p2)
    l2 = gmsh.model.geo.addLine(p2, p3)
    l3 = gmsh.model.geo.addLine(p3, p4)
    l4 = gmsh.model.geo.addLine(p4, p1)
    # 顶面
    l5 = gmsh.model.geo.addLine(p5, p6)
    l6 = gmsh.model.geo.addLine(p6, p7)
    l7 = gmsh.model.geo.addLine(p7, p8)
    l8 = gmsh.model.geo.addLine(p8, p5)
    # 竖边
    l9 = gmsh.model.geo.addLine(p1, p5)
    l10 = gmsh.model.geo.addLine(p2, p6)
    l11 = gmsh.model.geo.addLine(p3, p7)
    l12 = gmsh.model.geo.addLine(p4, p8)

    # 创建6个面
    # 底面 (z=0)
    cl1 = gmsh.model.geo.addCurveLoop([l1, l2, l3, l4])
    s1 = gmsh.model.geo.addPlaneSurface([cl1])

    # 顶面 (z=L)
    cl2 = gmsh.model.geo.addCurveLoop([l5, l6, l7, l8])
    s2 = gmsh.model.geo.addPlaneSurface([cl2])

    # 前面 (y=0)
    cl3 = gmsh.model.geo.addCurveLoop([l1, l10, -l5, -l9])
    s3 = gmsh.model.geo.addPlaneSurface([cl3])

    # 后面 (y=L)
    cl4 = gmsh.model.geo.addCurveLoop([-l3, l11, l7, -l12])
    s4 = gmsh.model.geo.addPlaneSurface([cl4])

    # 左面 (x=0)
    cl5 = gmsh.model.geo.addCurveLoop([-l4, l12, -l8, -l9])
    s5 = gmsh.model.geo.addPlaneSurface([cl5])

    # 右面 (x=L)
    cl6 = gmsh.model.geo.addCurveLoop([l2, l11, -l6, -l10])
    s6 = gmsh.model.geo.addPlaneSurface([cl6])

    # 创建体积
    sl = gmsh.model.geo.addSurfaceLoop([s1, s2, s3, s4, s5, s6])
    v = gmsh.model.geo.addVolume([sl])

    gmsh.model.geo.synchronize()

    # 设置Transfinite
    # 所有边都设置相同节点数
    for l in [l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12]:
        gmsh.model.mesh.setTransfiniteCurve(l, N + 1)

    # 所有面设置为Transfinite
    for s in [s1, s2, s3, s4, s5, s6]:
        gmsh.model.mesh.setTransfiniteSurface(s)
        gmsh.model.mesh.setRecombine(2, s)  # 重组为四边形

    # 体积设置为Transfinite
    gmsh.model.mesh.setTransfiniteVolume(v)

    # 物理组
    gmsh.model.addPhysicalGroup(3, [v], name="Volume")

    # 生成网格
    gmsh.model.mesh.generate(3)

    elem_types, elem_tags, _ = gmsh.model.mesh.getElements(dim=3)
    total = sum(len(t) for t in elem_tags)
    print(f"六面体数量: {total}")

    gmsh.write("cube_hex.msh")

    if "-nopopup" not in sys.argv:
        gmsh.fltk.run()

    gmsh.finalize()

if __name__ == "__main__":
    create_structured_hex_mesh()
```

## 渐变网格（边界层模拟）

```python
#!/usr/bin/env python3
"""
案例3: 渐变网格
"""
import gmsh
import sys

def create_graded_cube():
    """创建渐变网格"""
    gmsh.initialize(sys.argv)
    gmsh.model.add("cube_graded")

    L = 1.0

    # 创建几何
    box = gmsh.model.occ.addBox(0, 0, 0, L, L, L)
    gmsh.model.occ.synchronize()

    # 获取底面
    boundary = gmsh.model.getBoundary([(3, box)], oriented=False)
    bottom_face = None
    for dim, tag in boundary:
        com = gmsh.model.occ.getCenterOfMass(dim, tag)
        if abs(com[2]) < 1e-6:
            bottom_face = tag
            break

    # 使用距离场从底面控制尺寸
    if bottom_face:
        dist = gmsh.model.mesh.field.add("Distance")
        gmsh.model.mesh.field.setNumbers(dist, "SurfacesList", [bottom_face])

        thresh = gmsh.model.mesh.field.add("Threshold")
        gmsh.model.mesh.field.setNumber(thresh, "InField", dist)
        gmsh.model.mesh.field.setNumber(thresh, "SizeMin", 0.02)
        gmsh.model.mesh.field.setNumber(thresh, "SizeMax", 0.15)
        gmsh.model.mesh.field.setNumber(thresh, "DistMin", 0.05)
        gmsh.model.mesh.field.setNumber(thresh, "DistMax", 0.5)

        gmsh.model.mesh.field.setAsBackgroundMesh(thresh)

    gmsh.option.setNumber("Mesh.MeshSizeExtendFromBoundary", 0)
    gmsh.option.setNumber("Mesh.MeshSizeFromPoints", 0)
    gmsh.option.setNumber("Mesh.MeshSizeFromCurvature", 0)

    # 使用HXT并行算法
    gmsh.option.setNumber("Mesh.Algorithm3D", 10)

    gmsh.model.addPhysicalGroup(3, [box], name="Volume")

    gmsh.model.mesh.generate(3)

    gmsh.write("cube_graded.msh")

    if "-nopopup" not in sys.argv:
        gmsh.fltk.run()

    gmsh.finalize()

if __name__ == "__main__":
    create_graded_cube()
```

## 带孔立方体

```python
#!/usr/bin/env python3
"""
案例3: 带通孔的立方体
"""
import gmsh
import sys

def create_cube_with_hole():
    """创建带通孔的立方体"""
    gmsh.initialize(sys.argv)
    gmsh.model.add("cube_hole")

    L = 1.0
    r = 0.2  # 孔半径

    # 创建立方体
    box = gmsh.model.occ.addBox(0, 0, 0, L, L, L)

    # 创建圆柱孔（沿Z轴）
    cylinder = gmsh.model.occ.addCylinder(L/2, L/2, 0, 0, 0, L, r)

    # 布尔差集
    result, _ = gmsh.model.occ.cut([(3, box)], [(3, cylinder)])

    gmsh.model.occ.synchronize()

    # 获取结果体积
    volume_tag = result[0][1]

    # 获取所有边界面
    boundary = gmsh.model.getBoundary([(3, volume_tag)], oriented=False)

    outer_faces = []
    hole_face = []

    for dim, tag in boundary:
        # 计算面的质心
        com = gmsh.model.occ.getCenterOfMass(dim, tag)
        x, y, z = com

        # 判断是外表面还是孔表面
        # 孔表面的质心距离Z轴接近孔半径
        dist_to_axis = ((x - L/2)**2 + (y - L/2)**2)**0.5

        if abs(dist_to_axis - r) < 0.1:
            hole_face.append(tag)
        else:
            outer_faces.append(tag)

    # 物理组
    if outer_faces:
        gmsh.model.addPhysicalGroup(2, outer_faces, name="Outer")
    if hole_face:
        gmsh.model.addPhysicalGroup(2, hole_face, name="Hole")
    gmsh.model.addPhysicalGroup(3, [volume_tag], name="Volume")

    # 孔壁加密
    dist = gmsh.model.mesh.field.add("Distance")
    gmsh.model.mesh.field.setNumbers(dist, "SurfacesList", hole_face)

    thresh = gmsh.model.mesh.field.add("Threshold")
    gmsh.model.mesh.field.setNumber(thresh, "InField", dist)
    gmsh.model.mesh.field.setNumber(thresh, "SizeMin", 0.02)
    gmsh.model.mesh.field.setNumber(thresh, "SizeMax", 0.1)
    gmsh.model.mesh.field.setNumber(thresh, "DistMin", 0.02)
    gmsh.model.mesh.field.setNumber(thresh, "DistMax", 0.3)

    gmsh.model.mesh.field.setAsBackgroundMesh(thresh)

    gmsh.option.setNumber("Mesh.MeshSizeExtendFromBoundary", 0)
    gmsh.option.setNumber("Mesh.MeshSizeFromPoints", 0)

    gmsh.model.mesh.generate(3)

    gmsh.write("cube_hole.msh")

    if "-nopopup" not in sys.argv:
        gmsh.fltk.run()

    gmsh.finalize()

if __name__ == "__main__":
    create_cube_with_hole()
```

## 高阶元素

```python
#!/usr/bin/env python3
"""
案例3: 高阶四面体网格
"""
import gmsh
import sys
import numpy as np

def create_high_order_mesh():
    """创建高阶元素网格"""
    gmsh.initialize(sys.argv)
    gmsh.model.add("cube_high_order")

    L = 1.0

    box = gmsh.model.occ.addBox(0, 0, 0, L, L, L)
    gmsh.model.occ.synchronize()

    gmsh.model.addPhysicalGroup(3, [box], name="Volume")

    # 网格尺寸
    gmsh.option.setNumber("Mesh.MeshSizeMax", 0.15)

    # 生成线性网格
    gmsh.model.mesh.generate(3)

    # 提升到高阶
    # ElementOrder: 1=线性, 2=二次, 3=三次...
    gmsh.option.setNumber("Mesh.ElementOrder", 2)

    # 高阶优化
    gmsh.option.setNumber("Mesh.HighOrderOptimize", 1)

    # 将元素提升为高阶
    gmsh.model.mesh.setOrder(2)

    # 统计
    node_tags, _, _ = gmsh.model.mesh.getNodes()
    elem_types, elem_tags, _ = gmsh.model.mesh.getElements(dim=3)

    for etype, etags in zip(elem_types, elem_tags):
        props = gmsh.model.mesh.getElementProperties(etype)
        print(f"元素类型: {props[0]}")
        print(f"  阶数: {props[2]}")
        print(f"  节点数/元素: {props[3]}")
        print(f"  元素数: {len(etags)}")

    print(f"\n总节点数: {len(node_tags)}")

    gmsh.write("cube_high_order.msh")

    if "-nopopup" not in sys.argv:
        gmsh.fltk.run()

    gmsh.finalize()

if __name__ == "__main__":
    create_high_order_mesh()
```

## 网格优化

```python
#!/usr/bin/env python3
"""
案例3: 网格优化
"""
import gmsh
import sys
import numpy as np

def optimize_cube_mesh():
    """优化立方体网格"""
    gmsh.initialize(sys.argv)
    gmsh.model.add("cube_optimized")

    L = 1.0

    box = gmsh.model.occ.addBox(0, 0, 0, L, L, L)
    gmsh.model.occ.synchronize()

    gmsh.option.setNumber("Mesh.MeshSizeMax", 0.1)

    # 生成初始网格
    gmsh.model.mesh.generate(3)

    # 获取优化前质量
    qualities_before = gmsh.model.mesh.getElementQualities([], "minSJ")
    q_before = np.array(qualities_before)
    print(f"优化前:")
    print(f"  最小质量: {q_before.min():.4f}")
    print(f"  平均质量: {q_before.mean():.4f}")

    # 优化网格
    # optimize(method="", force=false, niter=1, dimTags=[])
    # 方法:
    #   "" - 默认优化
    #   "Netgen" - Netgen优化
    #   "HighOrder" - 高阶优化
    #   "HighOrderElastic" - 弹性高阶优化
    #   "HighOrderFastCurving" - 快速曲面拟合
    #   "Laplace2D" - 2D Laplace平滑
    #   "Relocate2D" - 2D重定位
    #   "Relocate3D" - 3D重定位

    gmsh.model.mesh.optimize("Netgen")

    # 获取优化后质量
    qualities_after = gmsh.model.mesh.getElementQualities([], "minSJ")
    q_after = np.array(qualities_after)
    print(f"\n优化后:")
    print(f"  最小质量: {q_after.min():.4f}")
    print(f"  平均质量: {q_after.mean():.4f}")

    print(f"\n改进:")
    print(f"  最小质量提升: {q_after.min() - q_before.min():.4f}")
    print(f"  平均质量提升: {q_after.mean() - q_before.mean():.4f}")

    gmsh.model.addPhysicalGroup(3, [box], name="Volume")

    gmsh.write("cube_optimized.msh")

    if "-nopopup" not in sys.argv:
        gmsh.fltk.run()

    gmsh.finalize()

if __name__ == "__main__":
    optimize_cube_mesh()
```

## 完整3D工作流

```python
#!/usr/bin/env python3
"""
案例3: 完整3D工作流
"""
import gmsh
import numpy as np
import json
import sys

def complete_3d_workflow():
    """完整3D网格工作流"""
    gmsh.initialize(sys.argv)
    gmsh.model.add("complete_3d")

    # 参数
    L = 1.0

    # 创建几何
    box = gmsh.model.occ.addBox(0, 0, 0, L, L, L)
    gmsh.model.occ.synchronize()

    # 分类边界面
    boundary = gmsh.model.getBoundary([(3, box)], oriented=False)

    faces = {
        "inlet": [],   # x=0
        "outlet": [],  # x=L
        "walls": []    # 其他
    }

    for dim, tag in boundary:
        com = gmsh.model.occ.getCenterOfMass(dim, tag)
        x = com[0]

        if abs(x) < 1e-6:
            faces["inlet"].append(tag)
        elif abs(x - L) < 1e-6:
            faces["outlet"].append(tag)
        else:
            faces["walls"].append(tag)

    # 物理组
    physical_ids = {}
    for name, tags in faces.items():
        if tags:
            pg = gmsh.model.addPhysicalGroup(2, tags, name=name.capitalize())
            physical_ids[name] = pg

    pg = gmsh.model.addPhysicalGroup(3, [box], name="Fluid")
    physical_ids["volume"] = pg

    # 网格设置
    gmsh.option.setNumber("Mesh.MeshSizeMax", 0.1)
    gmsh.option.setNumber("Mesh.Algorithm3D", 10)  # HXT
    gmsh.option.setNumber("General.NumThreads", 4)

    # 生成网格
    gmsh.model.mesh.generate(3)

    # 优化
    gmsh.model.mesh.optimize("Netgen")

    # 收集统计
    node_tags, coords, _ = gmsh.model.mesh.getNodes()
    coords = np.array(coords).reshape(-1, 3)

    elem_types, elem_tags, _ = gmsh.model.mesh.getElements(dim=3)
    num_elems = sum(len(t) for t in elem_tags)

    qualities = gmsh.model.mesh.getElementQualities([], "minSJ")
    q = np.array(qualities)

    mesh_info = {
        "physical_groups": physical_ids,
        "statistics": {
            "num_nodes": len(node_tags),
            "num_elements": num_elems,
            "quality": {
                "min": float(q.min()),
                "max": float(q.max()),
                "mean": float(q.mean()),
                "std": float(q.std())
            }
        },
        "bounding_box": {
            "xmin": float(coords[:, 0].min()),
            "xmax": float(coords[:, 0].max()),
            "ymin": float(coords[:, 1].min()),
            "ymax": float(coords[:, 1].max()),
            "zmin": float(coords[:, 2].min()),
            "zmax": float(coords[:, 2].max())
        }
    }

    # 保存信息
    with open("mesh_3d_info.json", "w") as f:
        json.dump(mesh_info, f, indent=2)

    # 保存网格
    gmsh.write("complete_3d.msh")
    gmsh.write("complete_3d.vtk")

    print("3D网格生成完成:")
    print(f"  节点数: {mesh_info['statistics']['num_nodes']}")
    print(f"  元素数: {mesh_info['statistics']['num_elements']}")
    print(f"  最小质量: {mesh_info['statistics']['quality']['min']:.4f}")
    print(f"  平均质量: {mesh_info['statistics']['quality']['mean']:.4f}")

    if "-nopopup" not in sys.argv:
        gmsh.fltk.run()

    gmsh.finalize()

if __name__ == "__main__":
    complete_3d_workflow()
```

## 总结

本案例涵盖了：

1. **四面体网格**: 默认3D网格类型
2. **六面体网格**: 使用Transfinite
3. **渐变网格**: 边界层模拟
4. **带孔几何**: 布尔运算
5. **高阶元素**: 二次/三次元素
6. **网格优化**: Netgen等优化方法
7. **完整工作流**: 从几何到导出

## 下一步

- [04-CSG建模实例](./04-CSG建模实例.md) - 学习复杂布尔运算
