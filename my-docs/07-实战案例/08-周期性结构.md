# 周期性结构

本案例演示周期性单元和周期边界网格的生成。

## 案例目标

- 创建周期性单胞几何
- 设置周期性网格约束
- 生成符合周期边界条件的网格
- 应用于光子晶体、复合材料等领域

## 2D周期性单胞

```python
#!/usr/bin/env python3
"""
案例8: 2D周期性单胞
"""
import gmsh
import sys

def create_2d_unit_cell():
    """创建2D周期性单胞"""
    gmsh.initialize(sys.argv)
    gmsh.model.add("unit_cell_2d")

    # 单胞参数
    a = 1.0  # 晶格常数
    r = 0.25 # 圆孔半径

    # 创建正方形单胞
    rect = gmsh.model.occ.addRectangle(0, 0, 0, a, a)

    # 创建中心圆孔
    circle = gmsh.model.occ.addDisk(a/2, a/2, 0, r, r)

    # 布尔差集
    result, _ = gmsh.model.occ.cut([(2, rect)], [(2, circle)])

    gmsh.model.occ.synchronize()

    # 获取曲面
    surfaces = gmsh.model.getEntities(dim=2)
    surface_tag = surfaces[0][1]

    # 获取边界曲线
    boundary = gmsh.model.getBoundary(surfaces, oriented=False)

    # 分类边界
    left, right, bottom, top, hole = [], [], [], [], []

    for dim, tag in boundary:
        com = gmsh.model.occ.getCenterOfMass(dim, tag)
        x, y = com[0], com[1]

        if abs(x) < 1e-6:
            left.append(tag)
        elif abs(x - a) < 1e-6:
            right.append(tag)
        elif abs(y) < 1e-6:
            bottom.append(tag)
        elif abs(y - a) < 1e-6:
            top.append(tag)
        else:
            hole.append(tag)

    # 设置周期性约束
    # setPeriodic(dim, tags, tagsMaster, affineTransform)
    # affineTransform: 4x4仿射变换矩阵展平为16元素列表

    # 左-右周期性 (平移 a 沿 X)
    transform_x = [1, 0, 0, a,   # 第一行
                   0, 1, 0, 0,   # 第二行
                   0, 0, 1, 0,   # 第三行
                   0, 0, 0, 1]   # 第四行

    if left and right:
        gmsh.model.mesh.setPeriodic(1, right, left, transform_x)

    # 下-上周期性 (平移 a 沿 Y)
    transform_y = [1, 0, 0, 0,
                   0, 1, 0, a,
                   0, 0, 1, 0,
                   0, 0, 0, 1]

    if bottom and top:
        gmsh.model.mesh.setPeriodic(1, top, bottom, transform_y)

    # 物理组
    gmsh.model.addPhysicalGroup(1, left, name="Left")
    gmsh.model.addPhysicalGroup(1, right, name="Right")
    gmsh.model.addPhysicalGroup(1, bottom, name="Bottom")
    gmsh.model.addPhysicalGroup(1, top, name="Top")
    if hole:
        gmsh.model.addPhysicalGroup(1, hole, name="Hole")
    gmsh.model.addPhysicalGroup(2, [surface_tag], name="Matrix")

    # 网格设置
    gmsh.option.setNumber("Mesh.MeshSizeMax", 0.05)

    # 生成网格
    gmsh.model.mesh.generate(2)

    gmsh.write("unit_cell_2d.msh")

    if "-nopopup" not in sys.argv:
        gmsh.fltk.run()

    gmsh.finalize()

if __name__ == "__main__":
    create_2d_unit_cell()
```

## 3D周期性单胞

```python
#!/usr/bin/env python3
"""
案例8: 3D周期性单胞（体心立方）
"""
import gmsh
import sys

def create_3d_bcc_cell():
    """创建体心立方周期性单胞"""
    gmsh.initialize(sys.argv)
    gmsh.model.add("bcc_cell")

    # 晶格参数
    a = 1.0  # 晶格常数
    r = 0.2  # 球半径

    # 创建立方体单胞
    box = gmsh.model.occ.addBox(0, 0, 0, a, a, a)

    # 创建球体
    spheres = []

    # 角点球（1/8属于此单胞）
    corners = [
        (0, 0, 0), (a, 0, 0), (0, a, 0), (a, a, 0),
        (0, 0, a), (a, 0, a), (0, a, a), (a, a, a)
    ]
    for x, y, z in corners:
        s = gmsh.model.occ.addSphere(x, y, z, r)
        spheres.append((3, s))

    # 中心球
    center = gmsh.model.occ.addSphere(a/2, a/2, a/2, r)
    spheres.append((3, center))

    # 布尔差集
    result, _ = gmsh.model.occ.cut([(3, box)], spheres)

    gmsh.model.occ.synchronize()

    # 获取体积
    volumes = gmsh.model.getEntities(dim=3)
    vol_tag = volumes[0][1]

    # 获取边界面
    boundary = gmsh.model.getBoundary(volumes, oriented=False)

    # 分类边界面
    faces = {"xmin": [], "xmax": [], "ymin": [], "ymax": [],
             "zmin": [], "zmax": [], "spheres": []}

    for dim, tag in boundary:
        com = gmsh.model.occ.getCenterOfMass(dim, tag)
        x, y, z = com

        if abs(x) < 1e-6:
            faces["xmin"].append(tag)
        elif abs(x - a) < 1e-6:
            faces["xmax"].append(tag)
        elif abs(y) < 1e-6:
            faces["ymin"].append(tag)
        elif abs(y - a) < 1e-6:
            faces["ymax"].append(tag)
        elif abs(z) < 1e-6:
            faces["zmin"].append(tag)
        elif abs(z - a) < 1e-6:
            faces["zmax"].append(tag)
        else:
            faces["spheres"].append(tag)

    # 设置周期性约束
    # X方向
    transform_x = [1, 0, 0, a,
                   0, 1, 0, 0,
                   0, 0, 1, 0,
                   0, 0, 0, 1]
    if faces["xmin"] and faces["xmax"]:
        gmsh.model.mesh.setPeriodic(2, faces["xmax"], faces["xmin"], transform_x)

    # Y方向
    transform_y = [1, 0, 0, 0,
                   0, 1, 0, a,
                   0, 0, 1, 0,
                   0, 0, 0, 1]
    if faces["ymin"] and faces["ymax"]:
        gmsh.model.mesh.setPeriodic(2, faces["ymax"], faces["ymin"], transform_y)

    # Z方向
    transform_z = [1, 0, 0, 0,
                   0, 1, 0, 0,
                   0, 0, 1, a,
                   0, 0, 0, 1]
    if faces["zmin"] and faces["zmax"]:
        gmsh.model.mesh.setPeriodic(2, faces["zmax"], faces["zmin"], transform_z)

    # 物理组
    for name, tags in faces.items():
        if tags:
            gmsh.model.addPhysicalGroup(2, tags, name=name.capitalize())

    gmsh.model.addPhysicalGroup(3, [vol_tag], name="Matrix")

    # 网格
    gmsh.option.setNumber("Mesh.MeshSizeMax", 0.1)
    gmsh.option.setNumber("Mesh.Algorithm3D", 10)

    gmsh.model.mesh.generate(3)

    gmsh.write("bcc_cell.msh")

    if "-nopopup" not in sys.argv:
        gmsh.fltk.run()

    gmsh.finalize()

if __name__ == "__main__":
    create_3d_bcc_cell()
```

## 六边形周期单胞

```python
#!/usr/bin/env python3
"""
案例8: 六边形周期单胞（蜂窝结构）
"""
import gmsh
import sys
import math

def create_hexagonal_cell():
    """创建六边形周期单胞"""
    gmsh.initialize(sys.argv)
    gmsh.model.add("hex_cell")

    # 参数
    a = 1.0  # 六边形边长
    h = a * math.sqrt(3)  # 六边形高度

    # 六边形顶点
    points = []
    center_x, center_y = a, h/2

    for i in range(6):
        angle = math.pi / 6 + i * math.pi / 3
        x = center_x + a * math.cos(angle)
        y = center_y + a * math.sin(angle)
        p = gmsh.model.geo.addPoint(x, y, 0, 0.1)
        points.append(p)

    # 创建六边形边
    lines = []
    for i in range(6):
        l = gmsh.model.geo.addLine(points[i], points[(i+1) % 6])
        lines.append(l)

    # 曲线环和平面
    loop = gmsh.model.geo.addCurveLoop(lines)
    surface = gmsh.model.geo.addPlaneSurface([loop])

    gmsh.model.geo.synchronize()

    # 周期性设置
    # 六边形的周期性需要特殊处理
    # 平移向量: (2a, 0) 和 (a, h)

    # 找到对应的边
    # 边0和边3是水平对应的
    # 边1,2和边4,5需要组合

    # 水平方向周期性 (边0 <-> 边3)
    transform_h = [1, 0, 0, 2*a * math.cos(math.pi/6),
                   0, 1, 0, 0,
                   0, 0, 1, 0,
                   0, 0, 0, 1]

    # 物理组
    gmsh.model.addPhysicalGroup(2, [surface], name="Cell")

    # 网格
    gmsh.option.setNumber("Mesh.MeshSizeMax", 0.1)
    gmsh.model.mesh.generate(2)

    gmsh.write("hex_cell.msh")

    if "-nopopup" not in sys.argv:
        gmsh.fltk.run()

    gmsh.finalize()

if __name__ == "__main__":
    create_hexagonal_cell()
```

## 复合材料RVE

```python
#!/usr/bin/env python3
"""
案例8: 纤维增强复合材料RVE
"""
import gmsh
import sys
import math
import random

def create_fiber_rve():
    """创建纤维增强复合材料代表性体积单元"""
    gmsh.initialize(sys.argv)
    gmsh.model.add("fiber_rve")

    # RVE参数
    Lx, Ly = 10.0, 10.0
    fiber_radius = 0.5
    volume_fraction = 0.4  # 纤维体积分数
    min_distance = 0.3     # 纤维最小间距

    # 计算纤维数量
    fiber_area = math.pi * fiber_radius**2
    total_area = Lx * Ly
    target_fiber_area = total_area * volume_fraction
    num_fibers = int(target_fiber_area / fiber_area)

    print(f"目标纤维数: {num_fibers}")

    # 随机放置纤维（简单方法，无碰撞检测）
    random.seed(42)
    fiber_centers = []

    attempts = 0
    max_attempts = num_fibers * 100

    while len(fiber_centers) < num_fibers and attempts < max_attempts:
        x = random.uniform(fiber_radius, Lx - fiber_radius)
        y = random.uniform(fiber_radius, Ly - fiber_radius)

        # 检查与现有纤维的距离
        valid = True
        for cx, cy in fiber_centers:
            dist = math.sqrt((x - cx)**2 + (y - cy)**2)
            if dist < 2 * fiber_radius + min_distance:
                valid = False
                break

        if valid:
            fiber_centers.append((x, y))

        attempts += 1

    print(f"实际放置纤维数: {len(fiber_centers)}")
    actual_vf = len(fiber_centers) * fiber_area / total_area
    print(f"实际体积分数: {actual_vf:.3f}")

    # 创建基体
    matrix = gmsh.model.occ.addRectangle(0, 0, 0, Lx, Ly)

    # 创建纤维
    fibers = []
    for x, y in fiber_centers:
        f = gmsh.model.occ.addDisk(x, y, 0, fiber_radius, fiber_radius)
        fibers.append((2, f))

    # 使用fragment分割（保留纤维和基体）
    result, result_map = gmsh.model.occ.fragment([(2, matrix)], fibers)

    gmsh.model.occ.synchronize()

    # 分类区域
    surfaces = gmsh.model.getEntities(dim=2)

    matrix_surfaces = []
    fiber_surfaces = []

    for dim, tag in surfaces:
        com = gmsh.model.occ.getCenterOfMass(dim, tag)
        x, y = com[0], com[1]

        is_fiber = False
        for cx, cy in fiber_centers:
            dist = math.sqrt((x - cx)**2 + (y - cy)**2)
            if dist < fiber_radius * 0.9:
                is_fiber = True
                break

        if is_fiber:
            fiber_surfaces.append(tag)
        else:
            matrix_surfaces.append(tag)

    # 获取边界
    boundary = gmsh.model.getBoundary(surfaces, oriented=False)

    left, right, bottom, top = [], [], [], []
    for dim, tag in boundary:
        com = gmsh.model.occ.getCenterOfMass(dim, tag)
        x, y = com[0], com[1]

        if abs(x) < 1e-6:
            left.append(tag)
        elif abs(x - Lx) < 1e-6:
            right.append(tag)
        elif abs(y) < 1e-6:
            bottom.append(tag)
        elif abs(y - Ly) < 1e-6:
            top.append(tag)

    # 周期性约束
    transform_x = [1, 0, 0, Lx, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
    transform_y = [1, 0, 0, 0, 0, 1, 0, Ly, 0, 0, 1, 0, 0, 0, 0, 1]

    if left and right:
        gmsh.model.mesh.setPeriodic(1, right, left, transform_x)
    if bottom and top:
        gmsh.model.mesh.setPeriodic(1, top, bottom, transform_y)

    # 物理组
    if matrix_surfaces:
        gmsh.model.addPhysicalGroup(2, matrix_surfaces, name="Matrix")
    if fiber_surfaces:
        gmsh.model.addPhysicalGroup(2, fiber_surfaces, name="Fibers")

    # 网格
    gmsh.option.setNumber("Mesh.MeshSizeMax", 0.2)
    gmsh.option.setNumber("Mesh.MeshSizeMin", 0.05)

    # 在纤维-基体界面加密
    interface_curves = []
    for dim, tag in boundary:
        com = gmsh.model.occ.getCenterOfMass(dim, tag)
        # 内部界面
        if 0.1 < com[0] < Lx - 0.1 and 0.1 < com[1] < Ly - 0.1:
            interface_curves.append(tag)

    if interface_curves:
        dist = gmsh.model.mesh.field.add("Distance")
        gmsh.model.mesh.field.setNumbers(dist, "CurvesList", interface_curves)

        thresh = gmsh.model.mesh.field.add("Threshold")
        gmsh.model.mesh.field.setNumber(thresh, "InField", dist)
        gmsh.model.mesh.field.setNumber(thresh, "SizeMin", 0.03)
        gmsh.model.mesh.field.setNumber(thresh, "SizeMax", 0.2)
        gmsh.model.mesh.field.setNumber(thresh, "DistMin", 0.02)
        gmsh.model.mesh.field.setNumber(thresh, "DistMax", 0.3)

        gmsh.model.mesh.field.setAsBackgroundMesh(thresh)

    gmsh.model.mesh.generate(2)

    gmsh.write("fiber_rve.msh")

    if "-nopopup" not in sys.argv:
        gmsh.fltk.run()

    gmsh.finalize()

if __name__ == "__main__":
    create_fiber_rve()
```

## 验证周期性

```python
#!/usr/bin/env python3
"""
案例8: 验证周期性网格
"""
import gmsh
import numpy as np

def verify_periodic_mesh(mesh_file):
    """验证网格的周期性"""
    gmsh.initialize()
    gmsh.merge(mesh_file)

    # 获取节点
    node_tags, coords, _ = gmsh.model.mesh.getNodes()
    coords = np.array(coords).reshape(-1, 3)

    print("=" * 50)
    print("周期性验证")
    print("=" * 50)

    # 假设正方形单胞
    xmin, xmax = coords[:, 0].min(), coords[:, 0].max()
    ymin, ymax = coords[:, 1].min(), coords[:, 1].max()

    Lx = xmax - xmin
    Ly = ymax - ymin

    print(f"\n单胞尺寸: {Lx:.4f} x {Ly:.4f}")

    # 找到边界上的节点
    tol = 1e-6

    left_nodes = coords[np.abs(coords[:, 0] - xmin) < tol]
    right_nodes = coords[np.abs(coords[:, 0] - xmax) < tol]
    bottom_nodes = coords[np.abs(coords[:, 1] - ymin) < tol]
    top_nodes = coords[np.abs(coords[:, 1] - ymax) < tol]

    print(f"\n边界节点数:")
    print(f"  左边: {len(left_nodes)}")
    print(f"  右边: {len(right_nodes)}")
    print(f"  底边: {len(bottom_nodes)}")
    print(f"  顶边: {len(top_nodes)}")

    # 检查左右周期性
    if len(left_nodes) == len(right_nodes):
        # 按Y坐标排序
        left_sorted = left_nodes[np.argsort(left_nodes[:, 1])]
        right_sorted = right_nodes[np.argsort(right_nodes[:, 1])]

        # 检查Y坐标是否匹配
        y_diff = np.abs(left_sorted[:, 1] - right_sorted[:, 1])
        max_y_diff = np.max(y_diff)

        print(f"\n左右周期性:")
        print(f"  节点数匹配: {'是' if len(left_nodes) == len(right_nodes) else '否'}")
        print(f"  最大Y坐标偏差: {max_y_diff:.6e}")

        if max_y_diff < 1e-6:
            print("  状态: 周期性良好")
        else:
            print("  状态: 可能存在问题")

    # 检查上下周期性
    if len(bottom_nodes) == len(top_nodes):
        bottom_sorted = bottom_nodes[np.argsort(bottom_nodes[:, 0])]
        top_sorted = top_nodes[np.argsort(top_nodes[:, 0])]

        x_diff = np.abs(bottom_sorted[:, 0] - top_sorted[:, 0])
        max_x_diff = np.max(x_diff)

        print(f"\n上下周期性:")
        print(f"  节点数匹配: {'是' if len(bottom_nodes) == len(top_nodes) else '否'}")
        print(f"  最大X坐标偏差: {max_x_diff:.6e}")

        if max_x_diff < 1e-6:
            print("  状态: 周期性良好")
        else:
            print("  状态: 可能存在问题")

    gmsh.finalize()

if __name__ == "__main__":
    verify_periodic_mesh("unit_cell_2d.msh")
```

## 总结

本案例涵盖了：

1. **2D周期性单胞**: 基本周期性设置
2. **3D周期性单胞**: 体心立方结构
3. **六边形单胞**: 特殊周期性
4. **复合材料RVE**: 实际应用
5. **周期性验证**: 检查网格质量

## 下一步

- [09-与FEM求解器集成](./09-与FEM求解器集成.md) - 完整工作流
