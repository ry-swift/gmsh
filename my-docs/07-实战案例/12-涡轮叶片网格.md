# 涡轮叶片网格

本节介绍涡轮叶片的网格生成，包括叶型轮廓定义、流道网格、边界层处理和多排叶片的周期性网格。这是CFD中最具挑战性的网格生成任务之一。

## 学习目标

- 理解涡轮叶片几何的特殊性
- 掌握叶型轮廓的参数化建模
- 学习叶片前后缘的网格处理
- 实现单通道周期性网格

## 涡轮叶片几何基础

### 叶型轮廓参数化

```python
"""
涡轮叶片叶型轮廓参数化定义
"""
import numpy as np
import gmsh

def naca_4digit_airfoil(naca_code, num_points=100, chord=1.0):
    """
    生成NACA 4位数翼型坐标

    参数:
        naca_code: 4位数代码，如 "2412"
        num_points: 每侧点数
        chord: 弦长
    """
    m = int(naca_code[0]) / 100  # 最大弯度
    p = int(naca_code[1]) / 10   # 最大弯度位置
    t = int(naca_code[2:]) / 100 # 最大厚度

    # 参数方程
    x = np.linspace(0, 1, num_points)

    # 厚度分布
    yt = 5 * t * (0.2969*np.sqrt(x) - 0.126*x - 0.3516*x**2
                  + 0.2843*x**3 - 0.1015*x**4)

    # 中弧线
    yc = np.where(x < p,
                  m/p**2 * (2*p*x - x**2),
                  m/(1-p)**2 * ((1-2*p) + 2*p*x - x**2))

    # 中弧线斜率
    dyc = np.where(x < p,
                   2*m/p**2 * (p - x),
                   2*m/(1-p)**2 * (p - x))

    theta = np.arctan(dyc)

    # 上下表面
    xu = x - yt * np.sin(theta)
    yu = yc + yt * np.cos(theta)
    xl = x + yt * np.sin(theta)
    yl = yc - yt * np.cos(theta)

    # 缩放到实际弦长
    xu *= chord
    yu *= chord
    xl *= chord
    yl *= chord

    return xu, yu, xl, yl


def create_blade_profile(camber_angle_in, camber_angle_out, thickness_ratio,
                         stagger_angle, chord, num_points=50):
    """
    创建涡轮叶片轮廓

    参数:
        camber_angle_in: 进气角 (度)
        camber_angle_out: 出气角 (度)
        thickness_ratio: 最大厚度/弦长比
        stagger_angle: 安装角 (度)
        chord: 弦长
        num_points: 点数
    """
    # 将角度转换为弧度
    beta_in = np.radians(camber_angle_in)
    beta_out = np.radians(camber_angle_out)
    gamma = np.radians(stagger_angle)

    # 参数t从0到1
    t = np.linspace(0, 1, num_points)

    # 中弧线（使用抛物线弧）
    # 入口切线方向
    tan_in = np.tan(beta_in - gamma)
    # 出口切线方向
    tan_out = np.tan(beta_out - gamma)

    # 贝塞尔中弧线
    x_camber = chord * t
    # 使用三次贝塞尔曲线
    y_camber = chord * (tan_in * t * (1-t)**2 + tan_out * t**2 * (1-t) * 0
                        + (tan_in * 0.3 + tan_out * 0.3) * t * (1-t))

    # 厚度分布（NACA 65系列类型）
    max_thick = thickness_ratio * chord
    thickness = max_thick * (2.969*np.sqrt(t) - 1.260*t - 3.516*t**2
                              + 2.843*t**3 - 1.015*t**4)
    thickness = np.maximum(thickness, 0)  # 避免负厚度

    # 切线角度
    dx = np.gradient(x_camber)
    dy = np.gradient(y_camber)
    theta = np.arctan2(dy, dx)

    # 上下表面
    x_upper = x_camber - thickness/2 * np.sin(theta)
    y_upper = y_camber + thickness/2 * np.cos(theta)
    x_lower = x_camber + thickness/2 * np.sin(theta)
    y_lower = y_camber - thickness/2 * np.cos(theta)

    return x_upper, y_upper, x_lower, y_lower, x_camber, y_camber


# 示例：创建典型压气机叶型
if __name__ == "__main__":
    xu, yu, xl, yl, xc, yc = create_blade_profile(
        camber_angle_in=45,
        camber_angle_out=30,
        thickness_ratio=0.10,
        stagger_angle=35,
        chord=50e-3
    )
    print(f"叶型点数: {len(xu)} (每侧)")
```

## 2D叶型网格

### 基础叶型网格

```python
"""
2D涡轮叶片叶型网格
"""
import gmsh
import numpy as np

def create_2d_blade_mesh():
    gmsh.initialize()
    gmsh.model.add("blade_2d")

    # 叶片参数
    chord = 50e-3  # 弦长
    pitch = 40e-3  # 叶栅节距
    stagger = 30   # 安装角（度）

    # 使用NACA翼型简化
    naca = "4412"
    num_points = 60

    # 生成翼型坐标
    m = int(naca[0]) / 100
    p = int(naca[1]) / 10
    t = int(naca[2:]) / 100

    x = np.linspace(0, 1, num_points)
    yt = 5 * t * (0.2969*np.sqrt(x) - 0.126*x - 0.3516*x**2 + 0.2843*x**3 - 0.1015*x**4)

    yc = np.where(x < p, m/p**2 * (2*p*x - x**2), m/(1-p)**2 * ((1-2*p) + 2*p*x - x**2))
    dyc = np.where(x < p, 2*m/p**2 * (p - x), 2*m/(1-p)**2 * (p - x))
    theta = np.arctan(dyc)

    xu = (x - yt * np.sin(theta)) * chord
    yu = (yc + yt * np.cos(theta)) * chord
    xl = (x + yt * np.sin(theta)) * chord
    yl = (yc - yt * np.cos(theta)) * chord

    # 旋转到安装角
    angle = np.radians(stagger)
    cos_a, sin_a = np.cos(angle), np.sin(angle)

    xu_rot = xu * cos_a - yu * sin_a
    yu_rot = xu * sin_a + yu * cos_a
    xl_rot = xl * cos_a - yl * sin_a
    yl_rot = xl * sin_a + yl * cos_a

    # 创建叶片轮廓点
    # 上表面（从后缘到前缘）
    upper_points = []
    for i in range(len(xu)-1, -1, -1):
        pt = gmsh.model.occ.addPoint(xu_rot[i], yu_rot[i], 0)
        upper_points.append(pt)

    # 下表面（从前缘到后缘，跳过第一个点避免重复）
    lower_points = []
    for i in range(1, len(xl)):
        pt = gmsh.model.occ.addPoint(xl_rot[i], yl_rot[i], 0)
        lower_points.append(pt)

    # 创建样条曲线
    upper_spline = gmsh.model.occ.addSpline(upper_points)
    lower_spline = gmsh.model.occ.addSpline(lower_points)

    # 连接前后缘
    le_line = gmsh.model.occ.addLine(upper_points[-1], lower_points[0])  # 前缘
    te_line = gmsh.model.occ.addLine(lower_points[-1], upper_points[0])  # 后缘

    # 叶片轮廓环
    blade_loop = gmsh.model.occ.addCurveLoop([upper_spline, le_line, lower_spline, te_line])

    # 计算流道边界
    inlet_x = -chord * 0.5
    outlet_x = chord * 1.5
    lower_y = -pitch / 2
    upper_y = pitch / 2

    # 外边界点
    p_inlet_lower = gmsh.model.occ.addPoint(inlet_x, lower_y, 0)
    p_inlet_upper = gmsh.model.occ.addPoint(inlet_x, upper_y, 0)
    p_outlet_lower = gmsh.model.occ.addPoint(outlet_x, lower_y, 0)
    p_outlet_upper = gmsh.model.occ.addPoint(outlet_x, upper_y, 0)

    # 外边界线
    inlet_line = gmsh.model.occ.addLine(p_inlet_lower, p_inlet_upper)
    outlet_line = gmsh.model.occ.addLine(p_outlet_lower, p_outlet_upper)
    periodic_lower = gmsh.model.occ.addLine(p_inlet_lower, p_outlet_lower)
    periodic_upper = gmsh.model.occ.addLine(p_inlet_upper, p_outlet_upper)

    # 外边界环
    outer_loop = gmsh.model.occ.addCurveLoop([inlet_line, periodic_upper, -outlet_line, -periodic_lower])

    # 创建流道面（外边界减去叶片）
    passage = gmsh.model.occ.addPlaneSurface([outer_loop, blade_loop])

    gmsh.model.occ.synchronize()

    # 物理组
    gmsh.model.addPhysicalGroup(1, [inlet_line], name="Inlet")
    gmsh.model.addPhysicalGroup(1, [outlet_line], name="Outlet")
    gmsh.model.addPhysicalGroup(1, [periodic_lower], name="Periodic_Lower")
    gmsh.model.addPhysicalGroup(1, [periodic_upper], name="Periodic_Upper")
    gmsh.model.addPhysicalGroup(1, [upper_spline, lower_spline], name="Blade")
    gmsh.model.addPhysicalGroup(2, [passage], name="Fluid")

    # 网格尺寸
    mesh_far = chord / 10
    mesh_blade = chord / 50
    mesh_le = chord / 100  # 前缘细化

    # 尺寸场
    # 叶片表面
    gmsh.model.mesh.field.add("Distance", 1)
    gmsh.model.mesh.field.setNumbers(1, "CurvesList", [upper_spline, lower_spline])
    gmsh.model.mesh.field.setNumber(1, "Sampling", 200)

    gmsh.model.mesh.field.add("Threshold", 2)
    gmsh.model.mesh.field.setNumber(2, "InField", 1)
    gmsh.model.mesh.field.setNumber(2, "SizeMin", mesh_blade)
    gmsh.model.mesh.field.setNumber(2, "SizeMax", mesh_far)
    gmsh.model.mesh.field.setNumber(2, "DistMin", 0)
    gmsh.model.mesh.field.setNumber(2, "DistMax", chord * 0.2)

    # 前缘（x接近0）
    gmsh.model.mesh.field.add("Box", 3)
    gmsh.model.mesh.field.setNumber(3, "VIn", mesh_le)
    gmsh.model.mesh.field.setNumber(3, "VOut", mesh_far)
    gmsh.model.mesh.field.setNumber(3, "XMin", -chord * 0.1)
    gmsh.model.mesh.field.setNumber(3, "XMax", chord * 0.1)
    gmsh.model.mesh.field.setNumber(3, "YMin", -pitch/2)
    gmsh.model.mesh.field.setNumber(3, "YMax", pitch/2)
    gmsh.model.mesh.field.setNumber(3, "Thickness", chord * 0.05)

    gmsh.model.mesh.field.add("Min", 4)
    gmsh.model.mesh.field.setNumbers(4, "FieldsList", [2, 3])
    gmsh.model.mesh.field.setAsBackgroundMesh(4)

    gmsh.option.setNumber("Mesh.MeshSizeExtendFromBoundary", 0)
    gmsh.option.setNumber("Mesh.MeshSizeFromPoints", 0)
    gmsh.option.setNumber("Mesh.MeshSizeFromCurvature", 0)

    # 生成网格
    gmsh.model.mesh.generate(2)

    # 统计
    _, nodes, _ = gmsh.model.mesh.getNodes()
    elem_types, elem_tags, _ = gmsh.model.mesh.getElements(2)
    print(f"2D叶型网格统计:")
    print(f"  节点数: {len(nodes)}")
    print(f"  三角形数: {len(elem_tags[0]) if elem_tags else 0}")

    gmsh.write("blade_2d.msh")
    gmsh.finalize()

create_2d_blade_mesh()
```

### 带边界层的叶型网格

```python
"""
带边界层的2D叶型网格
"""
import gmsh
import numpy as np

def create_blade_with_bl():
    gmsh.initialize()
    gmsh.model.add("blade_2d_bl")

    # 叶片参数
    chord = 50e-3
    pitch = 40e-3
    stagger = 30

    # 边界层参数
    bl_first_height = 0.05e-3  # 第一层高度
    bl_growth = 1.15           # 增长率
    bl_layers = 20             # 层数
    bl_thickness = bl_first_height * (bl_growth**bl_layers - 1) / (bl_growth - 1)

    # 使用NACA 0012简化（对称翼型）
    num_points = 80
    x = np.linspace(0, 1, num_points)
    t = 0.12
    yt = 5 * t * (0.2969*np.sqrt(x) - 0.126*x - 0.3516*x**2 + 0.2843*x**3 - 0.1015*x**4)

    xu = x * chord
    yu = yt * chord
    xl = x * chord
    yl = -yt * chord

    # 旋转
    angle = np.radians(stagger)
    cos_a, sin_a = np.cos(angle), np.sin(angle)

    xu_rot = xu * cos_a - yu * sin_a
    yu_rot = xu * sin_a + yu * cos_a
    xl_rot = xl * cos_a - yl * sin_a
    yl_rot = xl * sin_a + yl * cos_a

    # 创建叶片
    upper_pts = [gmsh.model.occ.addPoint(xu_rot[i], yu_rot[i], 0) for i in range(len(xu)-1, -1, -1)]
    lower_pts = [gmsh.model.occ.addPoint(xl_rot[i], yl_rot[i], 0) for i in range(1, len(xl))]

    upper_spline = gmsh.model.occ.addSpline(upper_pts)
    lower_spline = gmsh.model.occ.addSpline(lower_pts)
    le_line = gmsh.model.occ.addLine(upper_pts[-1], lower_pts[0])
    te_line = gmsh.model.occ.addLine(lower_pts[-1], upper_pts[0])

    blade_loop = gmsh.model.occ.addCurveLoop([upper_spline, le_line, lower_spline, te_line])
    blade_surf = gmsh.model.occ.addPlaneSurface([blade_loop])

    # 流道边界
    inlet_x = -chord * 0.5
    outlet_x = chord * 1.5
    lower_y = -pitch / 2
    upper_y = pitch / 2

    p1 = gmsh.model.occ.addPoint(inlet_x, lower_y, 0)
    p2 = gmsh.model.occ.addPoint(inlet_x, upper_y, 0)
    p3 = gmsh.model.occ.addPoint(outlet_x, upper_y, 0)
    p4 = gmsh.model.occ.addPoint(outlet_x, lower_y, 0)

    inlet = gmsh.model.occ.addLine(p1, p2)
    top = gmsh.model.occ.addLine(p2, p3)
    outlet = gmsh.model.occ.addLine(p3, p4)
    bottom = gmsh.model.occ.addLine(p4, p1)

    outer_loop = gmsh.model.occ.addCurveLoop([inlet, top, outlet, bottom])
    passage_surf = gmsh.model.occ.addPlaneSurface([outer_loop, blade_loop])

    gmsh.model.occ.synchronize()

    # 物理组
    gmsh.model.addPhysicalGroup(1, [inlet], name="Inlet")
    gmsh.model.addPhysicalGroup(1, [outlet], name="Outlet")
    gmsh.model.addPhysicalGroup(1, [top], name="Periodic_Top")
    gmsh.model.addPhysicalGroup(1, [bottom], name="Periodic_Bottom")
    gmsh.model.addPhysicalGroup(1, [upper_spline, le_line, lower_spline, te_line], name="Blade_Wall")
    gmsh.model.addPhysicalGroup(2, [passage_surf], name="Fluid")

    # 边界层
    # 使用BoundaryLayer字段
    gmsh.model.mesh.field.add("BoundaryLayer", 1)
    gmsh.model.mesh.field.setNumbers(1, "CurvesList", [upper_spline, le_line, lower_spline, te_line])
    gmsh.model.mesh.field.setNumber(1, "Size", bl_first_height)
    gmsh.model.mesh.field.setNumber(1, "Ratio", bl_growth)
    gmsh.model.mesh.field.setNumber(1, "NbLayers", bl_layers)
    gmsh.model.mesh.field.setNumber(1, "Quads", 1)
    gmsh.model.mesh.field.setNumber(1, "IntersectMetrics", 0)

    # 远场网格尺寸
    mesh_far = chord / 15

    gmsh.model.mesh.field.add("Distance", 2)
    gmsh.model.mesh.field.setNumbers(2, "CurvesList", [upper_spline, lower_spline])
    gmsh.model.mesh.field.setNumber(2, "Sampling", 200)

    gmsh.model.mesh.field.add("Threshold", 3)
    gmsh.model.mesh.field.setNumber(3, "InField", 2)
    gmsh.model.mesh.field.setNumber(3, "SizeMin", bl_first_height * 10)
    gmsh.model.mesh.field.setNumber(3, "SizeMax", mesh_far)
    gmsh.model.mesh.field.setNumber(3, "DistMin", bl_thickness)
    gmsh.model.mesh.field.setNumber(3, "DistMax", chord * 0.3)

    gmsh.model.mesh.field.add("Min", 4)
    gmsh.model.mesh.field.setNumbers(4, "FieldsList", [3])
    gmsh.model.mesh.field.setAsBackgroundMesh(4)

    gmsh.option.setNumber("Mesh.BoundaryLayerFanElements", 8)  # 前后缘扇形单元
    gmsh.option.setNumber("Mesh.MeshSizeExtendFromBoundary", 0)
    gmsh.option.setNumber("Mesh.MeshSizeFromPoints", 0)
    gmsh.option.setNumber("Mesh.MeshSizeFromCurvature", 0)

    # 生成网格
    gmsh.model.mesh.generate(2)

    # 统计
    _, nodes, _ = gmsh.model.mesh.getNodes()
    print(f"带边界层的2D叶型网格:")
    print(f"  节点数: {len(nodes)}")
    print(f"  边界层厚度: {bl_thickness*1e3:.3f} mm")
    print(f"  边界层层数: {bl_layers}")

    gmsh.write("blade_2d_bl.msh")
    gmsh.finalize()

create_blade_with_bl()
```

## 3D叶片网格

### 直叶片拉伸

```python
"""
3D直叶片（2D叶型拉伸）
"""
import gmsh
import numpy as np

def create_3d_straight_blade():
    gmsh.initialize()
    gmsh.model.add("blade_3d_straight")

    # 参数
    chord = 50e-3
    span = 80e-3      # 叶高
    pitch = 40e-3
    stagger = 30

    # 2D叶型
    num_points = 50
    x = np.linspace(0, 1, num_points)
    t = 0.10
    yt = 5 * t * (0.2969*np.sqrt(x) - 0.126*x - 0.3516*x**2 + 0.2843*x**3 - 0.1015*x**4)

    xu = x * chord
    yu = yt * chord
    xl = x * chord
    yl = -yt * chord

    # 旋转到安装角
    angle = np.radians(stagger)
    cos_a, sin_a = np.cos(angle), np.sin(angle)

    xu_rot = xu * cos_a - yu * sin_a
    yu_rot = xu * sin_a + yu * cos_a
    xl_rot = xl * cos_a - yl * sin_a
    yl_rot = xl * sin_a + yl * cos_a

    # 创建底面叶型
    upper_pts = [gmsh.model.occ.addPoint(xu_rot[i], yu_rot[i], 0) for i in range(len(xu)-1, -1, -1)]
    lower_pts = [gmsh.model.occ.addPoint(xl_rot[i], yl_rot[i], 0) for i in range(1, len(xl))]

    upper_spline = gmsh.model.occ.addSpline(upper_pts)
    lower_spline = gmsh.model.occ.addSpline(lower_pts)
    le_line = gmsh.model.occ.addLine(upper_pts[-1], lower_pts[0])
    te_line = gmsh.model.occ.addLine(lower_pts[-1], upper_pts[0])

    blade_loop = gmsh.model.occ.addCurveLoop([upper_spline, le_line, lower_spline, te_line])
    blade_surf = gmsh.model.occ.addPlaneSurface([blade_loop])

    # 拉伸叶片
    blade_3d = gmsh.model.occ.extrude([(2, blade_surf)], 0, 0, span)
    gmsh.model.occ.synchronize()

    # 获取叶片体积
    blade_volumes = [e[1] for e in blade_3d if e[0] == 3]

    # 创建流道
    inlet_x = -chord * 0.5
    outlet_x = chord * 1.5

    passage_box = gmsh.model.occ.addBox(
        inlet_x, -pitch/2, 0,
        outlet_x - inlet_x, pitch, span
    )

    # 从流道中减去叶片
    passage_cut = gmsh.model.occ.cut([(3, passage_box)], [(3, v) for v in blade_volumes],
                                      removeObject=True, removeTool=False)
    gmsh.model.occ.synchronize()

    # 分片确保匹配
    all_volumes = gmsh.model.getEntities(3)
    gmsh.model.occ.fragment(all_volumes, [])
    gmsh.model.occ.synchronize()

    # 物理组
    all_volumes = gmsh.model.getEntities(3)
    blade_vols = []
    fluid_vols = []

    for dim, tag in all_volumes:
        bbox = gmsh.model.occ.getBoundingBox(dim, tag)
        size_x = bbox[3] - bbox[0]
        size_y = bbox[4] - bbox[1]

        if size_x < chord * 0.8:  # 叶片（窄）
            blade_vols.append(tag)
        else:  # 流道（宽）
            fluid_vols.append(tag)

    if blade_vols:
        gmsh.model.addPhysicalGroup(3, blade_vols, name="Blade_Solid")
    if fluid_vols:
        gmsh.model.addPhysicalGroup(3, fluid_vols, name="Fluid")

    # 边界面
    surfaces = gmsh.model.getEntities(2)
    inlet_surfs = []
    outlet_surfs = []
    hub_surfs = []
    shroud_surfs = []
    periodic_lower = []
    periodic_upper = []
    blade_surfs = []

    for dim, tag in surfaces:
        bbox = gmsh.model.occ.getBoundingBox(dim, tag)
        com = gmsh.model.occ.getCenterOfMass(dim, tag)

        # 入口
        if abs(bbox[0] - inlet_x) < 1e-6 and abs(bbox[3] - inlet_x) < 1e-6:
            inlet_surfs.append(tag)
        # 出口
        elif abs(bbox[0] - outlet_x) < 1e-6 and abs(bbox[3] - outlet_x) < 1e-6:
            outlet_surfs.append(tag)
        # Hub (z=0)
        elif abs(bbox[2]) < 1e-6 and abs(bbox[5]) < 1e-6:
            hub_surfs.append(tag)
        # Shroud (z=span)
        elif abs(bbox[2] - span) < 1e-6 and abs(bbox[5] - span) < 1e-6:
            shroud_surfs.append(tag)
        # 周期面
        elif abs(bbox[1] - (-pitch/2)) < 1e-6 and abs(bbox[4] - (-pitch/2)) < 1e-6:
            periodic_lower.append(tag)
        elif abs(bbox[1] - pitch/2) < 1e-6 and abs(bbox[4] - pitch/2) < 1e-6:
            periodic_upper.append(tag)
        # 叶片表面（中间区域的曲面）
        else:
            if abs(com[0]) < chord and abs(com[1]) < pitch/4:
                blade_surfs.append(tag)

    if inlet_surfs:
        gmsh.model.addPhysicalGroup(2, inlet_surfs, name="Inlet")
    if outlet_surfs:
        gmsh.model.addPhysicalGroup(2, outlet_surfs, name="Outlet")
    if hub_surfs:
        gmsh.model.addPhysicalGroup(2, hub_surfs, name="Hub")
    if shroud_surfs:
        gmsh.model.addPhysicalGroup(2, shroud_surfs, name="Shroud")
    if periodic_lower:
        gmsh.model.addPhysicalGroup(2, periodic_lower, name="Periodic_Lower")
    if periodic_upper:
        gmsh.model.addPhysicalGroup(2, periodic_upper, name="Periodic_Upper")
    if blade_surfs:
        gmsh.model.addPhysicalGroup(2, blade_surfs, name="Blade_Surface")

    # 网格尺寸
    mesh_blade = chord / 30
    mesh_passage = chord / 10

    gmsh.model.mesh.field.add("Distance", 1)
    blade_curves = [c[1] for c in gmsh.model.getEntities(1) if abs(gmsh.model.occ.getCenterOfMass(1, c[1])[0]) < chord]
    if blade_curves:
        gmsh.model.mesh.field.setNumbers(1, "CurvesList", blade_curves[:10])  # 限制数量
        gmsh.model.mesh.field.setNumber(1, "Sampling", 100)

        gmsh.model.mesh.field.add("Threshold", 2)
        gmsh.model.mesh.field.setNumber(2, "InField", 1)
        gmsh.model.mesh.field.setNumber(2, "SizeMin", mesh_blade)
        gmsh.model.mesh.field.setNumber(2, "SizeMax", mesh_passage)
        gmsh.model.mesh.field.setNumber(2, "DistMin", 0)
        gmsh.model.mesh.field.setNumber(2, "DistMax", chord * 0.2)

        gmsh.model.mesh.field.setAsBackgroundMesh(2)

    # 生成网格
    gmsh.model.mesh.generate(3)
    gmsh.model.mesh.optimize("Netgen")

    # 统计
    _, nodes, _ = gmsh.model.mesh.getNodes()
    elem_types, elem_tags, _ = gmsh.model.mesh.getElements(3)
    print(f"3D直叶片网格统计:")
    print(f"  节点数: {len(nodes)}")
    print(f"  四面体数: {sum(len(t) for t in elem_tags)}")

    gmsh.write("blade_3d_straight.msh")
    gmsh.finalize()

create_3d_straight_blade()
```

### 扭转叶片

```python
"""
3D扭转叶片（叶型沿展向变化）
"""
import gmsh
import numpy as np

def create_twisted_blade():
    gmsh.initialize()
    gmsh.model.add("twisted_blade")

    # 叶片参数
    chord_hub = 60e-3      # 轮毂处弦长
    chord_tip = 40e-3      # 叶尖处弦长
    span = 100e-3          # 叶高
    twist_angle = 20       # 扭转角度（度）
    stagger_hub = 40       # 轮毂安装角
    num_sections = 8       # 截面数

    # 叶型参数（NACA 4位）
    thickness_hub = 0.12   # 轮毂处厚度比
    thickness_tip = 0.08   # 叶尖处厚度比

    # 网格参数
    mesh_size = 3e-3

    def create_airfoil_wire(chord, thickness, stagger, z_pos):
        """在指定高度创建翼型线框"""
        num_pts = 40
        x = np.linspace(0, 1, num_pts)
        yt = 5 * thickness * (0.2969*np.sqrt(x) - 0.126*x - 0.3516*x**2 + 0.2843*x**3 - 0.1015*x**4)

        xu = x * chord
        yu = yt * chord
        xl = x * chord
        yl = -yt * chord

        # 旋转
        angle = np.radians(stagger)
        cos_a, sin_a = np.cos(angle), np.sin(angle)

        # 叶型中心偏移到原点
        center_x = chord / 2
        xu -= center_x
        xl -= center_x

        xu_rot = xu * cos_a - yu * sin_a
        yu_rot = xu * sin_a + yu * cos_a
        xl_rot = xl * cos_a - yl * sin_a
        yl_rot = xl * sin_a + yl * cos_a

        # 创建点和线
        upper_pts = [gmsh.model.occ.addPoint(xu_rot[i], yu_rot[i], z_pos)
                     for i in range(len(xu)-1, -1, -1)]
        lower_pts = [gmsh.model.occ.addPoint(xl_rot[i], yl_rot[i], z_pos)
                     for i in range(1, len(xl))]

        upper_spline = gmsh.model.occ.addSpline(upper_pts)
        lower_spline = gmsh.model.occ.addSpline(lower_pts)
        le_line = gmsh.model.occ.addLine(upper_pts[-1], lower_pts[0])
        te_line = gmsh.model.occ.addLine(lower_pts[-1], upper_pts[0])

        wire = gmsh.model.occ.addWire([upper_spline, le_line, lower_spline, te_line])
        return wire

    # 创建各截面线框
    wires = []
    for i in range(num_sections):
        t = i / (num_sections - 1)  # 0到1
        z = t * span

        # 插值参数
        chord = chord_hub + t * (chord_tip - chord_hub)
        thickness = thickness_hub + t * (thickness_tip - thickness_hub)
        stagger = stagger_hub + t * twist_angle

        wire = create_airfoil_wire(chord, thickness, stagger, z)
        wires.append(wire)

    # 使用ThruSections创建叶片
    blade = gmsh.model.occ.addThruSections(wires, makeSolid=True, makeRuled=False)
    gmsh.model.occ.synchronize()

    # 物理组
    volumes = gmsh.model.getEntities(3)
    gmsh.model.addPhysicalGroup(3, [v[1] for v in volumes], name="Blade")

    # 定义表面
    surfaces = gmsh.model.getEntities(2)
    hub_surf = []
    tip_surf = []
    blade_surf = []

    for dim, tag in surfaces:
        bbox = gmsh.model.occ.getBoundingBox(dim, tag)
        if abs(bbox[2]) < 1e-6 and abs(bbox[5]) < 1e-6:
            hub_surf.append(tag)
        elif abs(bbox[2] - span) < 1e-6 and abs(bbox[5] - span) < 1e-6:
            tip_surf.append(tag)
        else:
            blade_surf.append(tag)

    if hub_surf:
        gmsh.model.addPhysicalGroup(2, hub_surf, name="Hub_Section")
    if tip_surf:
        gmsh.model.addPhysicalGroup(2, tip_surf, name="Tip_Section")
    if blade_surf:
        gmsh.model.addPhysicalGroup(2, blade_surf, name="Blade_Surface")

    # 网格
    gmsh.model.mesh.setSize(gmsh.model.getEntities(0), mesh_size)
    gmsh.model.mesh.generate(3)
    gmsh.model.mesh.optimize("Netgen")

    # 统计
    _, nodes, _ = gmsh.model.mesh.getNodes()
    print(f"扭转叶片网格统计:")
    print(f"  节点数: {len(nodes)}")
    print(f"  扭转角: {twist_angle}°")

    gmsh.write("twisted_blade.msh")
    gmsh.finalize()

create_twisted_blade()
```

## 叶片流道完整网格

### 单通道周期性网格

```python
"""
涡轮叶片单通道周期性网格
"""
import gmsh
import numpy as np

def create_blade_passage():
    gmsh.initialize()
    gmsh.model.add("blade_passage")

    # 几何参数
    chord = 50e-3
    span = 60e-3
    pitch = 35e-3
    stagger = 35

    # 流道参数
    inlet_distance = chord * 0.8   # 入口到前缘
    outlet_distance = chord * 1.2  # 后缘到出口

    # 网格参数
    mesh_blade = chord / 40
    mesh_far = chord / 12
    mesh_bl_first = 0.02e-3
    bl_layers = 15
    bl_growth = 1.2

    # 叶型生成
    num_pts = 60
    x = np.linspace(0, 1, num_pts)
    t = 0.10
    yt = 5 * t * (0.2969*np.sqrt(x) - 0.126*x - 0.3516*x**2 + 0.2843*x**3 - 0.1015*x**4)

    xu = x * chord
    yu = yt * chord
    xl = x * chord
    yl = -yt * chord

    # 旋转
    angle = np.radians(stagger)
    cos_a, sin_a = np.cos(angle), np.sin(angle)

    xu_rot = xu * cos_a - yu * sin_a
    yu_rot = xu * sin_a + yu * cos_a
    xl_rot = xl * cos_a - yl * sin_a
    yl_rot = xl * sin_a + yl * cos_a

    # 创建2D叶型
    upper_pts = [gmsh.model.occ.addPoint(xu_rot[i], yu_rot[i], 0)
                 for i in range(len(xu)-1, -1, -1)]
    lower_pts = [gmsh.model.occ.addPoint(xl_rot[i], yl_rot[i], 0)
                 for i in range(1, len(xl))]

    upper_spline = gmsh.model.occ.addSpline(upper_pts)
    lower_spline = gmsh.model.occ.addSpline(lower_pts)
    le_line = gmsh.model.occ.addLine(upper_pts[-1], lower_pts[0])
    te_line = gmsh.model.occ.addLine(lower_pts[-1], upper_pts[0])

    blade_loop = gmsh.model.occ.addCurveLoop([upper_spline, le_line, lower_spline, te_line])
    blade_surf = gmsh.model.occ.addPlaneSurface([blade_loop])

    # 流道边界
    # 入口和出口位置
    inlet_x = xu_rot.min() - inlet_distance
    outlet_x = xu_rot.max() + outlet_distance

    # 外边界
    p1 = gmsh.model.occ.addPoint(inlet_x, -pitch/2, 0)
    p2 = gmsh.model.occ.addPoint(inlet_x, pitch/2, 0)
    p3 = gmsh.model.occ.addPoint(outlet_x, pitch/2, 0)
    p4 = gmsh.model.occ.addPoint(outlet_x, -pitch/2, 0)

    inlet_line = gmsh.model.occ.addLine(p1, p2)
    periodic_top = gmsh.model.occ.addLine(p2, p3)
    outlet_line = gmsh.model.occ.addLine(p3, p4)
    periodic_bottom = gmsh.model.occ.addLine(p4, p1)

    outer_loop = gmsh.model.occ.addCurveLoop([inlet_line, periodic_top, outlet_line, periodic_bottom])

    # 流道面（外边界 - 叶片）
    passage_surf = gmsh.model.occ.addPlaneSurface([outer_loop, blade_loop])

    # 拉伸到3D
    passage_3d = gmsh.model.occ.extrude([(2, passage_surf)], 0, 0, span)
    blade_3d = gmsh.model.occ.extrude([(2, blade_surf)], 0, 0, span)

    gmsh.model.occ.synchronize()

    # 物理组
    # 获取体积
    volumes = gmsh.model.getEntities(3)
    fluid_vols = []
    blade_vols = []

    for dim, tag in volumes:
        bbox = gmsh.model.occ.getBoundingBox(dim, tag)
        size_x = bbox[3] - bbox[0]
        if size_x > chord:
            fluid_vols.append(tag)
        else:
            blade_vols.append(tag)

    if fluid_vols:
        gmsh.model.addPhysicalGroup(3, fluid_vols, name="Fluid")
    if blade_vols:
        gmsh.model.addPhysicalGroup(3, blade_vols, name="Blade_Solid")

    # 边界面识别
    surfaces = gmsh.model.getEntities(2)

    inlet_surfs = []
    outlet_surfs = []
    hub_surfs = []
    shroud_surfs = []
    periodic_minus = []
    periodic_plus = []
    blade_surfs = []

    for dim, tag in surfaces:
        bbox = gmsh.model.occ.getBoundingBox(dim, tag)
        com = gmsh.model.occ.getCenterOfMass(dim, tag)

        eps = 1e-6

        # 入口
        if abs(bbox[0] - inlet_x) < eps and abs(bbox[3] - inlet_x) < eps:
            inlet_surfs.append(tag)
        # 出口
        elif abs(bbox[0] - outlet_x) < eps and abs(bbox[3] - outlet_x) < eps:
            outlet_surfs.append(tag)
        # Hub (z=0)
        elif abs(bbox[2]) < eps and abs(bbox[5]) < eps:
            hub_surfs.append(tag)
        # Shroud (z=span)
        elif abs(bbox[2] - span) < eps and abs(bbox[5] - span) < eps:
            shroud_surfs.append(tag)
        # 周期边界-
        elif abs(bbox[1] + pitch/2) < eps and abs(bbox[4] + pitch/2) < eps:
            periodic_minus.append(tag)
        # 周期边界+
        elif abs(bbox[1] - pitch/2) < eps and abs(bbox[4] - pitch/2) < eps:
            periodic_plus.append(tag)
        # 叶片表面
        else:
            if abs(com[0]) < chord * 1.5 and abs(com[1]) < pitch/3:
                blade_surfs.append(tag)

    if inlet_surfs:
        gmsh.model.addPhysicalGroup(2, inlet_surfs, name="Inlet")
    if outlet_surfs:
        gmsh.model.addPhysicalGroup(2, outlet_surfs, name="Outlet")
    if hub_surfs:
        gmsh.model.addPhysicalGroup(2, hub_surfs, name="Hub")
    if shroud_surfs:
        gmsh.model.addPhysicalGroup(2, shroud_surfs, name="Shroud")
    if periodic_minus:
        gmsh.model.addPhysicalGroup(2, periodic_minus, name="Periodic_Minus")
    if periodic_plus:
        gmsh.model.addPhysicalGroup(2, periodic_plus, name="Periodic_Plus")
    if blade_surfs:
        gmsh.model.addPhysicalGroup(2, blade_surfs, name="Blade_Wall")

    # 设置周期性约束
    if periodic_minus and periodic_plus:
        # 平移向量
        translation = [0, pitch, 0]
        try:
            for surf_minus in periodic_minus:
                for surf_plus in periodic_plus:
                    # 这里简化处理，实际需要匹配对应面
                    pass
        except:
            pass

    # 尺寸场
    # 叶片表面细化
    if blade_surfs:
        gmsh.model.mesh.field.add("Distance", 1)
        gmsh.model.mesh.field.setNumbers(1, "SurfacesList", blade_surfs[:5])  # 限制
        gmsh.model.mesh.field.setNumber(1, "Sampling", 100)

        gmsh.model.mesh.field.add("Threshold", 2)
        gmsh.model.mesh.field.setNumber(2, "InField", 1)
        gmsh.model.mesh.field.setNumber(2, "SizeMin", mesh_blade)
        gmsh.model.mesh.field.setNumber(2, "SizeMax", mesh_far)
        gmsh.model.mesh.field.setNumber(2, "DistMin", 0)
        gmsh.model.mesh.field.setNumber(2, "DistMax", chord * 0.15)

        gmsh.model.mesh.field.setAsBackgroundMesh(2)

    # 前缘区域额外细化
    le_x = xu_rot.min()
    gmsh.model.mesh.field.add("Box", 3)
    gmsh.model.mesh.field.setNumber(3, "VIn", mesh_blade / 2)
    gmsh.model.mesh.field.setNumber(3, "VOut", mesh_far)
    gmsh.model.mesh.field.setNumber(3, "XMin", le_x - chord * 0.1)
    gmsh.model.mesh.field.setNumber(3, "XMax", le_x + chord * 0.1)
    gmsh.model.mesh.field.setNumber(3, "YMin", -pitch/2)
    gmsh.model.mesh.field.setNumber(3, "YMax", pitch/2)
    gmsh.model.mesh.field.setNumber(3, "ZMin", 0)
    gmsh.model.mesh.field.setNumber(3, "ZMax", span)

    gmsh.model.mesh.field.add("Min", 4)
    gmsh.model.mesh.field.setNumbers(4, "FieldsList", [2, 3])
    gmsh.model.mesh.field.setAsBackgroundMesh(4)

    gmsh.option.setNumber("Mesh.MeshSizeExtendFromBoundary", 0)
    gmsh.option.setNumber("Mesh.MeshSizeFromPoints", 0)
    gmsh.option.setNumber("Mesh.MeshSizeFromCurvature", 0)

    # 生成网格
    gmsh.model.mesh.generate(3)
    gmsh.model.mesh.optimize("Netgen")

    # 统计
    _, nodes, _ = gmsh.model.mesh.getNodes()
    elem_types, elem_tags, _ = gmsh.model.mesh.getElements(3)

    print(f"叶片流道网格统计:")
    print(f"  节点数: {len(nodes)}")
    print(f"  四面体数: {sum(len(t) for t in elem_tags)}")
    print(f"  流道尺寸: {(outlet_x-inlet_x)*1e3:.1f} x {pitch*1e3:.1f} x {span*1e3:.1f} mm")

    gmsh.write("blade_passage.msh")
    gmsh.finalize()

create_blade_passage()
```

## 网格质量检查

### 涡轮叶片网格质量工具

```python
"""
涡轮叶片网格质量检查工具
"""
import gmsh
import numpy as np

def check_blade_mesh_quality(msh_file):
    """检查叶片网格质量"""
    gmsh.initialize()
    gmsh.open(msh_file)

    print("涡轮叶片网格质量检查")
    print("=" * 50)

    # 基本统计
    _, node_coords, _ = gmsh.model.mesh.getNodes()
    node_coords = node_coords.reshape(-1, 3)
    print(f"节点数: {len(node_coords)}")

    # 边界框
    bbox = [node_coords.min(axis=0), node_coords.max(axis=0)]
    print(f"边界框: X[{bbox[0][0]*1e3:.2f}, {bbox[1][0]*1e3:.2f}] mm")
    print(f"        Y[{bbox[0][1]*1e3:.2f}, {bbox[1][1]*1e3:.2f}] mm")
    print(f"        Z[{bbox[0][2]*1e3:.2f}, {bbox[1][2]*1e3:.2f}] mm")

    # 检查各维度单元
    for dim in [2, 3]:
        elem_types, elem_tags, elem_nodes = gmsh.model.mesh.getElements(dim)
        if elem_tags:
            total = sum(len(t) for t in elem_tags)
            print(f"{dim}D单元数: {total}")

    # 质量检查（使用Gmsh内置）
    print("\n质量指标:")

    # SICN (Signed Inverse Condition Number)
    elem_types, elem_tags, _ = gmsh.model.mesh.getElements(3)
    if elem_tags:
        # 计算质量
        qualities = []
        for tet_tag in elem_tags[0][:1000]:  # 采样
            try:
                # 获取单元质量
                qual = gmsh.model.mesh.getElementQualities([tet_tag], "sicn")
                qualities.extend(qual)
            except:
                pass

        if qualities:
            qualities = np.array(qualities)
            print(f"  SICN (采样):")
            print(f"    最小值: {qualities.min():.4f}")
            print(f"    最大值: {qualities.max():.4f}")
            print(f"    平均值: {qualities.mean():.4f}")

            # 质量警告
            poor = np.sum(qualities < 0.1)
            if poor > 0:
                print(f"  ⚠ 警告: {poor} 个低质量单元 (SICN < 0.1)")
            else:
                print(f"  ✓ 所有采样单元质量良好")

    gmsh.finalize()


# 边界层质量检查
def check_boundary_layer_quality(msh_file, wall_name="Blade_Wall"):
    """检查边界层网格质量"""
    gmsh.initialize()
    gmsh.open(msh_file)

    print(f"\n边界层网格检查 (壁面: {wall_name})")
    print("-" * 40)

    # 找到壁面物理组
    groups = gmsh.model.getPhysicalGroups(2)
    wall_tag = None
    for dim, tag in groups:
        name = gmsh.model.getPhysicalName(dim, tag)
        if name == wall_name:
            wall_tag = tag
            break

    if wall_tag is None:
        print(f"未找到物理组: {wall_name}")
        gmsh.finalize()
        return

    # 获取壁面节点
    wall_entities = gmsh.model.getEntitiesForPhysicalGroup(2, wall_tag)
    wall_nodes = set()
    for entity in wall_entities:
        _, tags, _ = gmsh.model.mesh.getNodes(2, entity)
        wall_nodes.update(tags)

    print(f"壁面节点数: {len(wall_nodes)}")

    # 获取所有节点坐标
    _, all_node_tags, all_coords = gmsh.model.mesh.getNodes()
    coord_map = {}
    for i, tag in enumerate(all_node_tags):
        coord_map[tag] = all_coords[i*3:(i+1)*3]

    # 分析壁面附近单元
    # 这里简化，只检查壁面单元的质量
    wall_elem_types, wall_elem_tags, _ = gmsh.model.mesh.getElements(2)
    if wall_elem_tags:
        print(f"壁面单元数: {sum(len(t) for t in wall_elem_tags)}")

    gmsh.finalize()


if __name__ == "__main__":
    # 示例使用
    # check_blade_mesh_quality("blade_passage.msh")
    pass
```

## 完整案例：压气机级网格

```python
"""
压气机级完整网格生成
"""
import gmsh
import numpy as np

class CompressorBladeMesher:
    """压气机叶片网格生成器"""

    def __init__(self):
        # 默认几何参数
        self.geometry = {
            'chord': 40e-3,
            'span': 50e-3,
            'pitch': 30e-3,
            'stagger': 40,
            'thickness': 0.08,
            'inlet_distance': 0.6,  # 相对于弦长
            'outlet_distance': 1.0
        }

        # 网格参数
        self.mesh = {
            'blade_size': None,     # 自动计算
            'passage_size': None,
            'le_refinement': 2.0,   # 前缘细化倍数
            'te_refinement': 1.5,   # 后缘细化倍数
            'bl_first': 0.01e-3,
            'bl_growth': 1.2,
            'bl_layers': 20
        }

    def set_geometry(self, **kwargs):
        """设置几何参数"""
        self.geometry.update(kwargs)

    def set_mesh_params(self, **kwargs):
        """设置网格参数"""
        self.mesh.update(kwargs)

    def generate_airfoil_coords(self, chord, thickness, num_points=50):
        """生成NACA翼型坐标"""
        x = np.linspace(0, 1, num_points)
        t = thickness
        yt = 5 * t * (0.2969*np.sqrt(x) - 0.126*x - 0.3516*x**2 + 0.2843*x**3 - 0.1015*x**4)

        xu = x * chord
        yu = yt * chord
        xl = x * chord
        yl = -yt * chord

        return xu, yu, xl, yl

    def create_geometry(self):
        """创建几何模型"""
        g = self.geometry

        # 生成翼型
        xu, yu, xl, yl = self.generate_airfoil_coords(g['chord'], g['thickness'])

        # 旋转
        angle = np.radians(g['stagger'])
        cos_a, sin_a = np.cos(angle), np.sin(angle)

        xu_rot = xu * cos_a - yu * sin_a
        yu_rot = xu * sin_a + yu * cos_a
        xl_rot = xl * cos_a - yl * sin_a
        yl_rot = xl * sin_a + yl * cos_a

        # 创建点和线
        num_pts = len(xu)
        upper_pts = [gmsh.model.occ.addPoint(xu_rot[i], yu_rot[i], 0)
                     for i in range(num_pts-1, -1, -1)]
        lower_pts = [gmsh.model.occ.addPoint(xl_rot[i], yl_rot[i], 0)
                     for i in range(1, num_pts)]

        upper_spline = gmsh.model.occ.addSpline(upper_pts)
        lower_spline = gmsh.model.occ.addSpline(lower_pts)
        le_line = gmsh.model.occ.addLine(upper_pts[-1], lower_pts[0])
        te_line = gmsh.model.occ.addLine(lower_pts[-1], upper_pts[0])

        blade_loop = gmsh.model.occ.addCurveLoop([upper_spline, le_line, lower_spline, te_line])
        blade_surf = gmsh.model.occ.addPlaneSurface([blade_loop])

        # 流道边界
        inlet_x = xu_rot.min() - g['inlet_distance'] * g['chord']
        outlet_x = xu_rot.max() + g['outlet_distance'] * g['chord']

        p1 = gmsh.model.occ.addPoint(inlet_x, -g['pitch']/2, 0)
        p2 = gmsh.model.occ.addPoint(inlet_x, g['pitch']/2, 0)
        p3 = gmsh.model.occ.addPoint(outlet_x, g['pitch']/2, 0)
        p4 = gmsh.model.occ.addPoint(outlet_x, -g['pitch']/2, 0)

        inlet = gmsh.model.occ.addLine(p1, p2)
        top = gmsh.model.occ.addLine(p2, p3)
        outlet = gmsh.model.occ.addLine(p3, p4)
        bottom = gmsh.model.occ.addLine(p4, p1)

        outer_loop = gmsh.model.occ.addCurveLoop([inlet, top, outlet, bottom])
        passage_surf = gmsh.model.occ.addPlaneSurface([outer_loop, blade_loop])

        # 拉伸到3D
        passage_3d = gmsh.model.occ.extrude([(2, passage_surf)], 0, 0, g['span'])
        blade_3d = gmsh.model.occ.extrude([(2, blade_surf)], 0, 0, g['span'])

        gmsh.model.occ.synchronize()

        # 存储关键几何信息
        self._inlet_x = inlet_x
        self._outlet_x = outlet_x
        self._le_x = xu_rot.min()
        self._te_x = xu_rot.max()

        return {
            'upper_spline': upper_spline,
            'lower_spline': lower_spline,
            'le_line': le_line,
            'te_line': te_line
        }

    def setup_physical_groups(self):
        """设置物理组"""
        g = self.geometry

        volumes = gmsh.model.getEntities(3)
        surfaces = gmsh.model.getEntities(2)

        # 分类体积
        fluid_vols = []
        blade_vols = []
        for dim, tag in volumes:
            bbox = gmsh.model.occ.getBoundingBox(dim, tag)
            if bbox[3] - bbox[0] > g['chord']:
                fluid_vols.append(tag)
            else:
                blade_vols.append(tag)

        if fluid_vols:
            gmsh.model.addPhysicalGroup(3, fluid_vols, name="Fluid")
        if blade_vols:
            gmsh.model.addPhysicalGroup(3, blade_vols, name="Blade")

        # 分类面
        inlet_s, outlet_s, hub_s, shroud_s = [], [], [], []
        periodic_m, periodic_p, blade_s = [], [], []

        for dim, tag in surfaces:
            bbox = gmsh.model.occ.getBoundingBox(dim, tag)
            com = gmsh.model.occ.getCenterOfMass(dim, tag)
            eps = 1e-6

            if abs(bbox[0] - self._inlet_x) < eps and abs(bbox[3] - self._inlet_x) < eps:
                inlet_s.append(tag)
            elif abs(bbox[0] - self._outlet_x) < eps and abs(bbox[3] - self._outlet_x) < eps:
                outlet_s.append(tag)
            elif abs(bbox[2]) < eps and abs(bbox[5]) < eps:
                hub_s.append(tag)
            elif abs(bbox[2] - g['span']) < eps and abs(bbox[5] - g['span']) < eps:
                shroud_s.append(tag)
            elif abs(bbox[1] + g['pitch']/2) < eps:
                periodic_m.append(tag)
            elif abs(bbox[1] - g['pitch']/2) < eps:
                periodic_p.append(tag)
            elif abs(com[0] - (self._le_x + self._te_x)/2) < g['chord']:
                if abs(com[1]) < g['pitch']/3:
                    blade_s.append(tag)

        if inlet_s: gmsh.model.addPhysicalGroup(2, inlet_s, name="Inlet")
        if outlet_s: gmsh.model.addPhysicalGroup(2, outlet_s, name="Outlet")
        if hub_s: gmsh.model.addPhysicalGroup(2, hub_s, name="Hub")
        if shroud_s: gmsh.model.addPhysicalGroup(2, shroud_s, name="Shroud")
        if periodic_m: gmsh.model.addPhysicalGroup(2, periodic_m, name="Periodic_Minus")
        if periodic_p: gmsh.model.addPhysicalGroup(2, periodic_p, name="Periodic_Plus")
        if blade_s: gmsh.model.addPhysicalGroup(2, blade_s, name="Blade_Wall")

        return blade_s

    def setup_mesh_fields(self, blade_surfaces):
        """设置网格尺寸场"""
        g = self.geometry
        m = self.mesh

        # 自动计算网格尺寸
        if m['blade_size'] is None:
            m['blade_size'] = g['chord'] / 40
        if m['passage_size'] is None:
            m['passage_size'] = g['chord'] / 12

        # 叶片表面距离场
        if blade_surfaces:
            gmsh.model.mesh.field.add("Distance", 1)
            gmsh.model.mesh.field.setNumbers(1, "SurfacesList", blade_surfaces[:5])
            gmsh.model.mesh.field.setNumber(1, "Sampling", 100)

            gmsh.model.mesh.field.add("Threshold", 2)
            gmsh.model.mesh.field.setNumber(2, "InField", 1)
            gmsh.model.mesh.field.setNumber(2, "SizeMin", m['blade_size'])
            gmsh.model.mesh.field.setNumber(2, "SizeMax", m['passage_size'])
            gmsh.model.mesh.field.setNumber(2, "DistMin", 0)
            gmsh.model.mesh.field.setNumber(2, "DistMax", g['chord'] * 0.15)

        # 前缘细化
        gmsh.model.mesh.field.add("Box", 3)
        gmsh.model.mesh.field.setNumber(3, "VIn", m['blade_size'] / m['le_refinement'])
        gmsh.model.mesh.field.setNumber(3, "VOut", m['passage_size'])
        gmsh.model.mesh.field.setNumber(3, "XMin", self._le_x - g['chord'] * 0.1)
        gmsh.model.mesh.field.setNumber(3, "XMax", self._le_x + g['chord'] * 0.15)
        gmsh.model.mesh.field.setNumber(3, "YMin", -g['pitch']/2)
        gmsh.model.mesh.field.setNumber(3, "YMax", g['pitch']/2)
        gmsh.model.mesh.field.setNumber(3, "ZMin", 0)
        gmsh.model.mesh.field.setNumber(3, "ZMax", g['span'])

        # 后缘细化
        gmsh.model.mesh.field.add("Box", 4)
        gmsh.model.mesh.field.setNumber(4, "VIn", m['blade_size'] / m['te_refinement'])
        gmsh.model.mesh.field.setNumber(4, "VOut", m['passage_size'])
        gmsh.model.mesh.field.setNumber(4, "XMin", self._te_x - g['chord'] * 0.1)
        gmsh.model.mesh.field.setNumber(4, "XMax", self._te_x + g['chord'] * 0.2)
        gmsh.model.mesh.field.setNumber(4, "YMin", -g['pitch']/2)
        gmsh.model.mesh.field.setNumber(4, "YMax", g['pitch']/2)
        gmsh.model.mesh.field.setNumber(4, "ZMin", 0)
        gmsh.model.mesh.field.setNumber(4, "ZMax", g['span'])

        gmsh.model.mesh.field.add("Min", 5)
        gmsh.model.mesh.field.setNumbers(5, "FieldsList", [2, 3, 4])
        gmsh.model.mesh.field.setAsBackgroundMesh(5)

        gmsh.option.setNumber("Mesh.MeshSizeExtendFromBoundary", 0)
        gmsh.option.setNumber("Mesh.MeshSizeFromPoints", 0)
        gmsh.option.setNumber("Mesh.MeshSizeFromCurvature", 0)

    def generate(self, output_file="compressor_blade.msh"):
        """生成网格"""
        gmsh.initialize()
        gmsh.model.add("compressor_blade")

        # 创建几何
        geom_info = self.create_geometry()

        # 设置物理组
        blade_surfaces = self.setup_physical_groups()

        # 设置网格
        self.setup_mesh_fields(blade_surfaces)

        # 生成网格
        gmsh.model.mesh.generate(3)
        gmsh.model.mesh.optimize("Netgen")

        # 保存
        gmsh.write(output_file)

        # 统计
        _, nodes, _ = gmsh.model.mesh.getNodes()
        elem_types, elem_tags, _ = gmsh.model.mesh.getElements(3)

        print(f"压气机叶片网格统计:")
        print(f"  弦长: {self.geometry['chord']*1e3:.1f} mm")
        print(f"  叶高: {self.geometry['span']*1e3:.1f} mm")
        print(f"  节距: {self.geometry['pitch']*1e3:.1f} mm")
        print(f"  节点数: {len(nodes)}")
        print(f"  四面体数: {sum(len(t) for t in elem_tags)}")

        gmsh.finalize()
        return output_file


# 使用示例
if __name__ == "__main__":
    mesher = CompressorBladeMesher()

    # 设置几何
    mesher.set_geometry(
        chord=45e-3,
        span=60e-3,
        pitch=35e-3,
        stagger=38,
        thickness=0.10
    )

    # 设置网格
    mesher.set_mesh_params(
        le_refinement=2.5,
        te_refinement=2.0
    )

    # 生成
    mesher.generate("compressor_stage.msh")
```

## 小结

本节介绍了涡轮叶片网格生成的关键技术：

1. **叶型参数化**：NACA翼型、参数化叶型曲线
2. **2D叶型网格**：样条曲线定义、边界层网格
3. **3D叶片网格**：拉伸、扭转叶片
4. **流道网格**：单通道周期性网格
5. **网格质量检查**：专用检查工具

关键技术要点：
- 前后缘是网格细化的关键区域
- 边界层网格对CFD精度至关重要
- 周期性边界条件减少计算量
- 扭转叶片需要多截面过渡
- 网格质量直接影响求解收敛性
