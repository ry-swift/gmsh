# 波导结构网格

本节介绍电磁波导结构的网格生成，包括矩形波导、圆波导、同轴线和微带线等常见结构。

## 学习目标

- 理解波导网格的特殊要求
- 掌握电磁仿真网格密度准则
- 学习周期边界在波导中的应用
- 实现多介质区域的网格划分

## 电磁网格基础

### 网格密度准则

```python
"""
电磁仿真网格密度准则
"""
import gmsh
import numpy as np

def calculate_mesh_size(frequency, epsilon_r=1.0, elements_per_wavelength=10):
    """
    根据频率计算网格尺寸

    参数:
        frequency: 工作频率 (Hz)
        epsilon_r: 相对介电常数
        elements_per_wavelength: 每波长单元数（通常10-20）

    返回:
        mesh_size: 推荐网格尺寸 (m)
    """
    c = 299792458  # 光速 (m/s)
    wavelength = c / (frequency * np.sqrt(epsilon_r))
    mesh_size = wavelength / elements_per_wavelength

    print(f"频率: {frequency/1e9:.2f} GHz")
    print(f"相对介电常数: {epsilon_r}")
    print(f"波长: {wavelength*1000:.2f} mm")
    print(f"推荐网格尺寸: {mesh_size*1000:.3f} mm")

    return mesh_size

# 示例：X波段（10 GHz）
mesh_size_air = calculate_mesh_size(10e9, epsilon_r=1.0)
print()
# 在介质中（FR4, εr≈4.4）
mesh_size_fr4 = calculate_mesh_size(10e9, epsilon_r=4.4)
```

## 矩形波导

### 基础矩形波导

```python
"""
WR-90矩形波导（X波段：8.2-12.4 GHz）
"""
import gmsh
import numpy as np

gmsh.initialize()
gmsh.model.add("rectangular_waveguide")

# WR-90波导尺寸（标准尺寸）
a = 22.86e-3  # 宽边 (m)
b = 10.16e-3  # 窄边 (m)
L = 50e-3     # 长度 (m)

# 工作频率和网格参数
freq = 10e9  # 10 GHz
c = 299792458
wavelength = c / freq
mesh_size = wavelength / 15  # 每波长15个单元

# 创建波导几何
box = gmsh.model.occ.addBox(0, 0, 0, a, b, L)
gmsh.model.occ.synchronize()

# 定义物理组
# 获取所有面
surfaces = gmsh.model.getEntities(2)
inlet = []
outlet = []
walls = []

for dim, tag in surfaces:
    com = gmsh.model.occ.getCenterOfMass(dim, tag)
    if abs(com[2]) < 1e-10:  # z=0 面
        inlet.append(tag)
    elif abs(com[2] - L) < 1e-10:  # z=L 面
        outlet.append(tag)
    else:
        walls.append(tag)

# 创建物理组
gmsh.model.addPhysicalGroup(2, inlet, name="Port_In")
gmsh.model.addPhysicalGroup(2, outlet, name="Port_Out")
gmsh.model.addPhysicalGroup(2, walls, name="PEC_Walls")
gmsh.model.addPhysicalGroup(3, [box], name="Air")

# 设置网格尺寸
gmsh.model.mesh.setSize(gmsh.model.getEntities(0), mesh_size)

# 生成网格
gmsh.model.mesh.generate(3)

# 优化
gmsh.model.mesh.optimize("Netgen")

# 统计
_, node_tags, _ = gmsh.model.mesh.getNodes()
elem_types, elem_tags, _ = gmsh.model.mesh.getElements(3)
print(f"矩形波导网格统计:")
print(f"  节点数: {len(node_tags)}")
print(f"  四面体数: {len(elem_tags[0]) if elem_tags else 0}")

gmsh.write("rectangular_waveguide.msh")
gmsh.finalize()
```

### 带虹膜的波导滤波器

```python
"""
H面虹膜波导滤波器
"""
import gmsh
import numpy as np

gmsh.initialize()
gmsh.model.add("iris_filter")

# WR-90尺寸
a = 22.86e-3
b = 10.16e-3

# 滤波器参数
num_iris = 3  # 虹膜数量
cavity_length = 15e-3  # 腔体长度
iris_thickness = 2e-3  # 虹膜厚度
iris_openings = [12e-3, 10e-3, 12e-3]  # 虹膜开口宽度

# 网格参数
freq = 10e9
wavelength = 3e8 / freq
mesh_coarse = wavelength / 10
mesh_fine = wavelength / 20  # 虹膜处细化

# 输入波导
z_pos = 0
input_length = 20e-3
input_wg = gmsh.model.occ.addBox(0, 0, z_pos, a, b, input_length)
z_pos += input_length

volumes = [input_wg]

# 创建腔体和虹膜
for i in range(num_iris):
    # 虹膜
    iris_opening = iris_openings[i]
    iris_offset = (a - iris_opening) / 2

    # 虹膜分为两部分（左右金属块，中间开口）
    iris_left = gmsh.model.occ.addBox(0, 0, z_pos, iris_offset, b, iris_thickness)
    iris_right = gmsh.model.occ.addBox(a - iris_offset, 0, z_pos, iris_offset, b, iris_thickness)
    iris_center = gmsh.model.occ.addBox(iris_offset, 0, z_pos, iris_opening, b, iris_thickness)

    # 只保留中间开口部分
    volumes.append(iris_center)
    z_pos += iris_thickness

    # 腔体（最后一个虹膜后不需要腔体）
    if i < num_iris - 1:
        cavity = gmsh.model.occ.addBox(0, 0, z_pos, a, b, cavity_length)
        volumes.append(cavity)
        z_pos += cavity_length

# 输出波导
output_length = 20e-3
output_wg = gmsh.model.occ.addBox(0, 0, z_pos, a, b, output_length)
volumes.append(output_wg)
z_pos += output_length

# 融合所有体积
fused = gmsh.model.occ.fuse([(3, volumes[0])], [(3, v) for v in volumes[1:]])
gmsh.model.occ.synchronize()

# 物理组
all_volumes = gmsh.model.getEntities(3)
gmsh.model.addPhysicalGroup(3, [v[1] for v in all_volumes], name="Air")

# 找端口面
surfaces = gmsh.model.getEntities(2)
for dim, tag in surfaces:
    com = gmsh.model.occ.getCenterOfMass(dim, tag)
    if abs(com[2]) < 1e-10:
        gmsh.model.addPhysicalGroup(2, [tag], name="Port1")
    elif abs(com[2] - z_pos) < 1e-10:
        gmsh.model.addPhysicalGroup(2, [tag], name="Port2")

# 尺寸场：在虹膜位置细化
gmsh.model.mesh.field.add("Box", 1)
gmsh.model.mesh.field.setNumber(1, "VIn", mesh_fine)
gmsh.model.mesh.field.setNumber(1, "VOut", mesh_coarse)
gmsh.model.mesh.field.setNumber(1, "XMin", 0)
gmsh.model.mesh.field.setNumber(1, "XMax", a)
gmsh.model.mesh.field.setNumber(1, "YMin", 0)
gmsh.model.mesh.field.setNumber(1, "YMax", b)
gmsh.model.mesh.field.setNumber(1, "ZMin", input_length - 5e-3)
gmsh.model.mesh.field.setNumber(1, "ZMax", z_pos - output_length + 5e-3)
gmsh.model.mesh.field.setNumber(1, "Thickness", 5e-3)

gmsh.model.mesh.field.setAsBackgroundMesh(1)
gmsh.option.setNumber("Mesh.MeshSizeExtendFromBoundary", 0)
gmsh.option.setNumber("Mesh.MeshSizeFromPoints", 0)
gmsh.option.setNumber("Mesh.MeshSizeFromCurvature", 0)

# 生成网格
gmsh.model.mesh.generate(3)
gmsh.model.mesh.optimize("Netgen")

gmsh.write("iris_filter.msh")
gmsh.finalize()
print("波导滤波器网格生成完成")
```

## 圆波导

### 基础圆波导

```python
"""
圆波导网格生成
"""
import gmsh
import numpy as np

gmsh.initialize()
gmsh.model.add("circular_waveguide")

# 圆波导参数
radius = 10e-3  # 半径 10mm
length = 80e-3  # 长度 80mm

# 工作频率 (TE11模式截止频率约8.79 GHz，取10 GHz)
freq = 10e9
wavelength = 3e8 / freq
mesh_size = wavelength / 12

# 创建圆柱体
cylinder = gmsh.model.occ.addCylinder(0, 0, 0, 0, 0, length, radius)
gmsh.model.occ.synchronize()

# 物理组
surfaces = gmsh.model.getEntities(2)
for dim, tag in surfaces:
    com = gmsh.model.occ.getCenterOfMass(dim, tag)
    bbox = gmsh.model.occ.getBoundingBox(dim, tag)

    # 判断是端面还是侧面
    if abs(com[2]) < 1e-10:
        gmsh.model.addPhysicalGroup(2, [tag], name="Port_In")
    elif abs(com[2] - length) < 1e-10:
        gmsh.model.addPhysicalGroup(2, [tag], name="Port_Out")
    else:
        gmsh.model.addPhysicalGroup(2, [tag], name="PEC_Wall")

gmsh.model.addPhysicalGroup(3, [cylinder], name="Air")

# 边界层：在壁面附近细化（捕捉趋肤效应）
gmsh.model.mesh.field.add("Distance", 1)
# 找到侧面
wall_curves = []
curves = gmsh.model.getEntities(1)
for dim, tag in curves:
    com = gmsh.model.occ.getCenterOfMass(dim, tag)
    # 圆弧在端面上
    if abs(com[2]) < 1e-10 or abs(com[2] - length) < 1e-10:
        wall_curves.append(tag)

gmsh.model.mesh.field.setNumbers(1, "CurvesList", wall_curves)
gmsh.model.mesh.field.setNumber(1, "Sampling", 100)

gmsh.model.mesh.field.add("Threshold", 2)
gmsh.model.mesh.field.setNumber(2, "InField", 1)
gmsh.model.mesh.field.setNumber(2, "SizeMin", mesh_size / 3)
gmsh.model.mesh.field.setNumber(2, "SizeMax", mesh_size)
gmsh.model.mesh.field.setNumber(2, "DistMin", 0)
gmsh.model.mesh.field.setNumber(2, "DistMax", radius / 3)

gmsh.model.mesh.field.setAsBackgroundMesh(2)

# 网格生成
gmsh.model.mesh.generate(3)
gmsh.model.mesh.optimize("Netgen")

gmsh.write("circular_waveguide.msh")
gmsh.finalize()
```

### 圆-矩过渡波导

```python
"""
圆波导到矩形波导的过渡结构
"""
import gmsh
import numpy as np

gmsh.initialize()
gmsh.model.add("circular_rectangular_transition")

# 参数
rect_a = 22.86e-3  # 矩形波导宽
rect_b = 10.16e-3  # 矩形波导高
circ_r = 12e-3     # 圆波导半径

rect_length = 30e-3
transition_length = 40e-3
circ_length = 30e-3

# 网格尺寸
mesh_size = 2e-3

# 创建矩形波导截面
rect_section = gmsh.model.occ.addRectangle(-rect_a/2, -rect_b/2, 0, rect_a, rect_b)

# 创建圆形截面
total_length = rect_length + transition_length + circ_length
circ_section = gmsh.model.occ.addDisk(0, 0, total_length, circ_r, circ_r)

# 拉伸矩形波导
rect_wg = gmsh.model.occ.extrude([(2, rect_section)], 0, 0, rect_length)

# 过渡段：使用ThruSections
# 在过渡段起点创建矩形
z1 = rect_length
rect_trans = gmsh.model.occ.addRectangle(-rect_a/2, -rect_b/2, z1, rect_a, rect_b)

# 在过渡段中间创建椭圆（过渡形状）
z2 = rect_length + transition_length/2
# 创建椭圆
ellipse_rx = (rect_a/2 + circ_r) / 2
ellipse_ry = (rect_b/2 + circ_r) / 2
ellipse = gmsh.model.occ.addEllipse(0, 0, z2, ellipse_rx, ellipse_ry)
ellipse_loop = gmsh.model.occ.addCurveLoop([ellipse])
ellipse_surf = gmsh.model.occ.addPlaneSurface([ellipse_loop])

# 在过渡段终点创建圆
z3 = rect_length + transition_length
circ_trans = gmsh.model.occ.addDisk(0, 0, z3, circ_r, circ_r)

# 使用ThruSections创建过渡段
# 获取边界线
gmsh.model.occ.synchronize()
rect_trans_wire = gmsh.model.occ.addWire(gmsh.model.getBoundary([(2, rect_trans)], oriented=False))

# 重新创建截面为wire
gmsh.model.occ.remove([(2, rect_trans), (2, ellipse_surf), (2, circ_trans)])

# 简化：使用loft
# 创建矩形线框
p1 = gmsh.model.occ.addPoint(-rect_a/2, -rect_b/2, z1)
p2 = gmsh.model.occ.addPoint(rect_a/2, -rect_b/2, z1)
p3 = gmsh.model.occ.addPoint(rect_a/2, rect_b/2, z1)
p4 = gmsh.model.occ.addPoint(-rect_a/2, rect_b/2, z1)
l1 = gmsh.model.occ.addLine(p1, p2)
l2 = gmsh.model.occ.addLine(p2, p3)
l3 = gmsh.model.occ.addLine(p3, p4)
l4 = gmsh.model.occ.addLine(p4, p1)
rect_wire = gmsh.model.occ.addWire([l1, l2, l3, l4])

# 创建圆形线框
circ_curve = gmsh.model.occ.addCircle(0, 0, z3, circ_r)
circ_wire = gmsh.model.occ.addWire([circ_curve])

# 创建过渡体
transition = gmsh.model.occ.addThruSections([rect_wire, circ_wire], makeSolid=True, makeRuled=True)

# 拉伸圆波导
circ_disk = gmsh.model.occ.addDisk(0, 0, z3, circ_r, circ_r)
circ_wg = gmsh.model.occ.extrude([(2, circ_disk)], 0, 0, circ_length)

gmsh.model.occ.synchronize()

# 融合所有体积
volumes = gmsh.model.getEntities(3)
if len(volumes) > 1:
    fused = gmsh.model.occ.fuse([volumes[0]], volumes[1:])
    gmsh.model.occ.synchronize()

# 物理组
volumes = gmsh.model.getEntities(3)
gmsh.model.addPhysicalGroup(3, [v[1] for v in volumes], name="Air")

# 设置网格尺寸
gmsh.model.mesh.setSize(gmsh.model.getEntities(0), mesh_size)

# 过渡段细化
gmsh.model.mesh.field.add("Box", 1)
gmsh.model.mesh.field.setNumber(1, "VIn", mesh_size / 2)
gmsh.model.mesh.field.setNumber(1, "VOut", mesh_size)
gmsh.model.mesh.field.setNumber(1, "XMin", -rect_a)
gmsh.model.mesh.field.setNumber(1, "XMax", rect_a)
gmsh.model.mesh.field.setNumber(1, "YMin", -rect_a)
gmsh.model.mesh.field.setNumber(1, "YMax", rect_a)
gmsh.model.mesh.field.setNumber(1, "ZMin", z1 - 5e-3)
gmsh.model.mesh.field.setNumber(1, "ZMax", z3 + 5e-3)

gmsh.model.mesh.field.setAsBackgroundMesh(1)

# 生成网格
gmsh.model.mesh.generate(3)

gmsh.write("circular_rectangular_transition.msh")
gmsh.finalize()
print("圆-矩过渡波导网格生成完成")
```

## 同轴线

### 同轴传输线

```python
"""
同轴传输线网格
"""
import gmsh
import numpy as np

gmsh.initialize()
gmsh.model.add("coaxial_line")

# 50Ω同轴线参数（类似RG-58）
inner_radius = 0.5e-3    # 内导体半径
outer_radius = 1.67e-3   # 外导体内半径（介质外径）
shield_radius = 1.8e-3   # 外导体外半径（屏蔽层）
length = 20e-3           # 长度

# 介质参数
epsilon_r = 2.3  # 聚乙烯

# 网格参数
freq = 5e9
wavelength_medium = 3e8 / (freq * np.sqrt(epsilon_r))
mesh_size = wavelength_medium / 15

# 创建截面
# 内导体
inner_disk = gmsh.model.occ.addDisk(0, 0, 0, inner_radius, inner_radius)
# 介质环
dielectric_disk = gmsh.model.occ.addDisk(0, 0, 0, outer_radius, outer_radius)
dielectric_ring = gmsh.model.occ.cut([(2, dielectric_disk)], [(2, inner_disk)], removeObject=True, removeTool=False)
gmsh.model.occ.synchronize()

# 获取介质环的tag
dielectric_surfs = gmsh.model.getEntities(2)
dielectric_tag = None
for dim, tag in dielectric_surfs:
    if tag != inner_disk:
        dielectric_tag = tag
        break

# 拉伸创建3D
inner_vol = gmsh.model.occ.extrude([(2, inner_disk)], 0, 0, length)
dielectric_vol = gmsh.model.occ.extrude([(2, dielectric_tag)], 0, 0, length)

gmsh.model.occ.synchronize()

# 获取体积
volumes = gmsh.model.getEntities(3)

# 根据位置区分
inner_conductor = None
dielectric = None
for dim, tag in volumes:
    com = gmsh.model.occ.getCenterOfMass(dim, tag)
    r = np.sqrt(com[0]**2 + com[1]**2)
    if r < inner_radius:
        inner_conductor = tag
    else:
        dielectric = tag

# 物理组
if inner_conductor:
    gmsh.model.addPhysicalGroup(3, [inner_conductor], name="Inner_Conductor")
if dielectric:
    gmsh.model.addPhysicalGroup(3, [dielectric], name="Dielectric")

# 定义端口和边界
surfaces = gmsh.model.getEntities(2)
port1 = []
port2 = []

for dim, tag in surfaces:
    com = gmsh.model.occ.getCenterOfMass(dim, tag)
    if abs(com[2]) < 1e-10:
        port1.append(tag)
    elif abs(com[2] - length) < 1e-10:
        port2.append(tag)

if port1:
    gmsh.model.addPhysicalGroup(2, port1, name="Port1")
if port2:
    gmsh.model.addPhysicalGroup(2, port2, name="Port2")

# 在介质-导体界面细化
gmsh.model.mesh.field.add("Distance", 1)
inner_curves = []
curves = gmsh.model.getEntities(1)
for dim, tag in curves:
    # 获取曲线上的点
    bounds = gmsh.model.getParametrizationBounds(dim, tag)
    point = gmsh.model.getValue(dim, tag, [(bounds[0] + bounds[1])/2])
    r = np.sqrt(point[0]**2 + point[1]**2)
    if abs(r - inner_radius) < 1e-6:
        inner_curves.append(tag)

if inner_curves:
    gmsh.model.mesh.field.setNumbers(1, "CurvesList", inner_curves)
    gmsh.model.mesh.field.setNumber(1, "Sampling", 50)

    gmsh.model.mesh.field.add("Threshold", 2)
    gmsh.model.mesh.field.setNumber(2, "InField", 1)
    gmsh.model.mesh.field.setNumber(2, "SizeMin", mesh_size / 3)
    gmsh.model.mesh.field.setNumber(2, "SizeMax", mesh_size)
    gmsh.model.mesh.field.setNumber(2, "DistMin", 0)
    gmsh.model.mesh.field.setNumber(2, "DistMax", (outer_radius - inner_radius) / 3)

    gmsh.model.mesh.field.setAsBackgroundMesh(2)

# 生成网格
gmsh.model.mesh.setSize(gmsh.model.getEntities(0), mesh_size)
gmsh.model.mesh.generate(3)
gmsh.model.mesh.optimize("Netgen")

gmsh.write("coaxial_line.msh")
gmsh.finalize()
print("同轴线网格生成完成")
```

### 同轴-波导转换器

```python
"""
同轴到波导转换器（探针耦合）
"""
import gmsh
import numpy as np

gmsh.initialize()
gmsh.model.add("coax_waveguide_adapter")

# WR-90波导参数
wg_a = 22.86e-3
wg_b = 10.16e-3
wg_length = 40e-3

# 同轴探针参数
coax_inner_r = 0.635e-3   # 内导体半径
coax_outer_r = 2.05e-3    # 外导体半径
probe_length = 7e-3       # 探针伸入长度
probe_position = wg_a / 4 # 探针位置（距短路端λg/4）

# 网格参数
mesh_coarse = 2e-3
mesh_fine = 0.5e-3

# 创建波导主体
waveguide = gmsh.model.occ.addBox(0, 0, 0, wg_a, wg_b, wg_length)

# 在波导顶面创建同轴孔
# 孔的位置
hole_x = probe_position
hole_z = wg_length / 2

# 同轴孔（圆柱形）
coax_hole = gmsh.model.occ.addCylinder(hole_x, wg_b, hole_z, 0, 5e-3, 0, coax_outer_r)

# 从波导中减去同轴孔
cut_result = gmsh.model.occ.cut([(3, waveguide)], [(3, coax_hole)])
gmsh.model.occ.synchronize()

# 创建探针（内导体）
probe = gmsh.model.occ.addCylinder(hole_x, wg_b - probe_length, hole_z, 0, probe_length + 5e-3, 0, coax_inner_r)
gmsh.model.occ.synchronize()

# 物理组
volumes = gmsh.model.getEntities(3)
for dim, tag in volumes:
    bbox = gmsh.model.occ.getBoundingBox(dim, tag)
    # 根据尺寸判断是波导还是探针
    size_x = bbox[3] - bbox[0]
    if size_x > wg_a / 2:  # 波导
        gmsh.model.addPhysicalGroup(3, [tag], name="Waveguide_Air")
    else:  # 探针
        gmsh.model.addPhysicalGroup(3, [tag], name="Probe")

# 端口定义
surfaces = gmsh.model.getEntities(2)
for dim, tag in surfaces:
    bbox = gmsh.model.occ.getBoundingBox(dim, tag)
    com = gmsh.model.occ.getCenterOfMass(dim, tag)

    # 波导端口
    if abs(bbox[2] - 0) < 1e-10 and abs(bbox[5] - 0) < 1e-10:  # z=0平面
        size_x = bbox[3] - bbox[0]
        if size_x > wg_a / 2:
            gmsh.model.addPhysicalGroup(2, [tag], name="WG_Port")

    # 同轴端口（顶部）
    if abs(com[1] - (wg_b + 5e-3)) < 1e-3:
        gmsh.model.addPhysicalGroup(2, [tag], name="Coax_Port")

# 尺寸场：探针周围细化
gmsh.model.mesh.field.add("Cylinder", 1)
gmsh.model.mesh.field.setNumber(1, "VIn", mesh_fine)
gmsh.model.mesh.field.setNumber(1, "VOut", mesh_coarse)
gmsh.model.mesh.field.setNumber(1, "XCenter", hole_x)
gmsh.model.mesh.field.setNumber(1, "YCenter", wg_b / 2)
gmsh.model.mesh.field.setNumber(1, "ZCenter", hole_z)
gmsh.model.mesh.field.setNumber(1, "XAxis", 0)
gmsh.model.mesh.field.setNumber(1, "YAxis", 1)
gmsh.model.mesh.field.setNumber(1, "ZAxis", 0)
gmsh.model.mesh.field.setNumber(1, "Radius", coax_outer_r * 3)

gmsh.model.mesh.field.setAsBackgroundMesh(1)

# 生成网格
gmsh.model.mesh.generate(3)

gmsh.write("coax_waveguide_adapter.msh")
gmsh.finalize()
print("同轴-波导转换器网格生成完成")
```

## 微带线

### 基础微带线

```python
"""
微带传输线网格
"""
import gmsh
import numpy as np

gmsh.initialize()
gmsh.model.add("microstrip_line")

# 微带线参数
substrate_width = 10e-3   # 基板宽度
substrate_length = 30e-3  # 基板长度
substrate_height = 1.6e-3 # 基板厚度（FR4标准）

strip_width = 3e-3        # 微带宽度（约50Ω）
strip_thickness = 35e-6   # 铜厚度（1 oz铜）

# 空气盒子
air_height = 10e-3        # 空气区域高度

# 介质参数
epsilon_r = 4.4  # FR4

# 网格参数
freq = 5e9
wavelength = 3e8 / (freq * np.sqrt((epsilon_r + 1) / 2))  # 有效介电常数近似
mesh_substrate = wavelength / 10
mesh_strip = strip_width / 5  # 微带边缘细化
mesh_air = wavelength / 8

# 创建基板
substrate = gmsh.model.occ.addBox(
    -substrate_width/2, 0, 0,
    substrate_width, substrate_height, substrate_length
)

# 创建微带
strip = gmsh.model.occ.addBox(
    -strip_width/2, substrate_height, 0,
    strip_width, strip_thickness, substrate_length
)

# 创建空气区域
air_box = gmsh.model.occ.addBox(
    -substrate_width/2, substrate_height, 0,
    substrate_width, air_height, substrate_length
)

# 布尔运算：从空气中减去微带
air_cut = gmsh.model.occ.cut([(3, air_box)], [(3, strip)], removeObject=True, removeTool=False)
gmsh.model.occ.synchronize()

# 物理组
volumes = gmsh.model.getEntities(3)
for dim, tag in volumes:
    bbox = gmsh.model.occ.getBoundingBox(dim, tag)

    if bbox[4] < substrate_height + 1e-6:  # 基板
        gmsh.model.addPhysicalGroup(3, [tag], name="Substrate")
    elif (bbox[3] - bbox[0]) < strip_width * 2:  # 微带
        gmsh.model.addPhysicalGroup(3, [tag], name="Strip")
    else:  # 空气
        gmsh.model.addPhysicalGroup(3, [tag], name="Air")

# 接地面（y=0）
surfaces = gmsh.model.getEntities(2)
ground_surfaces = []
port1_surfaces = []
port2_surfaces = []

for dim, tag in surfaces:
    bbox = gmsh.model.occ.getBoundingBox(dim, tag)
    com = gmsh.model.occ.getCenterOfMass(dim, tag)

    if abs(bbox[1]) < 1e-10 and abs(bbox[4]) < 1e-10:  # y=0面
        ground_surfaces.append(tag)
    elif abs(bbox[2]) < 1e-10 and abs(bbox[5]) < 1e-10:  # z=0面
        port1_surfaces.append(tag)
    elif abs(bbox[2] - substrate_length) < 1e-10:  # z=L面
        port2_surfaces.append(tag)

if ground_surfaces:
    gmsh.model.addPhysicalGroup(2, ground_surfaces, name="Ground")
if port1_surfaces:
    gmsh.model.addPhysicalGroup(2, port1_surfaces, name="Port1")
if port2_surfaces:
    gmsh.model.addPhysicalGroup(2, port2_surfaces, name="Port2")

# 尺寸场：微带边缘细化
gmsh.model.mesh.field.add("Box", 1)
gmsh.model.mesh.field.setNumber(1, "VIn", mesh_strip)
gmsh.model.mesh.field.setNumber(1, "VOut", mesh_substrate)
gmsh.model.mesh.field.setNumber(1, "XMin", -strip_width)
gmsh.model.mesh.field.setNumber(1, "XMax", strip_width)
gmsh.model.mesh.field.setNumber(1, "YMin", substrate_height - substrate_height/4)
gmsh.model.mesh.field.setNumber(1, "YMax", substrate_height + strip_thickness + 1e-3)
gmsh.model.mesh.field.setNumber(1, "ZMin", -1e-3)
gmsh.model.mesh.field.setNumber(1, "ZMax", substrate_length + 1e-3)
gmsh.model.mesh.field.setNumber(1, "Thickness", strip_width)

# 基板内部
gmsh.model.mesh.field.add("Box", 2)
gmsh.model.mesh.field.setNumber(2, "VIn", mesh_substrate)
gmsh.model.mesh.field.setNumber(2, "VOut", mesh_air)
gmsh.model.mesh.field.setNumber(2, "XMin", -substrate_width/2)
gmsh.model.mesh.field.setNumber(2, "XMax", substrate_width/2)
gmsh.model.mesh.field.setNumber(2, "YMin", 0)
gmsh.model.mesh.field.setNumber(2, "YMax", substrate_height)
gmsh.model.mesh.field.setNumber(2, "ZMin", 0)
gmsh.model.mesh.field.setNumber(2, "ZMax", substrate_length)

gmsh.model.mesh.field.add("Min", 3)
gmsh.model.mesh.field.setNumbers(3, "FieldsList", [1, 2])
gmsh.model.mesh.field.setAsBackgroundMesh(3)

# 生成网格
gmsh.model.mesh.generate(3)
gmsh.model.mesh.optimize("Netgen")

# 统计
print("微带线网格统计:")
for dim, tag in gmsh.model.getEntities(3):
    name = gmsh.model.getPhysicalName(3, tag) if tag in [p[1] for p in gmsh.model.getPhysicalGroups(3)] else f"Volume_{tag}"
    elem_types, elem_tags, _ = gmsh.model.mesh.getElements(3, tag)
    if elem_tags:
        print(f"  {name}: {len(elem_tags[0])} 四面体")

gmsh.write("microstrip_line.msh")
gmsh.finalize()
```

### 微带贴片天线

```python
"""
矩形微带贴片天线
"""
import gmsh
import numpy as np

gmsh.initialize()
gmsh.model.add("patch_antenna")

# 天线参数
# 设计频率：2.4 GHz (WiFi)
freq = 2.4e9
c = 3e8
epsilon_r = 4.4  # FR4

# 贴片尺寸计算
# 有效介电常数
epsilon_eff = (epsilon_r + 1) / 2 + (epsilon_r - 1) / 2 * (1 + 12 * 1.6e-3 / 30e-3)**(-0.5)
wavelength_eff = c / (freq * np.sqrt(epsilon_eff))

patch_width = 38e-3   # 贴片宽度
patch_length = 29e-3  # 贴片长度
patch_thickness = 35e-6

# 基板
substrate_width = 60e-3
substrate_length = 50e-3
substrate_height = 1.6e-3

# 馈电点（从边缘偏移）
feed_offset = 9e-3  # 从贴片中心的偏移

# 空气盒子（辐射边界）
air_margin = wavelength_eff / 4
air_height = wavelength_eff / 4

# 网格参数
mesh_patch = 1.5e-3
mesh_substrate = 3e-3
mesh_air = wavelength_eff / 8

# 创建基板
substrate = gmsh.model.occ.addBox(
    -substrate_width/2, 0, -substrate_length/2,
    substrate_width, substrate_height, substrate_length
)

# 创建贴片
patch = gmsh.model.occ.addBox(
    -patch_width/2, substrate_height, -patch_length/2,
    patch_width, patch_thickness, patch_length
)

# 创建馈电探针孔
probe_radius = 0.5e-3
probe = gmsh.model.occ.addCylinder(
    feed_offset, 0, 0,
    0, substrate_height + patch_thickness, 0,
    probe_radius
)

# 创建空气盒子
air_box = gmsh.model.occ.addBox(
    -substrate_width/2 - air_margin, 0, -substrate_length/2 - air_margin,
    substrate_width + 2*air_margin, air_height, substrate_length + 2*air_margin
)

# 布尔运算
# 基板中打探针孔
substrate_with_hole = gmsh.model.occ.cut([(3, substrate)], [(3, probe)], removeObject=True, removeTool=False)
gmsh.model.occ.synchronize()

# 更新substrate标签
volumes = gmsh.model.getEntities(3)
for dim, tag in volumes:
    bbox = gmsh.model.occ.getBoundingBox(dim, tag)
    if bbox[4] < substrate_height + patch_thickness:
        substrate = tag
        break

# 空气中减去基板和贴片
# 先获取当前所有体积
gmsh.model.occ.synchronize()
volumes = gmsh.model.getEntities(3)

# 找出空气盒子
air_tag = None
for dim, tag in volumes:
    bbox = gmsh.model.occ.getBoundingBox(dim, tag)
    if bbox[4] > air_height / 2:
        air_tag = tag
        break

if air_tag:
    other_volumes = [(3, v[1]) for v in volumes if v[1] != air_tag]
    if other_volumes:
        gmsh.model.occ.cut([(3, air_tag)], other_volumes, removeObject=True, removeTool=False)

gmsh.model.occ.synchronize()

# 分片以确保界面匹配
gmsh.model.occ.synchronize()
all_volumes = gmsh.model.getEntities(3)
if len(all_volumes) > 1:
    gmsh.model.occ.fragment(all_volumes, [])
    gmsh.model.occ.synchronize()

# 物理组
volumes = gmsh.model.getEntities(3)
for dim, tag in volumes:
    bbox = gmsh.model.occ.getBoundingBox(dim, tag)
    com = gmsh.model.occ.getCenterOfMass(dim, tag)

    height = bbox[4] - bbox[1]

    if height < substrate_height * 1.5 and height > substrate_height * 0.5:
        gmsh.model.addPhysicalGroup(3, [tag], name="Substrate")
    elif height < patch_thickness * 10:
        gmsh.model.addPhysicalGroup(3, [tag], name="Patch")
    else:
        gmsh.model.addPhysicalGroup(3, [tag], name="Air")

# 边界条件
surfaces = gmsh.model.getEntities(2)
ground = []
radiation_boundary = []

for dim, tag in surfaces:
    bbox = gmsh.model.occ.getBoundingBox(dim, tag)
    com = gmsh.model.occ.getCenterOfMass(dim, tag)

    # 接地面
    if abs(bbox[1]) < 1e-10 and abs(bbox[4]) < 1e-10:
        if abs(com[0]) < substrate_width/2 and abs(com[2]) < substrate_length/2:
            ground.append(tag)

    # 辐射边界（空气盒子的外表面）
    if (abs(bbox[0] - (-substrate_width/2 - air_margin)) < 1e-6 or
        abs(bbox[3] - (substrate_width/2 + air_margin)) < 1e-6 or
        abs(bbox[2] - (-substrate_length/2 - air_margin)) < 1e-6 or
        abs(bbox[5] - (substrate_length/2 + air_margin)) < 1e-6 or
        abs(bbox[4] - air_height) < 1e-6):
        radiation_boundary.append(tag)

if ground:
    gmsh.model.addPhysicalGroup(2, ground, name="Ground")
if radiation_boundary:
    gmsh.model.addPhysicalGroup(2, radiation_boundary, name="Radiation_Boundary")

# 尺寸场
# 贴片周围细化
gmsh.model.mesh.field.add("Box", 1)
gmsh.model.mesh.field.setNumber(1, "VIn", mesh_patch)
gmsh.model.mesh.field.setNumber(1, "VOut", mesh_air)
gmsh.model.mesh.field.setNumber(1, "XMin", -patch_width)
gmsh.model.mesh.field.setNumber(1, "XMax", patch_width)
gmsh.model.mesh.field.setNumber(1, "YMin", 0)
gmsh.model.mesh.field.setNumber(1, "YMax", substrate_height + 2e-3)
gmsh.model.mesh.field.setNumber(1, "ZMin", -patch_length)
gmsh.model.mesh.field.setNumber(1, "ZMax", patch_length)
gmsh.model.mesh.field.setNumber(1, "Thickness", 5e-3)

# 馈电点细化
gmsh.model.mesh.field.add("Cylinder", 2)
gmsh.model.mesh.field.setNumber(2, "VIn", mesh_patch / 2)
gmsh.model.mesh.field.setNumber(2, "VOut", mesh_patch)
gmsh.model.mesh.field.setNumber(2, "XCenter", feed_offset)
gmsh.model.mesh.field.setNumber(2, "YCenter", substrate_height / 2)
gmsh.model.mesh.field.setNumber(2, "ZCenter", 0)
gmsh.model.mesh.field.setNumber(2, "XAxis", 0)
gmsh.model.mesh.field.setNumber(2, "YAxis", 1)
gmsh.model.mesh.field.setNumber(2, "ZAxis", 0)
gmsh.model.mesh.field.setNumber(2, "Radius", 3e-3)

gmsh.model.mesh.field.add("Min", 3)
gmsh.model.mesh.field.setNumbers(3, "FieldsList", [1, 2])
gmsh.model.mesh.field.setAsBackgroundMesh(3)

# 生成网格
gmsh.model.mesh.generate(3)
gmsh.model.mesh.optimize("Netgen")

gmsh.write("patch_antenna.msh")
gmsh.finalize()
print("微带贴片天线网格生成完成")
```

## 周期波导结构

### 波纹波导

```python
"""
周期波纹波导（慢波结构）
"""
import gmsh
import numpy as np

gmsh.initialize()
gmsh.model.add("corrugated_waveguide")

# 波导参数
inner_radius = 5e-3    # 内半径
outer_radius = 8e-3    # 波纹槽深
period = 4e-3          # 周期长度
slot_width = 2e-3      # 槽宽
num_periods = 10       # 周期数

# 网格参数
mesh_size = 0.5e-3

# 构建一个周期
def create_period(z_start, period_idx):
    """创建单个周期的几何"""
    volumes = []

    # 平滑段
    smooth_length = period - slot_width
    if smooth_length > 0:
        smooth = gmsh.model.occ.addCylinder(
            0, 0, z_start, 0, 0, smooth_length, inner_radius
        )
        volumes.append(smooth)

    # 波纹槽
    slot_z = z_start + smooth_length
    slot = gmsh.model.occ.addCylinder(
        0, 0, slot_z, 0, 0, slot_width, outer_radius
    )
    volumes.append(slot)

    return volumes

# 创建所有周期
all_volumes = []
for i in range(num_periods):
    z_start = i * period
    vols = create_period(z_start, i)
    all_volumes.extend(vols)

# 融合所有体积
gmsh.model.occ.synchronize()
if len(all_volumes) > 1:
    fused = gmsh.model.occ.fuse([(3, all_volumes[0])], [(3, v) for v in all_volumes[1:]])

gmsh.model.occ.synchronize()

# 物理组
volumes = gmsh.model.getEntities(3)
gmsh.model.addPhysicalGroup(3, [v[1] for v in volumes], name="Vacuum")

# 端口
total_length = num_periods * period
surfaces = gmsh.model.getEntities(2)
for dim, tag in surfaces:
    com = gmsh.model.occ.getCenterOfMass(dim, tag)
    if abs(com[2]) < 1e-10:
        gmsh.model.addPhysicalGroup(2, [tag], name="Port_In")
    elif abs(com[2] - total_length) < 1e-10:
        gmsh.model.addPhysicalGroup(2, [tag], name="Port_Out")

# 网格
gmsh.model.mesh.setSize(gmsh.model.getEntities(0), mesh_size)
gmsh.model.mesh.generate(3)

gmsh.write("corrugated_waveguide.msh")
gmsh.finalize()
print("波纹波导网格生成完成")
```

## 完整案例：带状线滤波器

```python
"""
多层带状线滤波器（完整案例）
"""
import gmsh
import numpy as np

class StriplineFilter:
    """带状线滤波器网格生成器"""

    def __init__(self):
        self.substrate_width = 20e-3
        self.substrate_height = 0.8e-3
        self.strip_width = 1.5e-3
        self.strip_thickness = 35e-6
        self.epsilon_r = 4.4

    def create_filter(self, filter_length, num_stages):
        """
        创建滤波器几何

        参数:
            filter_length: 滤波器总长度
            num_stages: 级数
        """
        gmsh.initialize()
        gmsh.model.add("stripline_filter")

        # 计算每级长度
        stage_length = filter_length / num_stages

        # 下层基板
        lower_substrate = gmsh.model.occ.addBox(
            -self.substrate_width/2, 0, 0,
            self.substrate_width, self.substrate_height, filter_length
        )

        # 上层基板
        upper_substrate = gmsh.model.occ.addBox(
            -self.substrate_width/2, self.substrate_height + self.strip_thickness, 0,
            self.substrate_width, self.substrate_height, filter_length
        )

        # 创建带状线（交替耦合结构）
        strips = []
        for i in range(num_stages):
            z_start = i * stage_length
            # 交替偏移
            x_offset = (self.strip_width * 0.6) * (1 if i % 2 == 0 else -1)

            strip = gmsh.model.occ.addBox(
                -self.strip_width/2 + x_offset,
                self.substrate_height,
                z_start + stage_length * 0.1,
                self.strip_width,
                self.strip_thickness,
                stage_length * 0.8
            )
            strips.append(strip)

        gmsh.model.occ.synchronize()

        # 物理组
        gmsh.model.addPhysicalGroup(3, [lower_substrate], name="Lower_Substrate")
        gmsh.model.addPhysicalGroup(3, [upper_substrate], name="Upper_Substrate")
        gmsh.model.addPhysicalGroup(3, strips, name="Strips")

        # 接地面
        surfaces = gmsh.model.getEntities(2)
        bottom_ground = []
        top_ground = []

        for dim, tag in surfaces:
            bbox = gmsh.model.occ.getBoundingBox(dim, tag)
            if abs(bbox[1]) < 1e-10 and abs(bbox[4]) < 1e-10:
                bottom_ground.append(tag)
            elif abs(bbox[1] - (2*self.substrate_height + self.strip_thickness)) < 1e-6:
                top_ground.append(tag)

        if bottom_ground:
            gmsh.model.addPhysicalGroup(2, bottom_ground, name="Bottom_Ground")
        if top_ground:
            gmsh.model.addPhysicalGroup(2, top_ground, name="Top_Ground")

        return filter_length

    def setup_mesh(self, filter_length):
        """设置网格参数"""
        # 计算网格尺寸
        freq = 5e9
        wavelength = 3e8 / (freq * np.sqrt(self.epsilon_r))

        mesh_fine = self.strip_width / 4
        mesh_coarse = wavelength / 10

        # 带状线区域细化
        gmsh.model.mesh.field.add("Box", 1)
        gmsh.model.mesh.field.setNumber(1, "VIn", mesh_fine)
        gmsh.model.mesh.field.setNumber(1, "VOut", mesh_coarse)
        gmsh.model.mesh.field.setNumber(1, "XMin", -self.strip_width * 2)
        gmsh.model.mesh.field.setNumber(1, "XMax", self.strip_width * 2)
        gmsh.model.mesh.field.setNumber(1, "YMin", self.substrate_height - self.substrate_height/4)
        gmsh.model.mesh.field.setNumber(1, "YMax", self.substrate_height + self.strip_thickness + self.substrate_height/4)
        gmsh.model.mesh.field.setNumber(1, "ZMin", 0)
        gmsh.model.mesh.field.setNumber(1, "ZMax", filter_length)
        gmsh.model.mesh.field.setNumber(1, "Thickness", self.strip_width)

        gmsh.model.mesh.field.setAsBackgroundMesh(1)

    def generate_mesh(self, order=1):
        """生成网格"""
        gmsh.model.mesh.generate(3)

        if order > 1:
            gmsh.model.mesh.setOrder(order)

        gmsh.model.mesh.optimize("Netgen")

    def export(self, filename):
        """导出网格"""
        gmsh.write(filename)

        # 统计
        _, nodes, _ = gmsh.model.mesh.getNodes()
        elem_types, elem_tags, _ = gmsh.model.mesh.getElements(3)

        print(f"带状线滤波器网格统计:")
        print(f"  节点数: {len(nodes)}")
        print(f"  四面体数: {sum(len(t) for t in elem_tags)}")

    def finalize(self):
        """清理"""
        gmsh.finalize()


# 使用示例
if __name__ == "__main__":
    filter_gen = StriplineFilter()

    # 创建3级滤波器
    length = filter_gen.create_filter(
        filter_length=15e-3,
        num_stages=3
    )

    # 设置网格
    filter_gen.setup_mesh(length)

    # 生成网格
    filter_gen.generate_mesh(order=1)

    # 导出
    filter_gen.export("stripline_filter.msh")
    filter_gen.finalize()
```

## 网格质量检查与电磁仿真准备

```python
"""
电磁网格质量检查工具
"""
import gmsh
import numpy as np

def check_em_mesh_quality(msh_file, frequency):
    """
    检查电磁仿真网格质量

    参数:
        msh_file: 网格文件
        frequency: 工作频率 (Hz)
    """
    gmsh.initialize()
    gmsh.open(msh_file)

    c = 3e8
    wavelength = c / frequency

    print(f"电磁网格质量检查")
    print(f"=" * 50)
    print(f"工作频率: {frequency/1e9:.2f} GHz")
    print(f"自由空间波长: {wavelength*1e3:.2f} mm")
    print(f"推荐最大网格尺寸: {wavelength/10*1e3:.2f} mm")
    print()

    # 获取所有四面体
    elem_types, elem_tags, elem_nodes = gmsh.model.mesh.getElements(3)
    _, node_coords, _ = gmsh.model.mesh.getNodes()
    node_coords = node_coords.reshape(-1, 3)

    if not elem_tags:
        print("未找到3D单元")
        gmsh.finalize()
        return

    # 计算单元尺寸
    tet_nodes = elem_nodes[0].reshape(-1, 4) - 1  # 0-indexed

    max_edge_lengths = []
    for tet in tet_nodes:
        coords = node_coords[tet]
        # 计算6条边长
        edges = [
            np.linalg.norm(coords[0] - coords[1]),
            np.linalg.norm(coords[0] - coords[2]),
            np.linalg.norm(coords[0] - coords[3]),
            np.linalg.norm(coords[1] - coords[2]),
            np.linalg.norm(coords[1] - coords[3]),
            np.linalg.norm(coords[2] - coords[3])
        ]
        max_edge_lengths.append(max(edges))

    max_edge_lengths = np.array(max_edge_lengths)

    print(f"网格统计:")
    print(f"  四面体数量: {len(max_edge_lengths)}")
    print(f"  最大边长: {max_edge_lengths.max()*1e3:.3f} mm")
    print(f"  最小边长: {max_edge_lengths.min()*1e3:.3f} mm")
    print(f"  平均边长: {max_edge_lengths.mean()*1e3:.3f} mm")
    print()

    # 检查每波长单元数
    elements_per_wavelength = wavelength / max_edge_lengths.mean()
    oversized_elements = np.sum(max_edge_lengths > wavelength / 10)
    oversized_ratio = oversized_elements / len(max_edge_lengths) * 100

    print(f"每波长单元数: {elements_per_wavelength:.1f}")
    print(f"超尺寸单元 (>λ/10): {oversized_elements} ({oversized_ratio:.1f}%)")

    # 质量评估
    if elements_per_wavelength >= 10:
        print(f"\n✓ 网格密度满足要求 (≥10/λ)")
    else:
        print(f"\n✗ 网格密度不足，建议细化")

    if oversized_ratio < 5:
        print(f"✓ 超尺寸单元比例可接受 (<5%)")
    else:
        print(f"✗ 超尺寸单元过多，建议局部细化")

    gmsh.finalize()


# 检查示例
if __name__ == "__main__":
    # 假设已生成网格文件
    # check_em_mesh_quality("rectangular_waveguide.msh", 10e9)
    pass
```

## 小结

本节介绍了电磁波导结构的网格生成技术：

1. **网格密度准则**：每波长10-20个单元
2. **矩形波导**：基础结构和虹膜滤波器
3. **圆波导**：基础结构和圆-矩过渡
4. **同轴线**：传输线和波导转换器
5. **微带线**：传输线和贴片天线
6. **周期结构**：波纹波导和慢波结构

关键技术要点：
- 根据工作频率和介质参数计算网格尺寸
- 在导体边缘和介质界面处局部细化
- 正确定义物理组用于边界条件
- 多介质区域使用fragment确保界面一致
