# 带孔平面网格

本案例演示如何处理带有孔洞的2D平面网格。

## 案例目标

- 创建带单孔和多孔的平面
- 在孔边缘进行网格加密
- 正确设置物理组
- 应用于应力集中分析

## 单孔矩形板

```python
#!/usr/bin/env python3
"""
案例2: 带单孔的矩形板
"""
import gmsh
import sys

def create_plate_with_hole():
    """创建带孔的矩形板"""
    gmsh.initialize(sys.argv)
    gmsh.model.add("plate_with_hole")

    # 几何参数
    Lx = 4.0      # 板长
    Ly = 2.0      # 板宽
    r = 0.3       # 孔半径
    cx, cy = Lx/2, Ly/2  # 孔中心

    # 创建外轮廓
    plate = gmsh.model.occ.addRectangle(0, 0, 0, Lx, Ly)

    # 创建圆孔
    hole = gmsh.model.occ.addDisk(cx, cy, 0, r, r)

    # 布尔差集
    result, _ = gmsh.model.occ.cut([(2, plate)], [(2, hole)])

    gmsh.model.occ.synchronize()

    # 获取结果实体
    surface_tag = result[0][1]

    # 识别边界
    boundary = gmsh.model.getBoundary([(2, surface_tag)], oriented=False)

    left, right, top, bottom, hole_boundary = [], [], [], [], []

    for dim, tag in boundary:
        com = gmsh.model.occ.getCenterOfMass(dim, tag)
        x, y = com[0], com[1]

        # 判断曲线位置
        if abs(x) < 1e-6:
            left.append(tag)
        elif abs(x - Lx) < 1e-6:
            right.append(tag)
        elif abs(y) < 1e-6:
            bottom.append(tag)
        elif abs(y - Ly) < 1e-6:
            top.append(tag)
        else:
            # 孔边界
            hole_boundary.append(tag)

    # 定义物理组
    if left:
        gmsh.model.addPhysicalGroup(1, left, name="Left")
    if right:
        gmsh.model.addPhysicalGroup(1, right, name="Right")
    if top:
        gmsh.model.addPhysicalGroup(1, top, name="Top")
    if bottom:
        gmsh.model.addPhysicalGroup(1, bottom, name="Bottom")
    if hole_boundary:
        gmsh.model.addPhysicalGroup(1, hole_boundary, name="Hole")

    gmsh.model.addPhysicalGroup(2, [surface_tag], name="Plate")

    # 在孔边缘加密网格
    dist = gmsh.model.mesh.field.add("Distance")
    gmsh.model.mesh.field.setNumbers(dist, "CurvesList", hole_boundary)

    thresh = gmsh.model.mesh.field.add("Threshold")
    gmsh.model.mesh.field.setNumber(thresh, "InField", dist)
    gmsh.model.mesh.field.setNumber(thresh, "SizeMin", 0.02)
    gmsh.model.mesh.field.setNumber(thresh, "SizeMax", 0.15)
    gmsh.model.mesh.field.setNumber(thresh, "DistMin", 0.05)
    gmsh.model.mesh.field.setNumber(thresh, "DistMax", 0.5)

    gmsh.model.mesh.field.setAsBackgroundMesh(thresh)

    gmsh.option.setNumber("Mesh.MeshSizeExtendFromBoundary", 0)
    gmsh.option.setNumber("Mesh.MeshSizeFromPoints", 0)
    gmsh.option.setNumber("Mesh.MeshSizeFromCurvature", 0)

    # 生成网格
    gmsh.model.mesh.generate(2)

    gmsh.write("plate_with_hole.msh")

    if "-nopopup" not in sys.argv:
        gmsh.fltk.run()

    gmsh.finalize()

if __name__ == "__main__":
    create_plate_with_hole()
```

## 多孔板

```python
#!/usr/bin/env python3
"""
案例2: 带多孔的矩形板
"""
import gmsh
import sys

def create_plate_with_multiple_holes():
    """创建多孔板"""
    gmsh.initialize(sys.argv)
    gmsh.model.add("multi_holes")

    # 几何参数
    Lx, Ly = 6.0, 3.0
    hole_radius = 0.25
    hole_positions = [
        (1.0, 1.5),
        (2.5, 1.5),
        (4.0, 1.5),
        (5.0, 1.5),
        (1.75, 0.8),
        (3.25, 0.8),
        (4.5, 0.8),
        (1.75, 2.2),
        (3.25, 2.2),
        (4.5, 2.2),
    ]

    # 创建板
    plate = gmsh.model.occ.addRectangle(0, 0, 0, Lx, Ly)

    # 创建孔
    holes = []
    for cx, cy in hole_positions:
        hole = gmsh.model.occ.addDisk(cx, cy, 0, hole_radius, hole_radius)
        holes.append((2, hole))

    # 布尔差集
    result, _ = gmsh.model.occ.cut([(2, plate)], holes)

    gmsh.model.occ.synchronize()

    # 获取结果
    surface_tag = result[0][1]

    # 获取边界
    boundary = gmsh.model.getBoundary([(2, surface_tag)], oriented=False)

    outer_boundary = []
    hole_boundaries = []

    for dim, tag in boundary:
        com = gmsh.model.occ.getCenterOfMass(dim, tag)
        x, y = com[0], com[1]

        # 外边界判断
        if abs(x) < 1e-6 or abs(x - Lx) < 1e-6 or \
           abs(y) < 1e-6 or abs(y - Ly) < 1e-6:
            outer_boundary.append(tag)
        else:
            hole_boundaries.append(tag)

    # 物理组
    gmsh.model.addPhysicalGroup(1, outer_boundary, name="Outer")
    gmsh.model.addPhysicalGroup(1, hole_boundaries, name="Holes")
    gmsh.model.addPhysicalGroup(2, [surface_tag], name="Plate")

    # 孔边缘加密
    dist = gmsh.model.mesh.field.add("Distance")
    gmsh.model.mesh.field.setNumbers(dist, "CurvesList", hole_boundaries)

    thresh = gmsh.model.mesh.field.add("Threshold")
    gmsh.model.mesh.field.setNumber(thresh, "InField", dist)
    gmsh.model.mesh.field.setNumber(thresh, "SizeMin", 0.02)
    gmsh.model.mesh.field.setNumber(thresh, "SizeMax", 0.2)
    gmsh.model.mesh.field.setNumber(thresh, "DistMin", 0.05)
    gmsh.model.mesh.field.setNumber(thresh, "DistMax", 0.4)

    gmsh.model.mesh.field.setAsBackgroundMesh(thresh)

    gmsh.option.setNumber("Mesh.MeshSizeExtendFromBoundary", 0)
    gmsh.option.setNumber("Mesh.MeshSizeFromPoints", 0)

    gmsh.model.mesh.generate(2)
    gmsh.write("multi_holes.msh")

    if "-nopopup" not in sys.argv:
        gmsh.fltk.run()

    gmsh.finalize()

if __name__ == "__main__":
    create_plate_with_multiple_holes()
```

## 对称模型（1/4板）

```python
#!/usr/bin/env python3
"""
案例2: 利用对称性建模1/4板
"""
import gmsh
import sys

def create_quarter_plate():
    """创建1/4对称模型"""
    gmsh.initialize(sys.argv)
    gmsh.model.add("quarter_plate")

    # 几何参数
    Lx = 2.0      # 半宽
    Ly = 1.0      # 半高
    r = 0.3       # 孔半径

    # 使用geo内核更好控制
    lc = 0.05  # 孔边缘网格尺寸
    lc_far = 0.15  # 远场网格尺寸

    # 创建点 - 从孔边缘开始
    p1 = gmsh.model.geo.addPoint(r, 0, 0, lc)      # 孔与X轴交点
    p2 = gmsh.model.geo.addPoint(Lx, 0, 0, lc_far) # 右下角
    p3 = gmsh.model.geo.addPoint(Lx, Ly, 0, lc_far)# 右上角
    p4 = gmsh.model.geo.addPoint(0, Ly, 0, lc_far) # 左上角
    p5 = gmsh.model.geo.addPoint(0, r, 0, lc)      # 孔与Y轴交点
    p6 = gmsh.model.geo.addPoint(0, 0, 0, lc)      # 圆心

    # 创建线和圆弧
    l1 = gmsh.model.geo.addLine(p1, p2)           # 底边
    l2 = gmsh.model.geo.addLine(p2, p3)           # 右边
    l3 = gmsh.model.geo.addLine(p3, p4)           # 顶边
    l4 = gmsh.model.geo.addLine(p4, p5)           # 左边

    # 圆弧（1/4圆）
    arc = gmsh.model.geo.addCircleArc(p5, p6, p1)

    # 创建曲线环和平面
    cl = gmsh.model.geo.addCurveLoop([l1, l2, l3, l4, arc])
    s = gmsh.model.geo.addPlaneSurface([cl])

    gmsh.model.geo.synchronize()

    # 物理组
    gmsh.model.addPhysicalGroup(1, [l1], name="SymmetryX")      # X对称面
    gmsh.model.addPhysicalGroup(1, [l4], name="SymmetryY")      # Y对称面
    gmsh.model.addPhysicalGroup(1, [l2], name="Right")          # 加载边
    gmsh.model.addPhysicalGroup(1, [l3], name="Top")            # 自由边
    gmsh.model.addPhysicalGroup(1, [arc], name="Hole")          # 孔边界
    gmsh.model.addPhysicalGroup(2, [s], name="Plate")

    gmsh.model.mesh.generate(2)
    gmsh.write("quarter_plate.msh")

    if "-nopopup" not in sys.argv:
        gmsh.fltk.run()

    gmsh.finalize()

if __name__ == "__main__":
    create_quarter_plate()
```

## 椭圆孔

```python
#!/usr/bin/env python3
"""
案例2: 椭圆孔板
"""
import gmsh
import sys

def create_plate_with_ellipse():
    """创建椭圆孔板"""
    gmsh.initialize(sys.argv)
    gmsh.model.add("ellipse_hole")

    # 几何参数
    Lx, Ly = 4.0, 3.0
    a, b = 0.6, 0.3  # 椭圆半长轴和半短轴
    cx, cy = Lx/2, Ly/2

    # 创建板
    plate = gmsh.model.occ.addRectangle(0, 0, 0, Lx, Ly)

    # 创建椭圆孔
    # addEllipse(xc, yc, zc, r1, r2, tag=-1, angle1=0, angle2=2*pi, zAxis=[], xAxis=[])
    ellipse = gmsh.model.occ.addDisk(cx, cy, 0, a, b)

    # 布尔差集
    result, _ = gmsh.model.occ.cut([(2, plate)], [(2, ellipse)])

    gmsh.model.occ.synchronize()

    surface_tag = result[0][1]

    # 获取孔边界
    boundary = gmsh.model.getBoundary([(2, surface_tag)], oriented=False)

    hole_boundary = []
    for dim, tag in boundary:
        com = gmsh.model.occ.getCenterOfMass(dim, tag)
        x, y = com[0], com[1]
        if not (abs(x) < 1e-6 or abs(x - Lx) < 1e-6 or
                abs(y) < 1e-6 or abs(y - Ly) < 1e-6):
            hole_boundary.append(tag)

    # 在椭圆边缘加密
    dist = gmsh.model.mesh.field.add("Distance")
    gmsh.model.mesh.field.setNumbers(dist, "CurvesList", hole_boundary)

    thresh = gmsh.model.mesh.field.add("Threshold")
    gmsh.model.mesh.field.setNumber(thresh, "InField", dist)
    gmsh.model.mesh.field.setNumber(thresh, "SizeMin", 0.02)
    gmsh.model.mesh.field.setNumber(thresh, "SizeMax", 0.15)
    gmsh.model.mesh.field.setNumber(thresh, "DistMin", 0.05)
    gmsh.model.mesh.field.setNumber(thresh, "DistMax", 0.5)

    gmsh.model.mesh.field.setAsBackgroundMesh(thresh)

    gmsh.option.setNumber("Mesh.MeshSizeExtendFromBoundary", 0)
    gmsh.option.setNumber("Mesh.MeshSizeFromPoints", 0)

    gmsh.model.addPhysicalGroup(2, [surface_tag], name="Plate")

    gmsh.model.mesh.generate(2)
    gmsh.write("ellipse_hole.msh")

    if "-nopopup" not in sys.argv:
        gmsh.fltk.run()

    gmsh.finalize()

if __name__ == "__main__":
    create_plate_with_ellipse()
```

## 应力集中分析网格

```python
#!/usr/bin/env python3
"""
案例2: 应力集中分析的精细网格
"""
import gmsh
import sys
import numpy as np

def create_stress_concentration_mesh():
    """
    创建用于应力集中分析的网格
    特点：孔边缘极细密网格，远离孔逐渐变粗
    """
    gmsh.initialize(sys.argv)
    gmsh.model.add("stress_concentration")

    # 几何参数
    Lx, Ly = 4.0, 2.0
    r = 0.3
    cx, cy = Lx/2, Ly/2

    # 创建几何
    plate = gmsh.model.occ.addRectangle(0, 0, 0, Lx, Ly)
    hole = gmsh.model.occ.addDisk(cx, cy, 0, r, r)
    result, _ = gmsh.model.occ.cut([(2, plate)], [(2, hole)])

    gmsh.model.occ.synchronize()

    surface_tag = result[0][1]
    boundary = gmsh.model.getBoundary([(2, surface_tag)], oriented=False)

    hole_boundary = []
    for dim, tag in boundary:
        com = gmsh.model.occ.getCenterOfMass(dim, tag)
        dist_to_center = np.sqrt((com[0] - cx)**2 + (com[1] - cy)**2)
        if dist_to_center < r + 0.1:
            hole_boundary.append(tag)

    # 多层尺寸场实现精细控制
    fields = []

    # 第一层：紧贴孔边 - 最细
    dist1 = gmsh.model.mesh.field.add("Distance")
    gmsh.model.mesh.field.setNumbers(dist1, "CurvesList", hole_boundary)

    thresh1 = gmsh.model.mesh.field.add("Threshold")
    gmsh.model.mesh.field.setNumber(thresh1, "InField", dist1)
    gmsh.model.mesh.field.setNumber(thresh1, "SizeMin", 0.005)  # 非常细
    gmsh.model.mesh.field.setNumber(thresh1, "SizeMax", 0.01)
    gmsh.model.mesh.field.setNumber(thresh1, "DistMin", 0.01)
    gmsh.model.mesh.field.setNumber(thresh1, "DistMax", 0.05)
    fields.append(thresh1)

    # 第二层：过渡区
    thresh2 = gmsh.model.mesh.field.add("Threshold")
    gmsh.model.mesh.field.setNumber(thresh2, "InField", dist1)
    gmsh.model.mesh.field.setNumber(thresh2, "SizeMin", 0.01)
    gmsh.model.mesh.field.setNumber(thresh2, "SizeMax", 0.05)
    gmsh.model.mesh.field.setNumber(thresh2, "DistMin", 0.05)
    gmsh.model.mesh.field.setNumber(thresh2, "DistMax", 0.3)
    fields.append(thresh2)

    # 第三层：远场
    thresh3 = gmsh.model.mesh.field.add("Threshold")
    gmsh.model.mesh.field.setNumber(thresh3, "InField", dist1)
    gmsh.model.mesh.field.setNumber(thresh3, "SizeMin", 0.05)
    gmsh.model.mesh.field.setNumber(thresh3, "SizeMax", 0.2)
    gmsh.model.mesh.field.setNumber(thresh3, "DistMin", 0.3)
    gmsh.model.mesh.field.setNumber(thresh3, "DistMax", 1.0)
    fields.append(thresh3)

    # 取最小值
    min_field = gmsh.model.mesh.field.add("Min")
    gmsh.model.mesh.field.setNumbers(min_field, "FieldsList", fields)

    gmsh.model.mesh.field.setAsBackgroundMesh(min_field)

    gmsh.option.setNumber("Mesh.MeshSizeExtendFromBoundary", 0)
    gmsh.option.setNumber("Mesh.MeshSizeFromPoints", 0)
    gmsh.option.setNumber("Mesh.MeshSizeFromCurvature", 0)

    # 使用高质量算法
    gmsh.option.setNumber("Mesh.Algorithm", 6)  # Frontal-Delaunay

    gmsh.model.addPhysicalGroup(2, [surface_tag], name="Plate")

    gmsh.model.mesh.generate(2)

    # 输出统计
    elem_types, elem_tags, _ = gmsh.model.mesh.getElements(dim=2)
    total_elems = sum(len(t) for t in elem_tags)
    print(f"总元素数: {total_elems}")

    gmsh.write("stress_concentration.msh")

    if "-nopopup" not in sys.argv:
        gmsh.fltk.run()

    gmsh.finalize()

if __name__ == "__main__":
    create_stress_concentration_mesh()
```

## 完整工作流：FEM分析准备

```python
#!/usr/bin/env python3
"""
案例2: 完整工作流 - 为FEM分析准备网格
"""
import gmsh
import numpy as np
import json
import sys

def prepare_fem_mesh():
    """准备FEM分析用网格"""
    gmsh.initialize(sys.argv)
    gmsh.model.add("fem_ready")

    # 几何参数
    params = {
        "Lx": 4.0,
        "Ly": 2.0,
        "hole_radius": 0.3,
        "hole_cx": 2.0,
        "hole_cy": 1.0
    }

    Lx, Ly = params["Lx"], params["Ly"]
    r = params["hole_radius"]
    cx, cy = params["hole_cx"], params["hole_cy"]

    # 创建几何
    plate = gmsh.model.occ.addRectangle(0, 0, 0, Lx, Ly)
    hole = gmsh.model.occ.addDisk(cx, cy, 0, r, r)
    result, _ = gmsh.model.occ.cut([(2, plate)], [(2, hole)])
    gmsh.model.occ.synchronize()

    surface_tag = result[0][1]
    boundary = gmsh.model.getBoundary([(2, surface_tag)], oriented=False)

    # 分类边界
    boundaries = {"left": [], "right": [], "top": [], "bottom": [], "hole": []}

    for dim, tag in boundary:
        com = gmsh.model.occ.getCenterOfMass(dim, tag)
        x, y = com[0], com[1]

        if abs(x) < 1e-6:
            boundaries["left"].append(tag)
        elif abs(x - Lx) < 1e-6:
            boundaries["right"].append(tag)
        elif abs(y) < 1e-6:
            boundaries["bottom"].append(tag)
        elif abs(y - Ly) < 1e-6:
            boundaries["top"].append(tag)
        else:
            boundaries["hole"].append(tag)

    # 定义物理组并记录ID
    physical_ids = {}
    tag_counter = 1

    for name, curves in boundaries.items():
        if curves:
            gmsh.model.addPhysicalGroup(1, curves, tag=tag_counter, name=name.capitalize())
            physical_ids[name] = tag_counter
            tag_counter += 1

    gmsh.model.addPhysicalGroup(2, [surface_tag], tag=100, name="Domain")
    physical_ids["domain"] = 100

    # 网格尺寸场
    dist = gmsh.model.mesh.field.add("Distance")
    gmsh.model.mesh.field.setNumbers(dist, "CurvesList", boundaries["hole"])

    thresh = gmsh.model.mesh.field.add("Threshold")
    gmsh.model.mesh.field.setNumber(thresh, "InField", dist)
    gmsh.model.mesh.field.setNumber(thresh, "SizeMin", 0.02)
    gmsh.model.mesh.field.setNumber(thresh, "SizeMax", 0.15)
    gmsh.model.mesh.field.setNumber(thresh, "DistMin", 0.05)
    gmsh.model.mesh.field.setNumber(thresh, "DistMax", 0.5)

    gmsh.model.mesh.field.setAsBackgroundMesh(thresh)

    gmsh.option.setNumber("Mesh.MeshSizeExtendFromBoundary", 0)
    gmsh.option.setNumber("Mesh.MeshSizeFromPoints", 0)

    # 生成二次元素网格
    gmsh.option.setNumber("Mesh.ElementOrder", 2)
    gmsh.model.mesh.generate(2)

    # 收集网格信息
    node_tags, coords, _ = gmsh.model.mesh.getNodes()
    coords = np.array(coords).reshape(-1, 3)

    elem_types, elem_tags, elem_nodes = gmsh.model.mesh.getElements(dim=2)

    mesh_info = {
        "parameters": params,
        "physical_ids": physical_ids,
        "num_nodes": len(node_tags),
        "num_elements": sum(len(t) for t in elem_tags),
        "element_order": 2,
        "bounding_box": {
            "xmin": float(coords[:, 0].min()),
            "xmax": float(coords[:, 0].max()),
            "ymin": float(coords[:, 1].min()),
            "ymax": float(coords[:, 1].max())
        }
    }

    # 保存网格信息
    with open("fem_mesh_info.json", "w") as f:
        json.dump(mesh_info, f, indent=2)

    # 保存网格
    gmsh.write("fem_ready.msh")

    print("FEM网格准备完成:")
    print(f"  节点数: {mesh_info['num_nodes']}")
    print(f"  元素数: {mesh_info['num_elements']}")
    print(f"  元素阶数: {mesh_info['element_order']}")
    print(f"  物理组: {list(physical_ids.keys())}")

    if "-nopopup" not in sys.argv:
        gmsh.fltk.run()

    gmsh.finalize()

if __name__ == "__main__":
    prepare_fem_mesh()
```

## 总结

本案例涵盖了：

1. **单孔和多孔处理**: 使用布尔运算
2. **边界识别**: 自动分类不同边界
3. **孔边缘加密**: 使用距离场和阈值场
4. **对称建模**: 利用对称性减少计算量
5. **多层尺寸控制**: 精细控制网格密度
6. **FEM分析准备**: 完整工作流

## 下一步

- [03-3D立方体网格](./03-3D立方体网格.md) - 进入3D网格生成
