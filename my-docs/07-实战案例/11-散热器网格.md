# 散热器网格

本节介绍散热器的网格生成，包括翅片散热器、针柱散热器和热管散热器等常见结构，适用于热分析和流固耦合仿真。

## 学习目标

- 理解热分析网格的特殊要求
- 掌握散热翅片的参数化建模
- 学习流固界面的网格处理
- 实现边界层网格用于对流换热

## 热分析网格基础

### 网格密度考虑因素

```python
"""
热分析网格密度指南
"""
import gmsh
import numpy as np

def thermal_mesh_guidelines():
    """热分析网格设计指南"""
    print("热分析网格设计指南")
    print("=" * 50)
    print("""
    1. 温度梯度区域细化
       - 热源附近
       - 材料界面
       - 对流换热边界

    2. 典型网格密度
       - 热源区域: 0.1-0.5 mm
       - 散热翅片: 0.5-2 mm
       - 空气域: 2-5 mm

    3. 边界层网格（对流换热）
       - 第一层高度: y+ ≈ 1（层流）或 y+ ≈ 30-50（壁面函数）
       - 增长率: 1.1-1.2
       - 层数: 10-20层

    4. 界面网格
       - 固-固界面: 匹配节点
       - 固-流界面: 可不匹配但需插值
    """)

thermal_mesh_guidelines()
```

## 翅片散热器

### 基础矩形翅片散热器

```python
"""
矩形翅片散热器网格
"""
import gmsh
import numpy as np

gmsh.initialize()
gmsh.model.add("fin_heatsink")

# 散热器参数
base_length = 50e-3     # 基板长度
base_width = 40e-3      # 基板宽度
base_height = 3e-3      # 基板厚度

fin_height = 25e-3      # 翅片高度
fin_thickness = 1.5e-3  # 翅片厚度
fin_spacing = 4e-3      # 翅片间距
num_fins = 8            # 翅片数量

# 热源参数
heat_source_size = 15e-3    # 热源尺寸（正方形）

# 网格参数
mesh_base = 2e-3
mesh_fin = 1e-3
mesh_fine = 0.5e-3  # 热源区域

# 创建基板
base = gmsh.model.occ.addBox(
    -base_length/2, 0, -base_width/2,
    base_length, base_height, base_width
)

# 创建翅片
fins = []
fin_start_x = -base_length/2 + (base_length - (num_fins-1)*fin_spacing) / 2

for i in range(num_fins):
    fin_x = fin_start_x + i * fin_spacing - fin_thickness/2
    fin = gmsh.model.occ.addBox(
        fin_x, base_height, -base_width/2,
        fin_thickness, fin_height, base_width
    )
    fins.append(fin)

# 融合基板和翅片
all_volumes = [(3, base)] + [(3, f) for f in fins]
fused = gmsh.model.occ.fuse([all_volumes[0]], all_volumes[1:])
gmsh.model.occ.synchronize()

# 获取融合后的体积
heatsink_volumes = gmsh.model.getEntities(3)
gmsh.model.addPhysicalGroup(3, [v[1] for v in heatsink_volumes], name="Heatsink_Aluminum")

# 定义热源区域（在基板底面中心）
surfaces = gmsh.model.getEntities(2)
heat_source_surfaces = []
base_bottom_surfaces = []
fin_surfaces = []

for dim, tag in surfaces:
    bbox = gmsh.model.occ.getBoundingBox(dim, tag)
    com = gmsh.model.occ.getCenterOfMass(dim, tag)

    # 底面 (y=0)
    if abs(bbox[1]) < 1e-10 and abs(bbox[4]) < 1e-10:
        # 检查是否在热源区域
        if (abs(com[0]) < heat_source_size/2 and
            abs(com[2]) < heat_source_size/2):
            heat_source_surfaces.append(tag)
        else:
            base_bottom_surfaces.append(tag)

    # 翅片表面（y > base_height的水平或垂直面）
    elif bbox[1] >= base_height - 1e-6 or bbox[4] > base_height + 1e-6:
        fin_surfaces.append(tag)

# 如果热源区域需要单独定义，需要对底面进行切割
# 这里简化处理，将整个底面标记为可能的热源区域
all_bottom = heat_source_surfaces + base_bottom_surfaces
if all_bottom:
    gmsh.model.addPhysicalGroup(2, all_bottom, name="Base_Bottom")
if fin_surfaces:
    gmsh.model.addPhysicalGroup(2, fin_surfaces, name="Fin_Surface")

# 尺寸场
# 热源区域细化
gmsh.model.mesh.field.add("Box", 1)
gmsh.model.mesh.field.setNumber(1, "VIn", mesh_fine)
gmsh.model.mesh.field.setNumber(1, "VOut", mesh_base)
gmsh.model.mesh.field.setNumber(1, "XMin", -heat_source_size)
gmsh.model.mesh.field.setNumber(1, "XMax", heat_source_size)
gmsh.model.mesh.field.setNumber(1, "YMin", -1e-3)
gmsh.model.mesh.field.setNumber(1, "YMax", base_height + 5e-3)
gmsh.model.mesh.field.setNumber(1, "ZMin", -heat_source_size)
gmsh.model.mesh.field.setNumber(1, "ZMax", heat_source_size)
gmsh.model.mesh.field.setNumber(1, "Thickness", 5e-3)

# 翅片细化
gmsh.model.mesh.field.add("Box", 2)
gmsh.model.mesh.field.setNumber(2, "VIn", mesh_fin)
gmsh.model.mesh.field.setNumber(2, "VOut", mesh_base)
gmsh.model.mesh.field.setNumber(2, "XMin", -base_length/2)
gmsh.model.mesh.field.setNumber(2, "XMax", base_length/2)
gmsh.model.mesh.field.setNumber(2, "YMin", base_height)
gmsh.model.mesh.field.setNumber(2, "YMax", base_height + fin_height)
gmsh.model.mesh.field.setNumber(2, "ZMin", -base_width/2)
gmsh.model.mesh.field.setNumber(2, "ZMax", base_width/2)

gmsh.model.mesh.field.add("Min", 3)
gmsh.model.mesh.field.setNumbers(3, "FieldsList", [1, 2])
gmsh.model.mesh.field.setAsBackgroundMesh(3)

# 生成网格
gmsh.model.mesh.generate(3)
gmsh.model.mesh.optimize("Netgen")

# 统计
_, nodes, _ = gmsh.model.mesh.getNodes()
elem_types, elem_tags, _ = gmsh.model.mesh.getElements(3)
print(f"翅片散热器网格统计:")
print(f"  节点数: {len(nodes)}")
print(f"  四面体数: {sum(len(t) for t in elem_tags)}")

gmsh.write("fin_heatsink.msh")
gmsh.finalize()
```

### 参数化翅片散热器生成器

```python
"""
参数化翅片散热器生成器
"""
import gmsh
import numpy as np

class FinHeatsinkGenerator:
    """翅片散热器网格生成器"""

    def __init__(self):
        self.base_params = {
            'length': 50e-3,
            'width': 40e-3,
            'height': 3e-3
        }
        self.fin_params = {
            'height': 25e-3,
            'thickness': 1.5e-3,
            'spacing': 4e-3,
            'count': 8
        }
        self.mesh_params = {
            'base': 2e-3,
            'fin': 1e-3,
            'fine': 0.5e-3
        }

    def set_base(self, length, width, height):
        """设置基板参数"""
        self.base_params = {
            'length': length,
            'width': width,
            'height': height
        }

    def set_fins(self, height, thickness, spacing, count):
        """设置翅片参数"""
        self.fin_params = {
            'height': height,
            'thickness': thickness,
            'spacing': spacing,
            'count': count
        }

    def create_straight_fins(self):
        """创建直翅片散热器"""
        bp = self.base_params
        fp = self.fin_params

        # 基板
        base = gmsh.model.occ.addBox(
            -bp['length']/2, 0, -bp['width']/2,
            bp['length'], bp['height'], bp['width']
        )

        # 翅片
        fins = []
        total_fin_width = (fp['count'] - 1) * fp['spacing']
        start_x = -total_fin_width / 2 - fp['thickness']/2

        for i in range(fp['count']):
            x = start_x + i * fp['spacing']
            fin = gmsh.model.occ.addBox(
                x, bp['height'], -bp['width']/2,
                fp['thickness'], fp['height'], bp['width']
            )
            fins.append(fin)

        return base, fins

    def create_offset_fins(self):
        """创建错列翅片散热器（增强换热）"""
        bp = self.base_params
        fp = self.fin_params

        base = gmsh.model.occ.addBox(
            -bp['length']/2, 0, -bp['width']/2,
            bp['length'], bp['height'], bp['width']
        )

        fins = []
        # 前半段
        segment_length = bp['width'] / 2

        for row in range(2):
            offset = fp['spacing'] / 2 if row == 1 else 0
            z_start = -bp['width']/2 + row * segment_length

            total_fin_width = (fp['count'] - 1) * fp['spacing']
            start_x = -total_fin_width / 2 - fp['thickness']/2 + offset

            for i in range(fp['count'] - (1 if row == 1 else 0)):
                x = start_x + i * fp['spacing']
                fin = gmsh.model.occ.addBox(
                    x, bp['height'], z_start,
                    fp['thickness'], fp['height'], segment_length * 0.9
                )
                fins.append(fin)

        return base, fins

    def create_tapered_fins(self):
        """创建锥形翅片散热器"""
        bp = self.base_params
        fp = self.fin_params

        base = gmsh.model.occ.addBox(
            -bp['length']/2, 0, -bp['width']/2,
            bp['length'], bp['height'], bp['width']
        )

        fins = []
        total_fin_width = (fp['count'] - 1) * fp['spacing']
        start_x = -total_fin_width / 2

        for i in range(fp['count']):
            x = start_x + i * fp['spacing']

            # 创建锥形翅片（底宽顶窄）
            base_thick = fp['thickness']
            top_thick = fp['thickness'] * 0.6

            # 使用6个点定义梯形截面
            y_base = bp['height']
            y_top = bp['height'] + fp['height']

            p1 = gmsh.model.occ.addPoint(x - base_thick/2, y_base, -bp['width']/2)
            p2 = gmsh.model.occ.addPoint(x + base_thick/2, y_base, -bp['width']/2)
            p3 = gmsh.model.occ.addPoint(x + top_thick/2, y_top, -bp['width']/2)
            p4 = gmsh.model.occ.addPoint(x - top_thick/2, y_top, -bp['width']/2)

            l1 = gmsh.model.occ.addLine(p1, p2)
            l2 = gmsh.model.occ.addLine(p2, p3)
            l3 = gmsh.model.occ.addLine(p3, p4)
            l4 = gmsh.model.occ.addLine(p4, p1)

            loop = gmsh.model.occ.addCurveLoop([l1, l2, l3, l4])
            surf = gmsh.model.occ.addPlaneSurface([loop])

            # 拉伸
            extrude = gmsh.model.occ.extrude([(2, surf)], 0, 0, bp['width'])
            fin_vol = [e[1] for e in extrude if e[0] == 3][0]
            fins.append(fin_vol)

        return base, fins

    def generate(self, fin_type='straight', output_file='heatsink.msh'):
        """生成散热器网格"""
        gmsh.initialize()
        gmsh.model.add("parametric_heatsink")

        # 根据类型创建几何
        if fin_type == 'straight':
            base, fins = self.create_straight_fins()
        elif fin_type == 'offset':
            base, fins = self.create_offset_fins()
        elif fin_type == 'tapered':
            base, fins = self.create_tapered_fins()
        else:
            raise ValueError(f"Unknown fin type: {fin_type}")

        # 融合
        all_volumes = [(3, base)] + [(3, f) for f in fins]
        fused = gmsh.model.occ.fuse([all_volumes[0]], all_volumes[1:])
        gmsh.model.occ.synchronize()

        # 物理组
        volumes = gmsh.model.getEntities(3)
        gmsh.model.addPhysicalGroup(3, [v[1] for v in volumes], name="Heatsink")

        # 网格尺寸场
        self._setup_mesh_fields()

        # 生成网格
        gmsh.model.mesh.generate(3)
        gmsh.model.mesh.optimize("Netgen")

        # 导出
        gmsh.write(output_file)

        # 统计
        _, nodes, _ = gmsh.model.mesh.getNodes()
        print(f"散热器网格 ({fin_type}):")
        print(f"  节点数: {len(nodes)}")

        gmsh.finalize()

    def _setup_mesh_fields(self):
        """设置网格尺寸场"""
        bp = self.base_params
        fp = self.fin_params
        mp = self.mesh_params

        # 翅片区域
        gmsh.model.mesh.field.add("Box", 1)
        gmsh.model.mesh.field.setNumber(1, "VIn", mp['fin'])
        gmsh.model.mesh.field.setNumber(1, "VOut", mp['base'])
        gmsh.model.mesh.field.setNumber(1, "XMin", -bp['length']/2)
        gmsh.model.mesh.field.setNumber(1, "XMax", bp['length']/2)
        gmsh.model.mesh.field.setNumber(1, "YMin", bp['height'])
        gmsh.model.mesh.field.setNumber(1, "YMax", bp['height'] + fp['height'])
        gmsh.model.mesh.field.setNumber(1, "ZMin", -bp['width']/2)
        gmsh.model.mesh.field.setNumber(1, "ZMax", bp['width']/2)

        gmsh.model.mesh.field.setAsBackgroundMesh(1)


# 使用示例
if __name__ == "__main__":
    generator = FinHeatsinkGenerator()

    # 设置参数
    generator.set_base(length=60e-3, width=50e-3, height=4e-3)
    generator.set_fins(height=30e-3, thickness=2e-3, spacing=5e-3, count=10)

    # 生成不同类型
    generator.generate(fin_type='straight', output_file='heatsink_straight.msh')
```

## 针柱散热器

### 圆形针柱散热器

```python
"""
圆形针柱散热器网格
"""
import gmsh
import numpy as np

gmsh.initialize()
gmsh.model.add("pin_fin_heatsink")

# 参数
base_size = 40e-3       # 基板尺寸（正方形）
base_height = 3e-3      # 基板厚度

pin_radius = 1.5e-3     # 针柱半径
pin_height = 20e-3      # 针柱高度
pin_spacing = 6e-3      # 针柱间距（中心距）
pin_array = (6, 6)      # 针柱阵列

# 网格参数
mesh_size = 1.5e-3
mesh_fine = 0.8e-3

# 创建基板
base = gmsh.model.occ.addBox(
    -base_size/2, 0, -base_size/2,
    base_size, base_height, base_size
)

# 创建针柱阵列
pins = []
array_width = (pin_array[0] - 1) * pin_spacing
array_depth = (pin_array[1] - 1) * pin_spacing

for i in range(pin_array[0]):
    for j in range(pin_array[1]):
        x = -array_width/2 + i * pin_spacing
        z = -array_depth/2 + j * pin_spacing

        pin = gmsh.model.occ.addCylinder(
            x, base_height, z,
            0, pin_height, 0,
            pin_radius
        )
        pins.append(pin)

# 融合
all_volumes = [(3, base)] + [(3, p) for p in pins]
fused = gmsh.model.occ.fuse([all_volumes[0]], all_volumes[1:])
gmsh.model.occ.synchronize()

# 物理组
volumes = gmsh.model.getEntities(3)
gmsh.model.addPhysicalGroup(3, [v[1] for v in volumes], name="Heatsink_Copper")

# 定义表面
surfaces = gmsh.model.getEntities(2)
bottom_surfaces = []
top_surfaces = []
pin_surfaces = []

for dim, tag in surfaces:
    bbox = gmsh.model.occ.getBoundingBox(dim, tag)
    com = gmsh.model.occ.getCenterOfMass(dim, tag)

    if abs(bbox[1]) < 1e-10 and abs(bbox[4]) < 1e-10:  # y=0
        bottom_surfaces.append(tag)
    elif abs(bbox[1] - (base_height + pin_height)) < 1e-6:  # 针柱顶面
        top_surfaces.append(tag)
    elif bbox[1] >= base_height - 1e-6:  # 针柱侧面或基板顶面
        # 检查是否是圆柱面
        if abs(bbox[4] - bbox[1] - pin_height) < 1e-6:
            pin_surfaces.append(tag)

if bottom_surfaces:
    gmsh.model.addPhysicalGroup(2, bottom_surfaces, name="Heat_Source")
if pin_surfaces:
    gmsh.model.addPhysicalGroup(2, pin_surfaces, name="Pin_Surface")

# 网格尺寸场
# 针柱区域细化
gmsh.model.mesh.field.add("Cylinder", 1)
gmsh.model.mesh.field.setNumber(1, "VIn", mesh_fine)
gmsh.model.mesh.field.setNumber(1, "VOut", mesh_size)
gmsh.model.mesh.field.setNumber(1, "XCenter", 0)
gmsh.model.mesh.field.setNumber(1, "YCenter", base_height + pin_height/2)
gmsh.model.mesh.field.setNumber(1, "ZCenter", 0)
gmsh.model.mesh.field.setNumber(1, "XAxis", 0)
gmsh.model.mesh.field.setNumber(1, "YAxis", 1)
gmsh.model.mesh.field.setNumber(1, "ZAxis", 0)
gmsh.model.mesh.field.setNumber(1, "Radius", max(array_width, array_depth)/2 + pin_radius * 2)

gmsh.model.mesh.field.setAsBackgroundMesh(1)

# 生成网格
gmsh.model.mesh.generate(3)
gmsh.model.mesh.optimize("Netgen")

# 统计
_, nodes, _ = gmsh.model.mesh.getNodes()
elem_types, elem_tags, _ = gmsh.model.mesh.getElements(3)
print(f"针柱散热器网格统计:")
print(f"  节点数: {len(nodes)}")
print(f"  四面体数: {sum(len(t) for t in elem_tags)}")
print(f"  针柱数量: {pin_array[0] * pin_array[1]}")

gmsh.write("pin_fin_heatsink.msh")
gmsh.finalize()
```

### 锥形针柱散热器

```python
"""
锥形针柱散热器（优化空气流动）
"""
import gmsh
import numpy as np

gmsh.initialize()
gmsh.model.add("tapered_pin_heatsink")

# 参数
base_size = 40e-3
base_height = 3e-3

pin_base_radius = 2e-3    # 针柱底部半径
pin_top_radius = 1e-3     # 针柱顶部半径
pin_height = 20e-3
pin_spacing = 7e-3
pin_array = (5, 5)

mesh_size = 1.5e-3

# 创建基板
base = gmsh.model.occ.addBox(
    -base_size/2, 0, -base_size/2,
    base_size, base_height, base_size
)

# 创建锥形针柱
pins = []
array_width = (pin_array[0] - 1) * pin_spacing
array_depth = (pin_array[1] - 1) * pin_spacing

for i in range(pin_array[0]):
    for j in range(pin_array[1]):
        x = -array_width/2 + i * pin_spacing
        z = -array_depth/2 + j * pin_spacing

        # 创建锥体
        cone = gmsh.model.occ.addCone(
            x, base_height, z,        # 底部中心
            0, pin_height, 0,         # 方向和高度
            pin_base_radius,          # 底部半径
            pin_top_radius            # 顶部半径
        )
        pins.append(cone)

# 融合
all_volumes = [(3, base)] + [(3, p) for p in pins]
fused = gmsh.model.occ.fuse([all_volumes[0]], all_volumes[1:])
gmsh.model.occ.synchronize()

# 物理组
volumes = gmsh.model.getEntities(3)
gmsh.model.addPhysicalGroup(3, [v[1] for v in volumes], name="Heatsink")

# 网格
gmsh.model.mesh.setSize(gmsh.model.getEntities(0), mesh_size)
gmsh.model.mesh.generate(3)
gmsh.model.mesh.optimize("Netgen")

gmsh.write("tapered_pin_heatsink.msh")
gmsh.finalize()
print("锥形针柱散热器网格生成完成")
```

## 流固耦合网格

### 散热器与空气域

```python
"""
散热器流固耦合网格（固体+流体域）
"""
import gmsh
import numpy as np

gmsh.initialize()
gmsh.model.add("heatsink_conjugate")

# 散热器参数
base_length = 50e-3
base_width = 40e-3
base_height = 3e-3
fin_height = 25e-3
fin_thickness = 1.5e-3
fin_spacing = 4e-3
num_fins = 8

# 空气域参数
air_inlet = 30e-3      # 入口到散热器距离
air_outlet = 50e-3     # 散热器到出口距离
air_height = 50e-3     # 空气域高度
air_side = 10e-3       # 侧面扩展

# 边界层参数
bl_first_height = 0.1e-3
bl_growth = 1.2
bl_layers = 10

# 网格参数
mesh_solid = 1.5e-3
mesh_fluid = 3e-3
mesh_bl = 0.5e-3

# 创建散热器
base = gmsh.model.occ.addBox(
    -base_length/2, 0, -base_width/2,
    base_length, base_height, base_width
)

fins = []
fin_start_x = -base_length/2 + (base_length - (num_fins-1)*fin_spacing) / 2
for i in range(num_fins):
    fin_x = fin_start_x + i * fin_spacing - fin_thickness/2
    fin = gmsh.model.occ.addBox(
        fin_x, base_height, -base_width/2,
        fin_thickness, fin_height, base_width
    )
    fins.append(fin)

# 融合散热器
heatsink_parts = [(3, base)] + [(3, f) for f in fins]
heatsink_fused = gmsh.model.occ.fuse([heatsink_parts[0]], heatsink_parts[1:])
gmsh.model.occ.synchronize()

# 获取散热器体积
heatsink_volumes = gmsh.model.getEntities(3)
heatsink_tag = heatsink_volumes[0][1]

# 创建空气域
total_length = air_inlet + base_length + air_outlet
total_width = base_width + 2 * air_side

air_box = gmsh.model.occ.addBox(
    -base_length/2 - air_inlet,
    0,
    -base_width/2 - air_side,
    total_length,
    air_height,
    total_width
)

# 从空气域中减去散热器
air_cut = gmsh.model.occ.cut([(3, air_box)], [(3, heatsink_tag)], removeObject=True, removeTool=False)
gmsh.model.occ.synchronize()

# 获取流体域
all_volumes = gmsh.model.getEntities(3)
fluid_volumes = [v for v in all_volumes if v[1] != heatsink_tag]

# 分片以确保界面匹配
gmsh.model.occ.fragment(all_volumes, [])
gmsh.model.occ.synchronize()

# 重新获取体积（fragment后标签可能改变）
all_volumes = gmsh.model.getEntities(3)

# 根据体积大小区分固体和流体
solid_vols = []
fluid_vols = []

for dim, tag in all_volumes:
    # 计算体积
    mass = gmsh.model.occ.getMass(dim, tag)
    bbox = gmsh.model.occ.getBoundingBox(dim, tag)

    # 散热器体积较小
    approx_heatsink_vol = base_length * base_width * base_height + num_fins * fin_thickness * fin_height * base_width
    approx_air_vol = total_length * total_width * air_height

    if mass < approx_air_vol / 2:
        solid_vols.append(tag)
    else:
        fluid_vols.append(tag)

# 物理组
if solid_vols:
    gmsh.model.addPhysicalGroup(3, solid_vols, name="Solid_Heatsink")
if fluid_vols:
    gmsh.model.addPhysicalGroup(3, fluid_vols, name="Fluid_Air")

# 定义边界
surfaces = gmsh.model.getEntities(2)
inlet_surfs = []
outlet_surfs = []
wall_surfs = []
interface_surfs = []
heat_source_surfs = []

x_inlet = -base_length/2 - air_inlet
x_outlet = base_length/2 + air_outlet

for dim, tag in surfaces:
    bbox = gmsh.model.occ.getBoundingBox(dim, tag)
    com = gmsh.model.occ.getCenterOfMass(dim, tag)

    # 入口 (x = x_inlet)
    if abs(bbox[0] - x_inlet) < 1e-6 and abs(bbox[3] - x_inlet) < 1e-6:
        inlet_surfs.append(tag)
    # 出口 (x = x_outlet)
    elif abs(bbox[0] - x_outlet) < 1e-6 and abs(bbox[3] - x_outlet) < 1e-6:
        outlet_surfs.append(tag)
    # 底面热源
    elif abs(bbox[1]) < 1e-10 and abs(bbox[4]) < 1e-10:
        if (abs(com[0]) < base_length/2 and abs(com[2]) < base_width/2):
            heat_source_surfs.append(tag)
        else:
            wall_surfs.append(tag)
    # 顶面和侧面
    elif abs(bbox[4] - air_height) < 1e-6:
        wall_surfs.append(tag)

# 找流固界面（散热器的外表面，但不包括底面）
# 这里简化处理，不单独标记界面

if inlet_surfs:
    gmsh.model.addPhysicalGroup(2, inlet_surfs, name="Inlet")
if outlet_surfs:
    gmsh.model.addPhysicalGroup(2, outlet_surfs, name="Outlet")
if heat_source_surfs:
    gmsh.model.addPhysicalGroup(2, heat_source_surfs, name="Heat_Source")
if wall_surfs:
    gmsh.model.addPhysicalGroup(2, wall_surfs, name="Walls")

# 尺寸场
# 散热器区域
gmsh.model.mesh.field.add("Box", 1)
gmsh.model.mesh.field.setNumber(1, "VIn", mesh_solid)
gmsh.model.mesh.field.setNumber(1, "VOut", mesh_fluid)
gmsh.model.mesh.field.setNumber(1, "XMin", -base_length/2 - 5e-3)
gmsh.model.mesh.field.setNumber(1, "XMax", base_length/2 + 5e-3)
gmsh.model.mesh.field.setNumber(1, "YMin", 0)
gmsh.model.mesh.field.setNumber(1, "YMax", base_height + fin_height + 5e-3)
gmsh.model.mesh.field.setNumber(1, "ZMin", -base_width/2 - 5e-3)
gmsh.model.mesh.field.setNumber(1, "ZMax", base_width/2 + 5e-3)
gmsh.model.mesh.field.setNumber(1, "Thickness", 5e-3)

gmsh.model.mesh.field.setAsBackgroundMesh(1)

# 边界层（在流固界面上）
# 注意：Gmsh的边界层需要在extrude时定义，或使用BoundaryLayer字段
# 这里简化处理，使用尺寸场在界面附近细化

# 生成网格
gmsh.model.mesh.generate(3)
gmsh.model.mesh.optimize("Netgen")

# 统计
_, nodes, _ = gmsh.model.mesh.getNodes()
elem_types, elem_tags, _ = gmsh.model.mesh.getElements(3)
print(f"流固耦合网格统计:")
print(f"  节点数: {len(nodes)}")
print(f"  四面体数: {sum(len(t) for t in elem_tags)}")

gmsh.write("heatsink_conjugate.msh")
gmsh.finalize()
```

## 热管散热器

### 热管嵌入式散热器

```python
"""
热管嵌入式散热器
"""
import gmsh
import numpy as np

gmsh.initialize()
gmsh.model.add("heatpipe_heatsink")

# 基板参数
base_length = 80e-3
base_width = 60e-3
base_height = 8e-3

# 热管参数
pipe_outer_radius = 3e-3
pipe_inner_radius = 2.5e-3
pipe_spacing = 15e-3
num_pipes = 4

# 翅片参数
fin_height = 30e-3
fin_thickness = 1e-3
fin_spacing = 3e-3
num_fins = 20

# 网格参数
mesh_size = 1.5e-3
mesh_fine = 0.5e-3

# 创建基板
base = gmsh.model.occ.addBox(
    -base_length/2, 0, -base_width/2,
    base_length, base_height, base_width
)

# 创建热管通道（在基板中）
pipe_channels = []
pipe_start_z = -base_width/2 + (base_width - (num_pipes-1)*pipe_spacing) / 2

for i in range(num_pipes):
    z = pipe_start_z + i * pipe_spacing
    # 外圆柱（热管外壁位置）
    channel = gmsh.model.occ.addCylinder(
        -base_length/2, base_height/2, z,
        base_length, 0, 0,
        pipe_outer_radius
    )
    pipe_channels.append(channel)

# 从基板中减去热管通道
base_with_channels = gmsh.model.occ.cut(
    [(3, base)],
    [(3, c) for c in pipe_channels],
    removeObject=True, removeTool=True
)
gmsh.model.occ.synchronize()

# 获取更新后的基板
volumes = gmsh.model.getEntities(3)
base_tag = volumes[0][1] if volumes else None

# 创建热管（壁+内腔）
heatpipes_wall = []
heatpipes_vapor = []

for i in range(num_pipes):
    z = pipe_start_z + i * pipe_spacing

    # 热管壁（外圆柱 - 内圆柱）
    outer = gmsh.model.occ.addCylinder(
        -base_length/2, base_height/2, z,
        base_length, 0, 0,
        pipe_outer_radius
    )
    inner = gmsh.model.occ.addCylinder(
        -base_length/2, base_height/2, z,
        base_length, 0, 0,
        pipe_inner_radius
    )
    wall = gmsh.model.occ.cut([(3, outer)], [(3, inner)], removeObject=True, removeTool=False)
    gmsh.model.occ.synchronize()

    # 获取壁的tag
    new_volumes = gmsh.model.getEntities(3)
    wall_tag = [v[1] for v in new_volumes if v[1] not in [base_tag] + [p[1] for p in heatpipes_vapor]]
    if wall_tag:
        heatpipes_wall.append(wall_tag[0])

    # 内腔（蒸汽通道）
    vapor = gmsh.model.occ.addCylinder(
        -base_length/2, base_height/2, z,
        base_length, 0, 0,
        pipe_inner_radius
    )
    heatpipes_vapor.append(vapor)

gmsh.model.occ.synchronize()

# 创建翅片（在基板顶部）
fins = []
fin_total_length = (num_fins - 1) * fin_spacing
fin_start_x = -fin_total_length / 2 - fin_thickness/2

for i in range(num_fins):
    x = fin_start_x + i * fin_spacing
    fin = gmsh.model.occ.addBox(
        x, base_height, -base_width/2,
        fin_thickness, fin_height, base_width
    )
    fins.append(fin)

gmsh.model.occ.synchronize()

# 分片以确保界面匹配
all_volumes = gmsh.model.getEntities(3)
gmsh.model.occ.fragment(all_volumes, [])
gmsh.model.occ.synchronize()

# 重新分类体积
all_volumes = gmsh.model.getEntities(3)
base_vols = []
pipe_wall_vols = []
vapor_vols = []
fin_vols = []

for dim, tag in all_volumes:
    bbox = gmsh.model.occ.getBoundingBox(dim, tag)
    com = gmsh.model.occ.getCenterOfMass(dim, tag)
    mass = gmsh.model.occ.getMass(dim, tag)

    height = bbox[4] - bbox[1]
    width_x = bbox[3] - bbox[0]

    # 翅片（高且窄）
    if height > fin_height * 0.5 and width_x < fin_thickness * 2:
        fin_vols.append(tag)
    # 蒸汽通道（圆柱形，半径小）
    elif abs(com[1] - base_height/2) < base_height/2:
        r_est = np.sqrt(mass / (base_length * np.pi))
        if r_est < pipe_inner_radius * 1.2:
            vapor_vols.append(tag)
        elif r_est < pipe_outer_radius * 1.2:
            pipe_wall_vols.append(tag)
        else:
            base_vols.append(tag)
    else:
        base_vols.append(tag)

# 物理组
if base_vols:
    gmsh.model.addPhysicalGroup(3, base_vols, name="Base_Aluminum")
if fin_vols:
    gmsh.model.addPhysicalGroup(3, fin_vols, name="Fins_Aluminum")
if pipe_wall_vols:
    gmsh.model.addPhysicalGroup(3, pipe_wall_vols, name="Pipe_Wall_Copper")
if vapor_vols:
    gmsh.model.addPhysicalGroup(3, vapor_vols, name="Vapor_Chamber")

# 底面（热源）
surfaces = gmsh.model.getEntities(2)
bottom_surfs = []
for dim, tag in surfaces:
    bbox = gmsh.model.occ.getBoundingBox(dim, tag)
    if abs(bbox[1]) < 1e-10 and abs(bbox[4]) < 1e-10:
        bottom_surfs.append(tag)

if bottom_surfs:
    gmsh.model.addPhysicalGroup(2, bottom_surfs, name="Heat_Source")

# 尺寸场
# 热管区域细化
gmsh.model.mesh.field.add("Box", 1)
gmsh.model.mesh.field.setNumber(1, "VIn", mesh_fine)
gmsh.model.mesh.field.setNumber(1, "VOut", mesh_size)
gmsh.model.mesh.field.setNumber(1, "XMin", -base_length/2)
gmsh.model.mesh.field.setNumber(1, "XMax", base_length/2)
gmsh.model.mesh.field.setNumber(1, "YMin", 0)
gmsh.model.mesh.field.setNumber(1, "YMax", base_height)
gmsh.model.mesh.field.setNumber(1, "ZMin", -base_width/2)
gmsh.model.mesh.field.setNumber(1, "ZMax", base_width/2)

gmsh.model.mesh.field.setAsBackgroundMesh(1)

# 生成网格
gmsh.model.mesh.generate(3)
gmsh.model.mesh.optimize("Netgen")

# 统计
_, nodes, _ = gmsh.model.mesh.getNodes()
print(f"热管散热器网格统计:")
print(f"  节点数: {len(nodes)}")

gmsh.write("heatpipe_heatsink.msh")
gmsh.finalize()
```

## 网格质量与热分析验证

### 热分析网格质量检查

```python
"""
热分析网格质量检查
"""
import gmsh
import numpy as np

def check_thermal_mesh_quality(msh_file):
    """检查热分析网格质量"""
    gmsh.initialize()
    gmsh.open(msh_file)

    print("热分析网格质量检查")
    print("=" * 50)

    # 获取所有四面体
    elem_types, elem_tags, elem_nodes = gmsh.model.mesh.getElements(3)
    _, node_coords, _ = gmsh.model.mesh.getNodes()
    node_coords = node_coords.reshape(-1, 3)

    if not elem_tags:
        print("未找到3D单元")
        gmsh.finalize()
        return

    # 获取四面体的雅可比质量
    tet_tags = elem_tags[0]
    num_tets = len(tet_tags)

    # 计算最小雅可比比值
    jacobians = []
    for tag in tet_tags:
        jac, det, pts = gmsh.model.mesh.getJacobian(tag, [0.25, 0.25, 0.25])
        jacobians.append(det[0])

    jacobians = np.array(jacobians)

    # 计算质量指标
    # 使用SIFQ（Scaled Inverse Frobenius Quality）
    gamma_values = []
    tet_nodes_array = elem_nodes[0].reshape(-1, 4) - 1

    for i, tet in enumerate(tet_nodes_array):
        coords = node_coords[tet]
        # 计算边长
        edges = []
        for j in range(4):
            for k in range(j+1, 4):
                edges.append(np.linalg.norm(coords[j] - coords[k]))

        edges = np.array(edges)
        l_max = edges.max()
        l_min = edges.min()

        # 边长比
        aspect = l_max / l_min if l_min > 0 else float('inf')

        # 体积
        v1 = coords[1] - coords[0]
        v2 = coords[2] - coords[0]
        v3 = coords[3] - coords[0]
        volume = abs(np.dot(v1, np.cross(v2, v3))) / 6

        # 理想正四面体的边长（给定体积）
        l_ideal = (6 * np.sqrt(2) * volume) ** (1/3)
        l_rms = np.sqrt(np.mean(edges**2))

        # 质量指标
        if l_rms > 0:
            gamma = l_ideal / l_rms
        else:
            gamma = 0

        gamma_values.append(gamma)

    gamma_values = np.array(gamma_values)

    print(f"网格统计:")
    print(f"  四面体数量: {num_tets}")
    print(f"  节点数量: {len(node_coords)}")
    print()
    print(f"质量指标 (γ, 1.0为理想):")
    print(f"  最小值: {gamma_values.min():.3f}")
    print(f"  最大值: {gamma_values.max():.3f}")
    print(f"  平均值: {gamma_values.mean():.3f}")
    print(f"  标准差: {gamma_values.std():.3f}")
    print()

    # 质量分布
    bins = [0, 0.3, 0.5, 0.7, 0.9, 1.0]
    labels = ['差(<0.3)', '一般(0.3-0.5)', '良好(0.5-0.7)', '很好(0.7-0.9)', '优秀(>0.9)']

    print("质量分布:")
    for i in range(len(bins)-1):
        count = np.sum((gamma_values >= bins[i]) & (gamma_values < bins[i+1]))
        ratio = count / num_tets * 100
        print(f"  {labels[i]}: {count} ({ratio:.1f}%)")

    # 检查是否有劣质单元
    poor_elements = np.sum(gamma_values < 0.3)
    if poor_elements > 0:
        print(f"\n⚠ 警告: 存在 {poor_elements} 个劣质单元 (γ<0.3)")
        print("  建议运行网格优化或细化这些区域")
    else:
        print(f"\n✓ 所有单元质量合格")

    gmsh.finalize()


# 使用示例
if __name__ == "__main__":
    # check_thermal_mesh_quality("fin_heatsink.msh")
    pass
```

## 完整案例：CPU散热器

```python
"""
CPU散热器完整案例（塔式散热器）
"""
import gmsh
import numpy as np

class CPUCoolerGenerator:
    """CPU塔式散热器生成器"""

    def __init__(self):
        # CPU接触板
        self.contact_plate = {
            'size': 40e-3,
            'height': 2e-3
        }

        # 热管
        self.heatpipes = {
            'radius': 3e-3,
            'count': 4,
            'spacing': 8e-3,
            'bend_radius': 20e-3
        }

        # 散热鳍片堆
        self.fin_stack = {
            'width': 100e-3,
            'height': 120e-3,
            'depth': 50e-3,
            'fin_thickness': 0.5e-3,
            'fin_spacing': 2e-3
        }

    def create_geometry(self):
        """创建散热器几何"""
        gmsh.initialize()
        gmsh.model.add("cpu_tower_cooler")

        cp = self.contact_plate
        hp = self.heatpipes
        fs = self.fin_stack

        # 接触板
        contact = gmsh.model.occ.addBox(
            -cp['size']/2, 0, -cp['size']/2,
            cp['size'], cp['height'], cp['size']
        )

        # 热管（简化为直管穿过鳍片）
        pipes = []
        pipe_start_x = -(hp['count']-1) * hp['spacing'] / 2

        for i in range(hp['count']):
            x = pipe_start_x + i * hp['spacing']
            # 垂直段（从接触板向上）
            pipe = gmsh.model.occ.addCylinder(
                x, cp['height'], 0,
                0, fs['height'], 0,
                hp['radius']
            )
            pipes.append(pipe)

        # 鳍片堆
        num_fins = int(fs['depth'] / fs['fin_spacing'])
        fins = []
        fin_start_z = -fs['depth']/2 + fs['fin_spacing']/2

        for i in range(num_fins):
            z = fin_start_z + i * fs['fin_spacing']

            # 创建带孔的鳍片
            fin = gmsh.model.occ.addBox(
                -fs['width']/2, cp['height'] + 10e-3, z - fs['fin_thickness']/2,
                fs['width'], fs['height'] - 10e-3, fs['fin_thickness']
            )

            # 为热管打孔
            for j, pipe_tag in enumerate(pipes):
                x = pipe_start_x + j * hp['spacing']
                hole = gmsh.model.occ.addCylinder(
                    x, cp['height'], z,
                    0, fs['height'] + cp['height'], 0,
                    hp['radius'] + 0.5e-3  # 稍大的孔
                )
                fin_cut = gmsh.model.occ.cut([(3, fin)], [(3, hole)], removeObject=True, removeTool=True)
                gmsh.model.occ.synchronize()

                # 更新fin标签
                new_vols = gmsh.model.getEntities(3)
                if new_vols:
                    fin = new_vols[-1][1]

            fins.append(fin)

        gmsh.model.occ.synchronize()

        # 融合所有部件
        all_parts = gmsh.model.getEntities(3)
        if len(all_parts) > 1:
            gmsh.model.occ.fuse([all_parts[0]], all_parts[1:])
            gmsh.model.occ.synchronize()

        # 物理组
        volumes = gmsh.model.getEntities(3)
        gmsh.model.addPhysicalGroup(3, [v[1] for v in volumes], name="Cooler_Aluminum")

        # 热源面（接触板底面）
        surfaces = gmsh.model.getEntities(2)
        for dim, tag in surfaces:
            bbox = gmsh.model.occ.getBoundingBox(dim, tag)
            com = gmsh.model.occ.getCenterOfMass(dim, tag)
            if (abs(bbox[1]) < 1e-10 and abs(bbox[4]) < 1e-10 and
                abs(com[0]) < cp['size']/2 and abs(com[2]) < cp['size']/2):
                gmsh.model.addPhysicalGroup(2, [tag], name="CPU_Contact")
                break

    def setup_mesh(self):
        """设置网格参数"""
        cp = self.contact_plate
        fs = self.fin_stack

        # 接触板细化
        gmsh.model.mesh.field.add("Box", 1)
        gmsh.model.mesh.field.setNumber(1, "VIn", 0.5e-3)
        gmsh.model.mesh.field.setNumber(1, "VOut", 2e-3)
        gmsh.model.mesh.field.setNumber(1, "XMin", -cp['size'])
        gmsh.model.mesh.field.setNumber(1, "XMax", cp['size'])
        gmsh.model.mesh.field.setNumber(1, "YMin", 0)
        gmsh.model.mesh.field.setNumber(1, "YMax", cp['height'] * 2)
        gmsh.model.mesh.field.setNumber(1, "ZMin", -cp['size'])
        gmsh.model.mesh.field.setNumber(1, "ZMax", cp['size'])
        gmsh.model.mesh.field.setNumber(1, "Thickness", 5e-3)

        # 鳍片区域
        gmsh.model.mesh.field.add("Box", 2)
        gmsh.model.mesh.field.setNumber(2, "VIn", 1e-3)
        gmsh.model.mesh.field.setNumber(2, "VOut", 3e-3)
        gmsh.model.mesh.field.setNumber(2, "XMin", -fs['width']/2)
        gmsh.model.mesh.field.setNumber(2, "XMax", fs['width']/2)
        gmsh.model.mesh.field.setNumber(2, "YMin", cp['height'])
        gmsh.model.mesh.field.setNumber(2, "YMax", cp['height'] + fs['height'])
        gmsh.model.mesh.field.setNumber(2, "ZMin", -fs['depth']/2)
        gmsh.model.mesh.field.setNumber(2, "ZMax", fs['depth']/2)

        gmsh.model.mesh.field.add("Min", 3)
        gmsh.model.mesh.field.setNumbers(3, "FieldsList", [1, 2])
        gmsh.model.mesh.field.setAsBackgroundMesh(3)

    def generate(self, output_file='cpu_cooler.msh'):
        """生成网格"""
        self.create_geometry()
        self.setup_mesh()

        gmsh.model.mesh.generate(3)
        gmsh.model.mesh.optimize("Netgen")

        gmsh.write(output_file)

        # 统计
        _, nodes, _ = gmsh.model.mesh.getNodes()
        print(f"CPU散热器网格统计:")
        print(f"  节点数: {len(nodes)}")

        gmsh.finalize()


# 简化版本（不含热管穿孔）
def create_simple_tower_cooler():
    """创建简化的塔式散热器"""
    gmsh.initialize()
    gmsh.model.add("simple_tower_cooler")

    # 参数
    base_size = 40e-3
    base_height = 5e-3
    fin_width = 80e-3
    fin_height = 100e-3
    fin_depth = 40e-3
    fin_thickness = 1e-3
    fin_spacing = 3e-3

    # 基座
    base = gmsh.model.occ.addBox(
        -base_size/2, 0, -base_size/2,
        base_size, base_height, base_size
    )

    # 散热柱（连接基座和鳍片）
    pillar = gmsh.model.occ.addBox(
        -10e-3, base_height, -fin_depth/2,
        20e-3, 10e-3, fin_depth
    )

    # 鳍片
    fins = []
    num_fins = int(fin_depth / fin_spacing)
    fin_start_z = -fin_depth/2 + fin_spacing/2

    for i in range(num_fins):
        z = fin_start_z + i * fin_spacing
        fin = gmsh.model.occ.addBox(
            -fin_width/2, base_height + 10e-3, z - fin_thickness/2,
            fin_width, fin_height, fin_thickness
        )
        fins.append(fin)

    # 融合
    all_parts = [(3, base), (3, pillar)] + [(3, f) for f in fins]
    gmsh.model.occ.fuse([all_parts[0]], all_parts[1:])
    gmsh.model.occ.synchronize()

    # 物理组
    volumes = gmsh.model.getEntities(3)
    gmsh.model.addPhysicalGroup(3, [v[1] for v in volumes], name="Cooler")

    # 网格
    gmsh.model.mesh.setSize(gmsh.model.getEntities(0), 2e-3)

    # 基座细化
    gmsh.model.mesh.field.add("Box", 1)
    gmsh.model.mesh.field.setNumber(1, "VIn", 1e-3)
    gmsh.model.mesh.field.setNumber(1, "VOut", 2e-3)
    gmsh.model.mesh.field.setNumber(1, "XMin", -base_size/2)
    gmsh.model.mesh.field.setNumber(1, "XMax", base_size/2)
    gmsh.model.mesh.field.setNumber(1, "YMin", 0)
    gmsh.model.mesh.field.setNumber(1, "YMax", base_height * 2)
    gmsh.model.mesh.field.setNumber(1, "ZMin", -base_size/2)
    gmsh.model.mesh.field.setNumber(1, "ZMax", base_size/2)

    gmsh.model.mesh.field.setAsBackgroundMesh(1)

    gmsh.model.mesh.generate(3)
    gmsh.model.mesh.optimize("Netgen")

    gmsh.write("simple_tower_cooler.msh")

    _, nodes, _ = gmsh.model.mesh.getNodes()
    print(f"简化塔式散热器: {len(nodes)} 节点")

    gmsh.finalize()


if __name__ == "__main__":
    create_simple_tower_cooler()
```

## 小结

本节介绍了散热器的网格生成技术：

1. **翅片散热器**：直翅片、错列翅片、锥形翅片
2. **针柱散热器**：圆形针柱、锥形针柱
3. **流固耦合**：固体域与流体域的统一网格
4. **热管散热器**：嵌入式热管结构
5. **塔式散热器**：CPU散热器完整案例

关键技术要点：
- 热源区域和温度梯度大的区域需要细化网格
- 流固界面需要足够的网格分辨率
- 薄翅片结构需要至少3-5层单元穿透厚度
- 使用fragment确保多材料界面节点匹配
