# 物理组定义 (Physical Groups)

物理组是Gmsh中用于组织和标记几何实体的机制，在有限元分析中非常重要。

## 物理组的作用

### 1. 定义边界条件

```
┌─────────────────────────┐
│                         │
│     inlet    wall       │ outlet
│       →      ───        │  →
│              ───        │
│     →                   │  →
│                         │
└─────────────────────────┘
```

- `inlet`: 入口边界
- `outlet`: 出口边界
- `wall`: 壁面边界

### 2. 指定材料区域

```
┌─────────────────────────┐
│      material_1         │
├─────────────────────────┤
│      material_2         │
├─────────────────────────┤
│      material_3         │
└─────────────────────────┘
```

### 3. 控制网格输出

默认情况下，如果定义了物理组，Gmsh只输出属于物理组的元素。

## 创建物理组

### 基本语法

```python
# addPhysicalGroup(dim, tags, tag=-1, name="")
# dim: 维度 (0=点, 1=曲线, 2=曲面, 3=体积)
# tags: 几何实体标签列表
# tag: 物理组标签（-1自动分配）
# name: 物理组名称（可选但推荐）
# 返回：物理组的tag

import gmsh

gmsh.initialize()
gmsh.model.add("physical_groups")

# 创建几何
gmsh.model.occ.addRectangle(0, 0, 0, 2, 1, 1)
gmsh.model.occ.synchronize()

# 创建物理组
# 假设边界曲线的tag为1, 2, 3, 4
inlet = gmsh.model.addPhysicalGroup(1, [4], name="inlet")
outlet = gmsh.model.addPhysicalGroup(1, [2], name="outlet")
wall = gmsh.model.addPhysicalGroup(1, [1, 3], name="wall")
domain = gmsh.model.addPhysicalGroup(2, [1], name="domain")

print(f"inlet物理组tag: {inlet}")
print(f"outlet物理组tag: {outlet}")

gmsh.finalize()
```

### 不同维度的物理组

```python
# 0D物理组 - 点（用于约束点、集中力等）
fixed_points = gmsh.model.addPhysicalGroup(0, [1, 2], name="fixed")

# 1D物理组 - 曲线（用于边界条件）
boundary = gmsh.model.addPhysicalGroup(1, [1, 2, 3, 4], name="boundary")

# 2D物理组 - 曲面（用于面载荷、2D域等）
surface = gmsh.model.addPhysicalGroup(2, [1], name="surface")

# 3D物理组 - 体积（用于材料域）
solid = gmsh.model.addPhysicalGroup(3, [1, 2], name="solid")
```

## 命名物理组

### 创建时命名（推荐）

```python
gmsh.model.addPhysicalGroup(2, [1], name="fluid_domain")
```

### 事后命名

```python
# 先创建
tag = gmsh.model.addPhysicalGroup(2, [1])

# 后命名
gmsh.model.setPhysicalName(2, tag, "fluid_domain")
```

### 获取名称

```python
name = gmsh.model.getPhysicalName(dim, tag)
```

## 查询物理组

### 获取所有物理组

```python
# getPhysicalGroups(dim=-1)
# dim=-1 返回所有维度的物理组

all_groups = gmsh.model.getPhysicalGroups()
# 返回: [(dim, tag), (dim, tag), ...]

# 只获取2D物理组
surface_groups = gmsh.model.getPhysicalGroups(2)
```

### 获取物理组包含的实体

```python
# getEntitiesForPhysicalGroup(dim, tag)
entities = gmsh.model.getEntitiesForPhysicalGroup(2, domain_tag)
# 返回: [surface_tag1, surface_tag2, ...]
```

### 根据实体获取物理组

```python
# getPhysicalGroupsForEntity(dim, tag)
groups = gmsh.model.getPhysicalGroupsForEntity(2, 1)
# 返回该实体所属的所有物理组
```

## 网格输出控制

### 默认行为

```python
# 如果定义了物理组，只输出物理组内的元素
gmsh.model.addPhysicalGroup(2, [1], name="domain")
gmsh.model.mesh.generate(2)
gmsh.write("output.msh")  # 只包含domain的元素
```

### 输出所有元素

```python
# 设置SaveAll选项
gmsh.option.setNumber("Mesh.SaveAll", 1)
gmsh.write("output.msh")  # 包含所有元素
```

### MSH文件中的物理组

```
$PhysicalNames
3                           // 物理组数量
1 1 "inlet"                 // dim tag "name"
1 2 "outlet"
2 3 "domain"
$EndPhysicalNames
```

## 自动识别边界

### 按位置分类

```python
#!/usr/bin/env python3
"""
根据几何位置自动分类边界
"""
import gmsh

gmsh.initialize()
gmsh.model.add("auto_boundary")

# 创建几何
gmsh.model.occ.addRectangle(0, 0, 0, 2, 1)
gmsh.model.occ.synchronize()

# 获取所有边界曲线
curves = gmsh.model.getEntities(1)

# 分类变量
left = []
right = []
bottom = []
top = []

for dim, tag in curves:
    # 获取曲线的边界框
    xmin, ymin, zmin, xmax, ymax, zmax = gmsh.model.getBoundingBox(dim, tag)

    # 获取曲线中点
    cx = (xmin + xmax) / 2
    cy = (ymin + ymax) / 2

    # 根据位置分类
    eps = 1e-6
    if abs(xmin - xmax) < eps:  # 垂直线
        if abs(cx) < eps:
            left.append(tag)
        elif abs(cx - 2) < eps:
            right.append(tag)
    elif abs(ymin - ymax) < eps:  # 水平线
        if abs(cy) < eps:
            bottom.append(tag)
        elif abs(cy - 1) < eps:
            top.append(tag)

# 创建物理组
if left: gmsh.model.addPhysicalGroup(1, left, name="left")
if right: gmsh.model.addPhysicalGroup(1, right, name="right")
if bottom: gmsh.model.addPhysicalGroup(1, bottom, name="bottom")
if top: gmsh.model.addPhysicalGroup(1, top, name="top")

# 域
surfaces = gmsh.model.getEntities(2)
gmsh.model.addPhysicalGroup(2, [s[1] for s in surfaces], name="domain")

gmsh.model.mesh.generate(2)
gmsh.write("auto_boundary.msh")
gmsh.finalize()
```

### 按曲面法向分类（3D）

```python
def get_surface_normal(surface_tag):
    """获取曲面的平均法向量"""
    # 使用曲面中心点的法向
    bounds = gmsh.model.getParametrizationBounds(2, surface_tag)
    u_mid = (bounds[0][0] + bounds[1][0]) / 2
    v_mid = (bounds[0][1] + bounds[1][1]) / 2
    normal = gmsh.model.getNormal(surface_tag, [u_mid, v_mid])
    return normal

# 按法向分类
z_plus = []   # 顶面
z_minus = []  # 底面
x_plus = []   # 右面
# ...

for dim, tag in gmsh.model.getEntities(2):
    nx, ny, nz = get_surface_normal(tag)
    if nz > 0.9:
        z_plus.append(tag)
    elif nz < -0.9:
        z_minus.append(tag)
    # ...
```

## 多材料域示例

```python
#!/usr/bin/env python3
"""
多材料域分片和物理组定义
"""
import gmsh

gmsh.initialize()
gmsh.model.add("multi_material")

# 创建三层结构
layer1 = gmsh.model.occ.addBox(0, 0, 0, 1, 1, 0.3)    # 底层
layer2 = gmsh.model.occ.addBox(0, 0, 0.3, 1, 1, 0.4)  # 中层
layer3 = gmsh.model.occ.addBox(0, 0, 0.7, 1, 1, 0.3)  # 顶层

# 分片确保界面共形
all_layers = [(3, layer1), (3, layer2), (3, layer3)]
result, map = gmsh.model.occ.fragment(all_layers[:-1], [all_layers[-1]])

gmsh.model.occ.synchronize()

# 根据Z坐标分配材料
volumes = gmsh.model.getEntities(3)
for dim, tag in volumes:
    cx, cy, cz = gmsh.model.occ.getCenterOfMass(dim, tag)
    if cz < 0.25:
        gmsh.model.addPhysicalGroup(3, [tag], name="substrate")
    elif cz < 0.55:
        gmsh.model.addPhysicalGroup(3, [tag], name="active_layer")
    else:
        gmsh.model.addPhysicalGroup(3, [tag], name="top_contact")

# 获取所有外表面作为边界
all_surfaces = set()
for dim, tag in volumes:
    boundary = gmsh.model.getBoundary([(dim, tag)], combined=False)
    all_surfaces.update(b[1] for b in boundary)

# 底面和顶面
bottom_surfaces = []
top_surfaces = []
for tag in all_surfaces:
    xmin, ymin, zmin, xmax, ymax, zmax = gmsh.model.getBoundingBox(2, tag)
    if abs(zmin) < 1e-6 and abs(zmax) < 1e-6:
        bottom_surfaces.append(tag)
    elif abs(zmin - 1) < 1e-6 and abs(zmax - 1) < 1e-6:
        top_surfaces.append(tag)

if bottom_surfaces:
    gmsh.model.addPhysicalGroup(2, bottom_surfaces, name="ground")
if top_surfaces:
    gmsh.model.addPhysicalGroup(2, top_surfaces, name="electrode")

gmsh.model.mesh.generate(3)
gmsh.write("multi_material.msh")
gmsh.finalize()
```

## 物理组与求解器集成

### 导出到FEniCS

```python
# FEniCS使用物理组标签来标识边界和域
gmsh.model.addPhysicalGroup(2, [...], tag=1, name="dirichlet")
gmsh.model.addPhysicalGroup(2, [...], tag=2, name="neumann")
gmsh.model.addPhysicalGroup(3, [...], tag=3, name="domain")

# MSH文件可直接被FEniCS读取
```

### 导出到OpenFOAM

```python
# OpenFOAM使用patch名称
# 物理组名称应与boundary文件中的patch名称对应
gmsh.model.addPhysicalGroup(2, [...], name="inlet")
gmsh.model.addPhysicalGroup(2, [...], name="outlet")
gmsh.model.addPhysicalGroup(2, [...], name="walls")
```

## 删除物理组

```python
# removePhysicalGroups(dimTags=[])
# 空列表删除所有物理组

# 删除特定物理组
gmsh.model.removePhysicalGroups([(2, 1)])

# 删除所有物理组
gmsh.model.removePhysicalGroups()
```

## 最佳实践

### 1. 总是命名物理组

```python
# 好
gmsh.model.addPhysicalGroup(2, [1], name="inlet")

# 不好（只有数字标签，难以识别）
gmsh.model.addPhysicalGroup(2, [1])
```

### 2. 使用有意义的名称

```python
# 好
"inlet", "outlet", "wall_no_slip", "fluid_domain"

# 不好
"group1", "surface_1", "pg2"
```

### 3. 在同步后定义物理组

```python
# 创建几何
gmsh.model.occ.addBox(...)

# 同步（必须！）
gmsh.model.occ.synchronize()

# 然后定义物理组
gmsh.model.addPhysicalGroup(...)
```

### 4. 验证物理组覆盖

```python
# 确保所有需要的边界都被定义
def verify_physical_groups():
    all_curves = set(c[1] for c in gmsh.model.getEntities(1))
    pg_curves = set()
    for dim, tag in gmsh.model.getPhysicalGroups(1):
        pg_curves.update(gmsh.model.getEntitiesForPhysicalGroup(dim, tag))

    uncovered = all_curves - pg_curves
    if uncovered:
        print(f"警告：以下曲线未被物理组覆盖: {uncovered}")
```

## 完整示例：CFD边界条件

```python
#!/usr/bin/env python3
"""
为CFD分析定义完整的边界条件物理组
管道流动示例
"""
import gmsh
import math

gmsh.initialize()
gmsh.model.add("pipe_flow")

# 创建管道几何
length = 10
radius = 1

pipe = gmsh.model.occ.addCylinder(0, 0, 0, length, 0, 0, radius)
gmsh.model.occ.synchronize()

# 获取所有曲面
surfaces = gmsh.model.getEntities(2)

# 分类曲面
inlet = []
outlet = []
wall = []

for dim, tag in surfaces:
    # 获取曲面的质心
    cx, cy, cz = gmsh.model.occ.getCenterOfMass(dim, tag)

    # 获取曲面面积
    area = gmsh.model.occ.getMass(dim, tag)

    # 圆形截面面积约为 π*r² ≈ 3.14
    # 侧面面积约为 2*π*r*L ≈ 62.8

    if abs(cx) < 0.01:  # 接近x=0
        inlet.append(tag)
    elif abs(cx - length) < 0.01:  # 接近x=length
        outlet.append(tag)
    else:
        wall.append(tag)

# 创建物理组
if inlet:
    gmsh.model.addPhysicalGroup(2, inlet, name="inlet")
    print(f"入口面: {inlet}")

if outlet:
    gmsh.model.addPhysicalGroup(2, outlet, name="outlet")
    print(f"出口面: {outlet}")

if wall:
    gmsh.model.addPhysicalGroup(2, wall, name="wall")
    print(f"壁面: {wall}")

# 流体域
volumes = gmsh.model.getEntities(3)
gmsh.model.addPhysicalGroup(3, [v[1] for v in volumes], name="fluid")

# 网格设置
gmsh.option.setNumber("Mesh.MeshSizeMin", 0.1)
gmsh.option.setNumber("Mesh.MeshSizeMax", 0.5)

gmsh.model.mesh.generate(3)
gmsh.write("pipe_flow.msh")

# 输出物理组信息
print("\n物理组摘要:")
for dim, tag in gmsh.model.getPhysicalGroups():
    name = gmsh.model.getPhysicalName(dim, tag)
    entities = gmsh.model.getEntitiesForPhysicalGroup(dim, tag)
    print(f"  {name}: dim={dim}, tag={tag}, entities={entities}")

gmsh.finalize()
```

## 下一步

完成几何建模基础后，请继续学习：
- [02-网格生成/01-网格尺寸控制](../02-网格生成/01-网格尺寸控制.md) - 学习网格尺寸控制
