# 布尔运算

布尔运算是CSG（构造实体几何）建模的核心，允许通过组合简单形状创建复杂几何。

**注意**：布尔运算**仅在OpenCASCADE内核（occ）中可用**。

## 布尔运算类型

| 运算 | 函数 | 描述 | 集合表示 |
|-----|------|------|---------|
| 并集 | fuse | 合并两个实体 | A ∪ B |
| 差集 | cut | 从一个实体减去另一个 | A - B |
| 交集 | intersect | 取两个实体的公共部分 | A ∩ B |
| 分片 | fragment | 将重叠区域分割 | 共形分割 |

## 并集 (Fuse/Union)

将多个实体合并为一个。

```python
# fuse(objectDimTags, toolDimTags, tag=-1, removeObject=True, removeTool=True)
# 返回：(结果dimTags, 映射关系outDimTagsMap)

import gmsh

gmsh.initialize()
gmsh.model.add("fuse_demo")

# 创建两个重叠的盒子
box1 = gmsh.model.occ.addBox(0, 0, 0, 1, 1, 1)
box2 = gmsh.model.occ.addBox(0.5, 0, 0, 1, 1, 1)

# 合并
result, map = gmsh.model.occ.fuse([(3, box1)], [(3, box2)])

print(f"结果: {result}")  # [(3, new_tag)]
print(f"映射: {map}")     # 原实体到结果的映射

gmsh.model.occ.synchronize()
gmsh.finalize()
```

### 合并多个实体

```python
# 方法1：多个tool
result, map = gmsh.model.occ.fuse(
    [(3, box1)],
    [(3, box2), (3, box3), (3, box4)]
)

# 方法2：链式合并
result1, _ = gmsh.model.occ.fuse([(3, box1)], [(3, box2)])
result2, _ = gmsh.model.occ.fuse(result1, [(3, box3)])
```

### 保留原实体

```python
# 默认会删除原实体
result, _ = gmsh.model.occ.fuse([(3, box1)], [(3, box2)])
# box1和box2被删除，只剩result

# 保留原实体
result, _ = gmsh.model.occ.fuse(
    [(3, box1)],
    [(3, box2)],
    removeObject=False,
    removeTool=False
)
# box1、box2和result都存在
```

## 差集 (Cut)

从一个实体中减去另一个。

```python
# cut(objectDimTags, toolDimTags, tag=-1, removeObject=True, removeTool=True)
# A - B：保留A中不与B重叠的部分

gmsh.initialize()
gmsh.model.add("cut_demo")

# 创建带孔的立方体
box = gmsh.model.occ.addBox(0, 0, 0, 1, 1, 1)
cylinder = gmsh.model.occ.addCylinder(0.5, 0.5, 0, 0, 0, 1, 0.2)

# 从立方体中挖出圆柱孔
result, map = gmsh.model.occ.cut([(3, box)], [(3, cylinder)])

gmsh.model.occ.synchronize()
gmsh.finalize()
```

### 多孔钻削

```python
# 创建多个孔
box = gmsh.model.occ.addBox(0, 0, 0, 2, 2, 1)
holes = []
for i in range(3):
    for j in range(3):
        cyl = gmsh.model.occ.addCylinder(0.3 + i*0.6, 0.3 + j*0.6, 0, 0, 0, 1, 0.1)
        holes.append((3, cyl))

# 一次性减去所有孔
result, _ = gmsh.model.occ.cut([(3, box)], holes)
```

### 差集顺序很重要

```python
# A - B ≠ B - A

# A - B：从A中减去B
result1, _ = gmsh.model.occ.cut([(3, box)], [(3, sphere)])

# B - A：从B中减去A
result2, _ = gmsh.model.occ.cut([(3, sphere)], [(3, box)])
```

## 交集 (Intersect)

取两个实体的公共部分。

```python
# intersect(objectDimTags, toolDimTags, tag=-1, removeObject=True, removeTool=True)
# A ∩ B：只保留重叠部分

gmsh.initialize()
gmsh.model.add("intersect_demo")

# 创建立方体和球的交集
box = gmsh.model.occ.addBox(0, 0, 0, 1, 1, 1)
sphere = gmsh.model.occ.addSphere(0.5, 0.5, 0.5, 0.7)

# 交集
result, map = gmsh.model.occ.intersect([(3, box)], [(3, sphere)])

gmsh.model.occ.synchronize()
gmsh.finalize()
```

### 多个实体的交集

```python
# 三个实体的交集
box = gmsh.model.occ.addBox(-0.5, -0.5, -0.5, 1, 1, 1)
cyl_x = gmsh.model.occ.addCylinder(-1, 0, 0, 2, 0, 0, 0.4)
cyl_y = gmsh.model.occ.addCylinder(0, -1, 0, 0, 2, 0, 0.4)

# 先求box和cyl_x的交集
temp, _ = gmsh.model.occ.intersect([(3, box)], [(3, cyl_x)])

# 再与cyl_y求交集
result, _ = gmsh.model.occ.intersect(temp, [(3, cyl_y)])
```

## 分片 (Fragment) - 最重要的运算

分片运算将重叠区域分割成多个共形部分，这对于多域问题至关重要。

```python
# fragment(objectDimTags, toolDimTags, tag=-1, removeObject=True, removeTool=True)
# 返回：(所有结果部分, 映射关系)

gmsh.initialize()
gmsh.model.add("fragment_demo")

# 创建两个重叠的盒子
box1 = gmsh.model.occ.addBox(0, 0, 0, 1, 1, 1)
box2 = gmsh.model.occ.addBox(0.5, 0, 0, 1, 1, 1)

# 分片
result, map = gmsh.model.occ.fragment([(3, box1)], [(3, box2)])

print(f"分片结果: {result}")
# 可能得到3个部分：左独占、重叠、右独占

gmsh.model.occ.synchronize()
gmsh.finalize()
```

### 为什么需要分片？

**不使用分片的问题**：

```
┌─────────┬─────────┐
│   A     │    B    │  两个独立网格
│ (网格1) │ (网格2) │  边界节点不共享
└─────────┴─────────┘
       ↑
    边界不连续
```

**使用分片后**：

```
┌─────────┬─────────┐
│   A     │    B    │  共形网格
│         │         │  边界节点完全匹配
└─────────┴─────────┘
       ↑
    节点共享
```

### 多域分片示例

```python
#!/usr/bin/env python3
"""
多材料域分片示例
创建三种材料的圆柱体
"""
import gmsh

gmsh.initialize()
gmsh.model.add("multi_material")

# 创建三个同心圆柱
inner = gmsh.model.occ.addCylinder(0, 0, 0, 0, 0, 1, 0.3, 1)   # 内层
middle = gmsh.model.occ.addCylinder(0, 0, 0, 0, 0, 1, 0.6, 2)  # 中层
outer = gmsh.model.occ.addCylinder(0, 0, 0, 0, 0, 1, 1.0, 3)   # 外层

# 分片：确保界面共形
result, map = gmsh.model.occ.fragment(
    [(3, inner), (3, middle)],
    [(3, outer)]
)

gmsh.model.occ.synchronize()

# 现在result包含3个不重叠的部分
# 它们的界面节点会自动匹配

# 根据位置或质心分类各部分
for dim, tag in result:
    if dim == 3:
        cx, cy, cz = gmsh.model.occ.getCenterOfMass(dim, tag)
        # 根据到轴线的距离分类
        radius = (cx**2 + cy**2)**0.5
        if radius < 0.2:
            gmsh.model.addPhysicalGroup(3, [tag], name="core")
        elif radius < 0.5:
            gmsh.model.addPhysicalGroup(3, [tag], name="middle")
        else:
            gmsh.model.addPhysicalGroup(3, [tag], name="outer")

gmsh.model.mesh.generate(3)
gmsh.write("multi_material.msh")
gmsh.finalize()
```

### 映射关系

fragment返回的map记录了原实体到结果的对应关系：

```python
result, map = gmsh.model.occ.fragment([(3, box1)], [(3, box2)])

# map是一个列表的列表
# map[i] 包含第i个输入实体产生的所有结果部分
# 输入顺序：先object，后tool

print(f"box1产生的部分: {map[0]}")  # 与box1重叠的所有结果
print(f"box2产生的部分: {map[1]}")  # 与box2重叠的所有结果
```

## 2D布尔运算

布尔运算也适用于2D实体：

```python
# 2D布尔运算
rect1 = gmsh.model.occ.addRectangle(0, 0, 0, 1, 1)
rect2 = gmsh.model.occ.addRectangle(0.5, 0.5, 0, 1, 1)

# 2D并集
result, _ = gmsh.model.occ.fuse([(2, rect1)], [(2, rect2)])

# 2D差集
circle = gmsh.model.occ.addDisk(0.5, 0.5, 0, 0.2, 0.2)
result, _ = gmsh.model.occ.cut([(2, rect1)], [(2, circle)])
```

## 混合维度布尔运算

可以在不同维度实体间进行布尔运算：

```python
# 用曲面切割体积
box = gmsh.model.occ.addBox(0, 0, 0, 1, 1, 1)
plane = gmsh.model.occ.addRectangle(0, 0, 0.5, 1, 1)  # z=0.5的平面

# 分片：将盒子切成两半
result, _ = gmsh.model.occ.fragment([(3, box)], [(2, plane)])
# 结果包含两个体积和一个曲面
```

## 布尔运算技巧

### 1. 确保实体重叠

```python
# 布尔运算需要实体有重叠区域才有效
# 检查包围盒是否重叠
def boxes_overlap(box1, box2):
    bb1 = gmsh.model.occ.getBoundingBox(3, box1)
    bb2 = gmsh.model.occ.getBoundingBox(3, box2)
    return not (bb1[3] < bb2[0] or bb2[3] < bb1[0] or
                bb1[4] < bb2[1] or bb2[4] < bb1[1] or
                bb1[5] < bb2[2] or bb2[5] < bb1[2])
```

### 2. 处理布尔运算失败

```python
try:
    result, _ = gmsh.model.occ.cut([(3, box)], [(3, tool)])
except Exception as e:
    print(f"布尔运算失败: {e}")
    # 尝试修复几何
    gmsh.model.occ.healShapes()
```

### 3. 避免薄壁问题

```python
# 布尔运算可能产生非常薄的区域，导致网格问题
# 使用公差设置
gmsh.option.setNumber("Geometry.OCCBooleanPreserveNumbering", 1)
gmsh.option.setNumber("Geometry.Tolerance", 1e-6)
```

## 完整示例：散热器

```python
#!/usr/bin/env python3
"""
使用布尔运算创建散热器模型
"""
import gmsh

gmsh.initialize()
gmsh.model.add("heatsink")

# 参数
base_length = 50
base_width = 50
base_height = 5
fin_count = 10
fin_height = 20
fin_thickness = 2
fin_gap = (base_width - fin_count * fin_thickness) / (fin_count + 1)

# 创建基座
base = gmsh.model.occ.addBox(0, 0, 0, base_length, base_width, base_height)

# 创建散热翅片
fins = []
for i in range(fin_count):
    y = fin_gap + i * (fin_thickness + fin_gap)
    fin = gmsh.model.occ.addBox(0, y, base_height, base_length, fin_thickness, fin_height)
    fins.append((3, fin))

# 合并基座和所有翅片
result, _ = gmsh.model.occ.fuse([(3, base)], fins)

# 在基座上创建安装孔
holes = []
hole_radius = 2
hole_positions = [
    (10, 10), (40, 10), (10, 40), (40, 40)
]
for x, y in hole_positions:
    hole = gmsh.model.occ.addCylinder(x, y, 0, 0, 0, base_height, hole_radius)
    holes.append((3, hole))

# 从散热器中挖出安装孔
result, _ = gmsh.model.occ.cut(result, holes)

gmsh.model.occ.synchronize()

# 定义物理组
volumes = gmsh.model.getEntities(3)
surfaces = gmsh.model.getEntities(2)
gmsh.model.addPhysicalGroup(3, [v[1] for v in volumes], name="heatsink")
gmsh.model.addPhysicalGroup(2, [s[1] for s in surfaces], name="surface")

# 网格设置
gmsh.option.setNumber("Mesh.MeshSizeMin", 0.5)
gmsh.option.setNumber("Mesh.MeshSizeMax", 3)

# 生成网格
gmsh.model.mesh.generate(3)

# 保存
gmsh.write("heatsink.msh")

# 可视化
# gmsh.fltk.run()

gmsh.finalize()
print("散热器模型创建完成！")
```

## 下一步

- [06-物理组定义](./06-物理组定义.md) - 学习如何定义物理组
