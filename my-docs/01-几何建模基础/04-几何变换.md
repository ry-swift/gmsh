# 几何变换

本文档介绍Gmsh中的几何变换操作，包括平移、旋转、缩放、镜像等。

## 变换概述

Gmsh支持的几何变换：

| 变换 | geo | occ | 描述 |
|-----|-----|-----|------|
| translate | ✅ | ✅ | 平移 |
| rotate | ✅ | ✅ | 旋转 |
| dilate | ✅ | ✅ | 缩放 |
| mirror | ✅ | ✅ | 镜像 |
| symmetrize | ✅ | ✅ | 对称化 |
| copy | ✅ | ✅ | 复制 |
| affineTransform | ❌ | ✅ | 仿射变换 |

## 平移 (Translate)

将实体沿指定方向移动。

```python
# translate(dimTags, dx, dy, dz)
# dimTags: 要变换的实体列表
# dx, dy, dz: 位移量

import gmsh

gmsh.initialize()
gmsh.model.add("translate_demo")

# 创建矩形
rect = gmsh.model.occ.addRectangle(0, 0, 0, 1, 1)
gmsh.model.occ.synchronize()

# 平移：X方向移动2
gmsh.model.occ.translate([(2, rect)], 2, 0, 0)
gmsh.model.occ.synchronize()

gmsh.finalize()
```

### 复制并平移

```python
# 先复制，再平移
original = gmsh.model.occ.addBox(0, 0, 0, 1, 1, 1)

# 复制
copied = gmsh.model.occ.copy([(3, original)])

# 平移副本
gmsh.model.occ.translate(copied, 2, 0, 0)

gmsh.model.occ.synchronize()
```

### 创建阵列

```python
# 线性阵列
def linear_array(dimTags, dx, dy, dz, count):
    """创建线性阵列"""
    all_copies = list(dimTags)
    for i in range(1, count):
        copies = gmsh.model.occ.copy(dimTags)
        gmsh.model.occ.translate(copies, dx * i, dy * i, dz * i)
        all_copies.extend(copies)
    return all_copies

# 使用
box = gmsh.model.occ.addBox(0, 0, 0, 0.5, 0.5, 0.5)
array = linear_array([(3, box)], 1, 0, 0, 5)  # 5个盒子，间距1
```

## 旋转 (Rotate)

绕轴旋转实体。

```python
# rotate(dimTags, x, y, z, ax, ay, az, angle)
# (x, y, z): 轴上的一点
# (ax, ay, az): 轴方向向量
# angle: 旋转角度（弧度）

import math

gmsh.initialize()
gmsh.model.add("rotate_demo")

# 创建矩形
rect = gmsh.model.occ.addRectangle(1, 0, 0, 1, 0.5)

# 绕Z轴（原点）旋转45度
gmsh.model.occ.rotate(
    [(2, rect)],
    0, 0, 0,       # 原点
    0, 0, 1,       # Z轴方向
    math.pi / 4    # 45度
)

gmsh.model.occ.synchronize()
gmsh.finalize()
```

### 绕任意轴旋转

```python
# 绕通过点(1,1,0)、方向(1,1,1)的轴旋转
gmsh.model.occ.rotate(
    [(3, box)],
    1, 1, 0,           # 轴上的点
    1, 1, 1,           # 轴方向（会自动归一化）
    math.pi / 6        # 30度
)
```

### 创建圆形阵列

```python
def circular_array(dimTags, cx, cy, cz, ax, ay, az, count):
    """创建圆形阵列"""
    all_copies = list(dimTags)
    angle_step = 2 * math.pi / count
    for i in range(1, count):
        copies = gmsh.model.occ.copy(dimTags)
        gmsh.model.occ.rotate(copies, cx, cy, cz, ax, ay, az, angle_step * i)
        all_copies.extend(copies)
    return all_copies

# 使用：绕Z轴创建6个盒子
box = gmsh.model.occ.addBox(2, 0, 0, 0.5, 0.5, 0.5)
array = circular_array([(3, box)], 0, 0, 0, 0, 0, 1, 6)
```

## 缩放 (Dilate)

以指定点为中心进行缩放。

```python
# dilate(dimTags, x, y, z, a, b, c)
# (x, y, z): 缩放中心
# (a, b, c): X、Y、Z方向的缩放因子

gmsh.initialize()
gmsh.model.add("dilate_demo")

box = gmsh.model.occ.addBox(0, 0, 0, 1, 1, 1)

# 均匀缩放：以原点为中心放大2倍
gmsh.model.occ.dilate([(3, box)], 0, 0, 0, 2, 2, 2)

gmsh.model.occ.synchronize()
gmsh.finalize()
```

### 非均匀缩放

```python
# X方向拉伸2倍，Y、Z保持
gmsh.model.occ.dilate([(3, box)], 0, 0, 0, 2, 1, 1)

# 压扁：Z方向压缩到0.5倍
gmsh.model.occ.dilate([(3, box)], 0, 0, 0, 1, 1, 0.5)
```

### 以质心为中心缩放

```python
# 获取质心
cx, cy, cz = gmsh.model.occ.getCenterOfMass(3, box)

# 以质心为中心缩放
gmsh.model.occ.dilate([(3, box)], cx, cy, cz, 1.5, 1.5, 1.5)
```

## 镜像 (Mirror)

关于平面镜像。

```python
# mirror(dimTags, a, b, c, d)
# 关于平面 ax + by + cz + d = 0 镜像

gmsh.initialize()
gmsh.model.add("mirror_demo")

box = gmsh.model.occ.addBox(1, 0, 0, 1, 1, 1)

# 关于YZ平面（x=0）镜像
# 平面方程：1*x + 0*y + 0*z + 0 = 0
gmsh.model.occ.mirror([(3, box)], 1, 0, 0, 0)

gmsh.model.occ.synchronize()
gmsh.finalize()
```

### 常见镜像平面

```python
# XY平面（z=0）
gmsh.model.occ.mirror(dimTags, 0, 0, 1, 0)

# XZ平面（y=0）
gmsh.model.occ.mirror(dimTags, 0, 1, 0, 0)

# YZ平面（x=0）
gmsh.model.occ.mirror(dimTags, 1, 0, 0, 0)

# x=2平面
# 方程：x - 2 = 0，即 1*x + 0*y + 0*z + (-2) = 0
gmsh.model.occ.mirror(dimTags, 1, 0, 0, -2)

# 45度斜面（过原点，法向量为(1,1,0)）
gmsh.model.occ.mirror(dimTags, 1, 1, 0, 0)
```

### 创建对称模型

```python
# 创建1/4模型，然后镜像得到完整模型
quarter = gmsh.model.occ.addBox(0, 0, 0, 1, 1, 1)

# 复制并沿X镜像
copy1 = gmsh.model.occ.copy([(3, quarter)])
gmsh.model.occ.mirror(copy1, 1, 0, 0, 0)

# 将两半合并
half, _ = gmsh.model.occ.fuse([(3, quarter)], copy1)

# 复制并沿Y镜像
copy2 = gmsh.model.occ.copy(half)
gmsh.model.occ.mirror(copy2, 0, 1, 0, 0)

# 合并得到完整模型
full, _ = gmsh.model.occ.fuse(half, copy2)
```

## 对称化 (Symmetrize)

与mirror类似，但修改原实体而不是创建新实体。

```python
# symmetrize(dimTags, a, b, c, d)
# 原地对称化

gmsh.model.occ.symmetrize([(3, box)], 1, 0, 0, 0)
```

## 复制 (Copy)

创建实体的副本。

```python
# copy(dimTags)
# 返回：复制后的dimTags

original = gmsh.model.occ.addBox(0, 0, 0, 1, 1, 1)

# 复制
copies = gmsh.model.occ.copy([(3, original)])
# copies = [(3, new_tag)]

# 可以一次复制多个实体
copies = gmsh.model.occ.copy([(3, 1), (3, 2), (2, 5)])
```

## 仿射变换 (Affine Transform) - 仅OCC

通用的仿射变换，可以实现任意线性变换加平移。

```python
# affineTransform(dimTags, a)
# a: 4x4变换矩阵的前12个元素（按行优先）
# [a11, a12, a13, a14]   [x]   [x']
# [a21, a22, a23, a24] × [y] = [y']
# [a31, a32, a33, a34]   [z]   [z']
#                        [1]

# 恒等变换
identity = [
    1, 0, 0, 0,  # 第一行
    0, 1, 0, 0,  # 第二行
    0, 0, 1, 0   # 第三行
]

# 平移(tx, ty, tz)
tx, ty, tz = 1, 2, 3
translate_matrix = [
    1, 0, 0, tx,
    0, 1, 0, ty,
    0, 0, 1, tz
]

# 绕Z轴旋转theta
import math
theta = math.pi / 4
rotate_z = [
    math.cos(theta), -math.sin(theta), 0, 0,
    math.sin(theta), math.cos(theta), 0, 0,
    0, 0, 1, 0
]

# 缩放(sx, sy, sz)
sx, sy, sz = 2, 1, 0.5
scale_matrix = [
    sx, 0, 0, 0,
    0, sy, 0, 0,
    0, 0, sz, 0
]

# 剪切变换
shear_xy = [
    1, 0.5, 0, 0,  # X随Y增加
    0, 1, 0, 0,
    0, 0, 1, 0
]

# 应用变换
gmsh.model.occ.affineTransform([(3, box)], rotate_z)
```

## 组合变换

通过矩阵乘法组合多个变换：

```python
import numpy as np

def combine_transforms(*matrices):
    """组合多个变换矩阵"""
    result = np.eye(4)
    for m in matrices:
        # 将12元素列表转为4x4矩阵
        mat = np.array([
            [m[0], m[1], m[2], m[3]],
            [m[4], m[5], m[6], m[7]],
            [m[8], m[9], m[10], m[11]],
            [0, 0, 0, 1]
        ])
        result = result @ mat
    # 返回前12个元素
    return list(result[:3].flatten())

# 使用：先旋转再平移
combined = combine_transforms(rotate_z, translate_matrix)
gmsh.model.occ.affineTransform([(3, box)], combined)
```

## 完整示例：齿轮外形

```python
#!/usr/bin/env python3
"""
使用几何变换创建齿轮外形
"""
import gmsh
import math

gmsh.initialize()
gmsh.model.add("gear")

# 参数
num_teeth = 20       # 齿数
outer_radius = 2.0   # 外径
inner_radius = 1.7   # 内径
tooth_width = 0.15   # 齿宽
center_hole = 0.5    # 中心孔半径

# 创建基本齿形（一个梯形）
angle_per_tooth = 2 * math.pi / num_teeth
half_tooth_angle = angle_per_tooth * tooth_width

# 齿的顶点
p1 = gmsh.model.occ.addPoint(
    inner_radius * math.cos(-half_tooth_angle),
    inner_radius * math.sin(-half_tooth_angle),
    0
)
p2 = gmsh.model.occ.addPoint(
    outer_radius * math.cos(-half_tooth_angle * 0.7),
    outer_radius * math.sin(-half_tooth_angle * 0.7),
    0
)
p3 = gmsh.model.occ.addPoint(
    outer_radius * math.cos(half_tooth_angle * 0.7),
    outer_radius * math.sin(half_tooth_angle * 0.7),
    0
)
p4 = gmsh.model.occ.addPoint(
    inner_radius * math.cos(half_tooth_angle),
    inner_radius * math.sin(half_tooth_angle),
    0
)

# 连接点形成一个齿
l1 = gmsh.model.occ.addLine(p1, p2)
l2 = gmsh.model.occ.addLine(p2, p3)
l3 = gmsh.model.occ.addLine(p3, p4)

# 圆弧连接相邻齿根
p_next = gmsh.model.occ.addPoint(
    inner_radius * math.cos(angle_per_tooth - half_tooth_angle),
    inner_radius * math.sin(angle_per_tooth - half_tooth_angle),
    0
)
p_center = gmsh.model.occ.addPoint(0, 0, 0)
arc_root = gmsh.model.occ.addCircleArc(p4, p_center, p_next)

# 创建所有齿（使用圆形阵列）
all_curves = [l1, l2, l3, arc_root]
for i in range(1, num_teeth):
    # 复制曲线
    curves_copy = gmsh.model.occ.copy([(1, l1), (1, l2), (1, l3), (1, arc_root)])
    # 旋转
    gmsh.model.occ.rotate(curves_copy, 0, 0, 0, 0, 0, 1, angle_per_tooth * i)
    all_curves.extend([c[1] for c in curves_copy])

# 创建曲线环
outer_loop = gmsh.model.occ.addCurveLoop(all_curves)

# 创建中心孔
hole = gmsh.model.occ.addDisk(0, 0, 0, center_hole, center_hole)
gmsh.model.occ.synchronize()
hole_loop = gmsh.model.occ.getCurveLoops(hole)[0]

# 创建齿轮面
gear_surface = gmsh.model.occ.addPlaneSurface([outer_loop, hole_loop])

# 拉伸成3D
thickness = 0.3
gear_volume = gmsh.model.occ.extrude([(2, gear_surface)], 0, 0, thickness)

gmsh.model.occ.synchronize()

# 网格设置
gmsh.option.setNumber("Mesh.MeshSizeMin", 0.05)
gmsh.option.setNumber("Mesh.MeshSizeMax", 0.2)

# 生成网格
gmsh.model.mesh.generate(3)

# 保存
gmsh.write("gear.msh")

# 可视化
# gmsh.fltk.run()

gmsh.finalize()
print("齿轮模型创建完成！")
```

## 下一步

- [05-布尔运算](./05-布尔运算.md) - 学习布尔运算的详细用法
