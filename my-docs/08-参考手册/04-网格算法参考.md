# 网格算法参考

本节详细介绍Gmsh中可用的各种网格生成算法，包括2D和3D算法的特点、适用场景和参数设置。

## 2D网格算法

### 算法选择

通过选项 `Mesh.Algorithm` 设置2D网格算法：

```python
import gmsh

gmsh.initialize()

# 设置2D网格算法
gmsh.option.setNumber("Mesh.Algorithm", algorithm_code)
```

### 算法列表

| 代码 | 名称 | 描述 |
|------|------|------|
| 1 | MeshAdapt | 自适应网格（默认） |
| 2 | Automatic | 自动选择（实验性） |
| 3 | Initial mesh only | 仅初始网格 |
| 5 | Delaunay | Delaunay三角化 |
| 6 | Frontal-Delaunay | 前沿Delaunay（推荐） |
| 7 | BAMG | 双向各向异性网格生成器 |
| 8 | Frontal-Delaunay for Quads | 前沿Delaunay（四边形） |
| 9 | Packing of Parallelograms | 平行四边形填充 |
| 11 | Quasi-structured Quad | 准结构化四边形 |

### 算法详解

#### MeshAdapt (1)

自适应网格算法，能够很好地处理复杂几何。

**特点：**
- 对边界曲率敏感
- 生成高质量三角形
- 适合复杂几何

**参数：**
```python
# 曲率自适应
gmsh.option.setNumber("Mesh.MeshSizeFromCurvature", 20)  # 每弧度单元数
```

#### Delaunay (5)

经典Delaunay三角化算法。

**特点：**
- 速度快
- 最大化最小角
- 适合简单几何

**参数：**
```python
gmsh.option.setNumber("Mesh.Algorithm", 5)
# 无额外参数
```

#### Frontal-Delaunay (6)

结合前沿推进和Delaunay三角化的混合算法。

**特点：**
- 最佳综合性能
- 边界层质量好
- 推荐作为默认选择

**参数：**
```python
gmsh.option.setNumber("Mesh.Algorithm", 6)
gmsh.option.setNumber("Mesh.AnisoMax", 1000)  # 最大各向异性比
```

#### BAMG (7)

双向各向异性网格生成器，专为各向异性网格优化。

**特点：**
- 优秀的各向异性支持
- 适合边界层
- 支持度量张量

**参数：**
```python
gmsh.option.setNumber("Mesh.Algorithm", 7)
gmsh.option.setNumber("Mesh.SmoothRatio", 2.0)  # 光滑比率
```

#### Frontal-Delaunay for Quads (8)

专门生成四边形网格的前沿算法。

**特点：**
- 生成主导四边形
- 边界对齐
- 需要重组选项

**参数：**
```python
gmsh.option.setNumber("Mesh.Algorithm", 8)
gmsh.option.setNumber("Mesh.RecombineAll", 1)
gmsh.option.setNumber("Mesh.RecombinationAlgorithm", 1)
```

#### Packing of Parallelograms (9)

通过平行四边形填充生成结构化类网格。

**特点：**
- 高度结构化
- 适合简单几何
- 较少的非结构化单元

**参数：**
```python
gmsh.option.setNumber("Mesh.Algorithm", 9)
gmsh.option.setNumber("Mesh.SubdivisionAlgorithm", 1)  # 全四边形
```

## 3D网格算法

### 算法选择

通过选项 `Mesh.Algorithm3D` 设置3D网格算法：

```python
gmsh.option.setNumber("Mesh.Algorithm3D", algorithm_code)
```

### 算法列表

| 代码 | 名称 | 描述 |
|------|------|------|
| 1 | Delaunay | Delaunay四面体化（默认） |
| 3 | Initial mesh only | 仅初始网格 |
| 4 | Frontal | 前沿推进 |
| 7 | MMG3D | MMG3D重网格 |
| 9 | R-tree | R树优化 |
| 10 | HXT | 并行Delaunay |

### 算法详解

#### Delaunay (1)

标准Delaunay四面体化算法。

**特点：**
- 稳定可靠
- 适合大多数情况
- 单线程

**参数：**
```python
gmsh.option.setNumber("Mesh.Algorithm3D", 1)
gmsh.option.setNumber("Mesh.OptimizeNetgen", 1)  # 使用Netgen优化
```

#### Frontal (4)

前沿推进算法，从表面向内生成网格。

**特点：**
- 边界质量好
- 层状结构
- 较慢

**参数：**
```python
gmsh.option.setNumber("Mesh.Algorithm3D", 4)
gmsh.option.setNumber("Mesh.Smoothing", 10)  # 光滑迭代
```

#### HXT (10)

高性能并行Delaunay算法。

**特点：**
- 多线程并行
- 速度极快
- 适合大规模网格

**参数：**
```python
gmsh.option.setNumber("Mesh.Algorithm3D", 10)
gmsh.option.setNumber("General.NumThreads", 8)  # 线程数
gmsh.option.setNumber("Mesh.MaxNumThreads3D", 8)
```

## 网格重组算法

### 四边形重组

将三角形重组为四边形：

```python
# 重组算法选择
gmsh.option.setNumber("Mesh.RecombinationAlgorithm", code)
```

| 代码 | 名称 | 描述 |
|------|------|------|
| 0 | Simple | 简单重组 |
| 1 | Blossom | Blossom算法（推荐） |
| 2 | Simple full-quad | 简单全四边形 |
| 3 | Blossom full-quad | Blossom全四边形 |

### 示例

```python
import gmsh

gmsh.initialize()
gmsh.model.add("quad_mesh")

# 创建几何
gmsh.model.occ.addRectangle(0, 0, 0, 10, 10)
gmsh.model.occ.synchronize()

# 设置算法
gmsh.option.setNumber("Mesh.Algorithm", 8)  # 前沿四边形
gmsh.option.setNumber("Mesh.RecombineAll", 1)
gmsh.option.setNumber("Mesh.RecombinationAlgorithm", 1)  # Blossom

# 生成网格
gmsh.model.mesh.generate(2)

# 统计
elem_types, elem_tags, _ = gmsh.model.mesh.getElements(2)
for i, etype in enumerate(elem_types):
    props = gmsh.model.mesh.getElementProperties(etype)
    print(f"{props[0]}: {len(elem_tags[i])}")

gmsh.write("quad_mesh.msh")
gmsh.finalize()
```

### 六面体重组

将四面体重组为六面体：

```python
gmsh.option.setNumber("Mesh.SubdivisionAlgorithm", code)
```

| 代码 | 描述 |
|------|------|
| 0 | 无细分 |
| 1 | 全六面体（四面体细分） |
| 2 | 全六面体（棱柱/六面体细分） |

## 网格优化算法

### 优化方法

通过 `gmsh.model.mesh.optimize()` 调用：

```python
gmsh.model.mesh.optimize(method, force=False, niter=1, dimTags=[])
```

| 方法 | 描述 |
|------|------|
| `"Netgen"` | Netgen优化器 |
| `"HighOrder"` | 高阶网格优化 |
| `"HighOrderElastic"` | 弹性高阶优化 |
| `"HighOrderFastCurving"` | 快速曲面优化 |
| `"Laplace2D"` | 2D拉普拉斯光滑 |
| `"Relocate2D"` | 2D节点重定位 |
| `"Relocate3D"` | 3D节点重定位 |

### 示例

```python
import gmsh

gmsh.initialize()
gmsh.model.add("optimize")

gmsh.model.occ.addSphere(0, 0, 0, 1)
gmsh.model.occ.synchronize()

# 生成初始网格
gmsh.model.mesh.generate(3)

# 多次优化
for i in range(3):
    gmsh.model.mesh.optimize("Netgen")

# 高阶网格优化
gmsh.model.mesh.setOrder(2)
gmsh.model.mesh.optimize("HighOrder")

gmsh.finalize()
```

### 优化选项

```python
# 光滑迭代次数
gmsh.option.setNumber("Mesh.Smoothing", 10)

# 优化阈值
gmsh.option.setNumber("Mesh.OptimizeThreshold", 0.3)

# Lloyd优化
gmsh.option.setNumber("Mesh.Lloyd", 1)
```

## 结构化网格（Transfinite）

### 曲线设置

```python
gmsh.model.mesh.setTransfiniteCurve(tag, numNodes, meshType, coef)
```

| meshType | 描述 |
|----------|------|
| `"Progression"` | 几何级数 |
| `"Bump"` | 两端密中间疏 |
| `"Beta"` | Beta分布 |

### 示例

```python
import gmsh

gmsh.initialize()
gmsh.model.add("transfinite")

# 创建矩形
p1 = gmsh.model.geo.addPoint(0, 0, 0)
p2 = gmsh.model.geo.addPoint(1, 0, 0)
p3 = gmsh.model.geo.addPoint(1, 1, 0)
p4 = gmsh.model.geo.addPoint(0, 1, 0)

l1 = gmsh.model.geo.addLine(p1, p2)
l2 = gmsh.model.geo.addLine(p2, p3)
l3 = gmsh.model.geo.addLine(p3, p4)
l4 = gmsh.model.geo.addLine(p4, p1)

loop = gmsh.model.geo.addCurveLoop([l1, l2, l3, l4])
surf = gmsh.model.geo.addPlaneSurface([loop])

gmsh.model.geo.synchronize()

# 设置Transfinite
gmsh.model.mesh.setTransfiniteCurve(l1, 20, "Progression", 1.1)
gmsh.model.mesh.setTransfiniteCurve(l2, 15, "Progression", 1.0)
gmsh.model.mesh.setTransfiniteCurve(l3, 20, "Progression", 1/1.1)
gmsh.model.mesh.setTransfiniteCurve(l4, 15, "Progression", 1.0)

gmsh.model.mesh.setTransfiniteSurface(surf, "Left", [p1, p2, p3, p4])
gmsh.model.mesh.setRecombine(2, surf)

gmsh.model.mesh.generate(2)

gmsh.finalize()
```

## 边界层算法

### ExtrudeBoundaryLayer

通过拉伸生成边界层：

```python
# 在geo内核中
gmsh.model.geo.extrudeBoundaryLayer(
    dimTags,
    numElements=[10],
    heights=[0.1],
    recombine=True
)
```

### BoundaryLayer尺寸场

```python
# 添加边界层场
gmsh.model.mesh.field.add("BoundaryLayer", 1)

# 设置参数
gmsh.model.mesh.field.setNumbers(1, "CurvesList", [1, 2, 3])  # 边界曲线
gmsh.model.mesh.field.setNumber(1, "Size", 0.01)  # 第一层高度
gmsh.model.mesh.field.setNumber(1, "Ratio", 1.2)  # 增长率
gmsh.model.mesh.field.setNumber(1, "NbLayers", 10)  # 层数
gmsh.model.mesh.field.setNumber(1, "Quads", 1)  # 生成四边形
gmsh.model.mesh.field.setNumber(1, "IntersectMetrics", 0)

# 设置扇形单元（前后缘）
gmsh.option.setNumber("Mesh.BoundaryLayerFanElements", 5)
```

### 示例

```python
import gmsh

gmsh.initialize()
gmsh.model.add("boundary_layer")

# 圆柱流场
cylinder = gmsh.model.occ.addCylinder(0, 0, 0, 10, 0, 0, 0.5)
box = gmsh.model.occ.addBox(-2, -2, -2, 14, 4, 4)
fluid = gmsh.model.occ.cut([(3, box)], [(3, cylinder)])

gmsh.model.occ.synchronize()

# 获取圆柱表面
surfaces = gmsh.model.getEntities(2)
cylinder_surfs = []
for dim, tag in surfaces:
    com = gmsh.model.occ.getCenterOfMass(dim, tag)
    if abs(com[1]**2 + com[2]**2) < 1:
        cylinder_surfs.append(tag)

# 边界层场
gmsh.model.mesh.field.add("BoundaryLayer", 1)
gmsh.model.mesh.field.setNumbers(1, "SurfacesList", cylinder_surfs)
gmsh.model.mesh.field.setNumber(1, "Size", 0.01)
gmsh.model.mesh.field.setNumber(1, "Ratio", 1.3)
gmsh.model.mesh.field.setNumber(1, "NbLayers", 8)

gmsh.model.mesh.generate(3)

gmsh.finalize()
```

## 尺寸场算法

### 常用尺寸场

| 场类型 | 描述 |
|--------|------|
| `Distance` | 到几何实体的距离 |
| `Threshold` | 基于距离的阈值函数 |
| `Box` | 盒子区域 |
| `Cylinder` | 圆柱区域 |
| `Ball` | 球形区域 |
| `MathEval` | 数学表达式 |
| `PostView` | 从后处理视图 |
| `Min` | 多场最小值 |
| `Max` | 多场最大值 |
| `Restrict` | 限制到特定实体 |

### Distance场

```python
gmsh.model.mesh.field.add("Distance", 1)
gmsh.model.mesh.field.setNumbers(1, "CurvesList", [1, 2])  # 或
gmsh.model.mesh.field.setNumbers(1, "SurfacesList", [1])    # 或
gmsh.model.mesh.field.setNumbers(1, "PointsList", [1, 2, 3])
gmsh.model.mesh.field.setNumber(1, "Sampling", 100)  # 采样点数
```

### Threshold场

```python
gmsh.model.mesh.field.add("Threshold", 2)
gmsh.model.mesh.field.setNumber(2, "InField", 1)  # 输入场
gmsh.model.mesh.field.setNumber(2, "SizeMin", 0.01)
gmsh.model.mesh.field.setNumber(2, "SizeMax", 0.1)
gmsh.model.mesh.field.setNumber(2, "DistMin", 0)
gmsh.model.mesh.field.setNumber(2, "DistMax", 1)
gmsh.model.mesh.field.setNumber(2, "StopAtDistMax", 1)
gmsh.model.mesh.field.setNumber(2, "Sigmoid", 0)  # 1=平滑过渡
```

### MathEval场

```python
gmsh.model.mesh.field.add("MathEval", 1)
# 使用x, y, z作为变量
gmsh.model.mesh.field.setString(1, "F", "0.1 + 0.05*sin(10*x)")
```

### 组合场

```python
# 创建多个场
gmsh.model.mesh.field.add("Box", 1)
gmsh.model.mesh.field.setNumber(1, "VIn", 0.01)
gmsh.model.mesh.field.setNumber(1, "VOut", 0.1)
# ... 设置Box参数

gmsh.model.mesh.field.add("Cylinder", 2)
# ... 设置Cylinder参数

# 取最小值
gmsh.model.mesh.field.add("Min", 3)
gmsh.model.mesh.field.setNumbers(3, "FieldsList", [1, 2])

# 设置为背景网格
gmsh.model.mesh.field.setAsBackgroundMesh(3)
```

## 算法选择指南

### 2D网格

| 需求 | 推荐算法 |
|------|---------|
| 一般用途 | Frontal-Delaunay (6) |
| 速度优先 | Delaunay (5) |
| 各向异性 | BAMG (7) |
| 四边形网格 | Frontal-Delaunay for Quads (8) |
| 结构化类 | Packing of Parallelograms (9) |

### 3D网格

| 需求 | 推荐算法 |
|------|---------|
| 一般用途 | Delaunay (1) |
| 大规模并行 | HXT (10) |
| 边界质量 | Frontal (4) |

### 优化策略

```python
# 完整优化流程
gmsh.model.mesh.generate(3)

# 多次Netgen优化
for _ in range(3):
    gmsh.model.mesh.optimize("Netgen")

# 如果是高阶网格
gmsh.model.mesh.setOrder(2)
gmsh.model.mesh.optimize("HighOrder")
```

## 性能对比

### 2D算法性能（参考）

| 算法 | 相对速度 | 质量 | 各向异性支持 |
|------|---------|------|-------------|
| Delaunay | ★★★★★ | ★★★☆☆ | ★★☆☆☆ |
| Frontal-Delaunay | ★★★★☆ | ★★★★☆ | ★★★☆☆ |
| BAMG | ★★★☆☆ | ★★★★☆ | ★★★★★ |
| MeshAdapt | ★★★☆☆ | ★★★★★ | ★★★☆☆ |

### 3D算法性能（参考）

| 算法 | 相对速度 | 质量 | 并行支持 |
|------|---------|------|---------|
| Delaunay | ★★★☆☆ | ★★★★☆ | ★☆☆☆☆ |
| Frontal | ★★☆☆☆ | ★★★★★ | ★☆☆☆☆ |
| HXT | ★★★★★ | ★★★☆☆ | ★★★★★ |

## 小结

本节介绍了Gmsh的网格算法：

1. **2D算法**：Delaunay、Frontal-Delaunay、BAMG等
2. **3D算法**：Delaunay、Frontal、HXT
3. **重组算法**：三角形→四边形，四面体→六面体
4. **优化算法**：Netgen、高阶优化、拉普拉斯光滑
5. **结构化网格**：Transfinite设置
6. **边界层**：ExtrudeBoundaryLayer、BoundaryLayer场
7. **尺寸场**：Distance、Threshold、Box等

选择算法时需考虑：
- 网格质量要求
- 计算效率
- 几何复杂度
- 是否需要各向异性/边界层
