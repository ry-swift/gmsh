# NCollection_BaseMap 类深度解析

## 0. 设计背景与动机（为什么需要这个类？）

### 0.1 问题背景

OpenCASCADE 作为一个 CAD 内核，需要处理大量的几何和拓扑数据。在这个过程中，频繁需要：

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        CAD 应用中的典型数据关联需求                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  需求1: 快速查找                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  "这个顶点 Vertex 属于哪条边 Edge？"                                  │    │
│  │  "这个面 Face 的法向量是多少？"                                       │    │
│  │  "ID=12345 的形状是哪个？"                                           │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                             │
│  需求2: 双向映射                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  "Shape A 对应索引 5" ──────► 正向查找                                │    │
│  │  "索引 5 对应 Shape A" ◄────── 反向查找                               │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                             │
│  需求3: 去重集合                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  "收集所有访问过的顶点（不重复）"                                      │    │
│  │  "记录所有已处理的边"                                                 │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 0.2 没有 NCollection_BaseMap 之前的问题

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           问题：代码重复膨胀                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│    如果没有基类，每种 Map 都要独立实现：                                      │
│                                                                             │
│    ┌──────────────────┐  ┌──────────────────┐  ┌──────────────────┐        │
│    │   Map 实现       │  │  DataMap 实现    │  │  DoubleMap 实现  │        │
│    ├──────────────────┤  ├──────────────────┤  ├──────────────────┤        │
│    │ - 哈希表逻辑     │  │ - 哈希表逻辑     │  │ - 哈希表逻辑     │        │
│    │ - 扩容逻辑       │  │ - 扩容逻辑       │  │ - 扩容逻辑       │        │
│    │ - 迭代器逻辑     │  │ - 迭代器逻辑     │  │ - 迭代器逻辑     │        │
│    │ - 内存管理       │  │ - 内存管理       │  │ - 内存管理       │        │
│    │ - 统计功能       │  │ - 统计功能       │  │ - 统计功能       │        │
│    └────────┬─────────┘  └────────┬─────────┘  └────────┬─────────┘        │
│             │                     │                     │                  │
│             └─────────────────────┼─────────────────────┘                  │
│                                   │                                        │
│                                   ▼                                        │
│                    ┌──────────────────────────────┐                        │
│                    │  ❌ 大量重复代码              │                        │
│                    │  ❌ 维护困难                  │                        │
│                    │  ❌ Bug 修复要改多处          │                        │
│                    │  ❌ 不一致风险                │                        │
│                    └──────────────────────────────┘                        │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 0.3 解决方案：抽象基类设计

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        NCollection_BaseMap 设计思路                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│                      ┌─────────────────────────────┐                        │
│                      │   NCollection_BaseMap       │                        │
│                      │   (抽象基类)                │                        │
│                      ├─────────────────────────────┤                        │
│                      │ ✓ 哈希表桶管理              │                        │
│                      │ ✓ 扩容/缩容机制             │                        │
│                      │ ✓ 迭代器基础实现            │                        │
│                      │ ✓ 内存分配器管理            │                        │
│                      │ ✓ 统计功能                  │                        │
│                      │ ✓ 素数桶计算                │                        │
│                      └──────────────┬──────────────┘                        │
│                                     │                                       │
│              ┌──────────────────────┼──────────────────────┐                │
│              │                      │                      │                │
│              ▼                      ▼                      ▼                │
│    ┌─────────────────┐   ┌─────────────────┐   ┌─────────────────┐          │
│    │  NCollection_   │   │  NCollection_   │   │  NCollection_   │          │
│    │     Map         │   │    DataMap      │   │   DoubleMap     │          │
│    ├─────────────────┤   ├─────────────────┤   ├─────────────────┤          │
│    │ 只需实现:       │   │ 只需实现:       │   │ 只需实现:       │          │
│    │ - 节点结构      │   │ - 节点结构      │   │ - 节点结构      │          │
│    │ - Bind/Find     │   │ - Bind/Find     │   │ - Bind1/Find1   │          │
│    │                 │   │ - ChangeFind    │   │ - Bind2/Find2   │          │
│    └─────────────────┘   └─────────────────┘   └─────────────────┘          │
│                                                                             │
│    ✓ 共享基类实现，消除代码重复                                              │
│    ✓ 统一的内存管理策略                                                      │
│    ✓ 一致的性能特性                                                          │
│    ✓ Bug 修复只需改一处                                                      │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 0.4 为什么选择「链地址法」而非「开放寻址法」？

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          哈希冲突解决策略对比                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  方案A: 开放寻址法 (Open Addressing)                                         │
│  ────────────────────────────────────                                        │
│  ┌───┬───┬───┬───┬───┬───┬───┬───┐                                         │
│  │ A │   │ B │ C │   │ D │   │   │   冲突时找下一个空位                      │
│  └───┴───┴───┴───┴───┴───┴───┴───┘                                         │
│                                                                             │
│  优点: 内存连续，缓存友好                                                     │
│  缺点: ❌ 删除操作复杂（需要墓碑标记）                                        │
│        ❌ 负载因子敏感（>0.7 性能急剧下降）                                   │
│        ❌ 聚集问题（冲突会连锁）                                              │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════    │
│                                                                             │
│  方案B: 链地址法 (Separate Chaining) ← NCollection_BaseMap 的选择            │
│  ───────────────────────────────────                                         │
│  ┌───┐                                                                      │
│  │ 0 │──► nullptr                                                           │
│  ├───┤                                                                      │
│  │ 1 │──► [A] ──► [B] ──► nullptr     冲突时加入链表                         │
│  ├───┤                                                                      │
│  │ 2 │──► [C] ──► nullptr                                                   │
│  ├───┤                                                                      │
│  │ 3 │──► nullptr                                                           │
│  └───┘                                                                      │
│                                                                             │
│  优点: ✓ 删除操作简单（链表删除）                                             │
│        ✓ 对负载因子不敏感                                                    │
│        ✓ 实现简单，不易出错                                                  │
│        ✓ 适合存储大对象指针                                                  │
│  缺点: 需要额外的指针空间                                                     │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│                        CAD 场景下链地址法更合适的原因                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  1. CAD 数据特点:                                                            │
│     ┌──────────────────────────────────────────────────────────────────┐    │
│     │  • 对象较大（Shape、Geometry 等复杂对象）                          │    │
│     │  • 频繁的增删操作（建模过程中不断修改）                            │    │
│     │  • 需要稳定的指针（外部可能持有引用）                              │    │
│     └──────────────────────────────────────────────────────────────────┘    │
│                                                                             │
│  2. 链地址法的优势匹配:                                                       │
│     ┌──────────────────────────────────────────────────────────────────┐    │
│     │  • 删除不影响其他元素位置  ──► 指针稳定                           │    │
│     │  • 扩容时只需重新链接      ──► 无需移动数据                       │    │
│     │  • 负载因子可超过 1        ──► 更灵活的内存使用                   │    │
│     └──────────────────────────────────────────────────────────────────┘    │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 0.4.1 什么是「负载因子敏感」？

**负载因子 (Load Factor)** = 已存储元素数 / 桶总数

```
例如: 桶数 = 10, 已存 7 个元素
      负载因子 = 7/10 = 0.7
```

**开放寻址法为什么对负载因子敏感？**

```text
┌─────────────────────────────────────────────────────────────────────────────┐
│                    开放寻址法：冲突时找下一个空位                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  负载因子 = 0.3 (空位多)                                                     │
│  ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐                                 │
│  │ A │   │   │ B │   │   │ C │   │   │   │                                 │
│  └───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘                                 │
│                                                                             │
│  插入新元素: 很快找到空位 ✓                                                   │
│  查找元素:   平均探测 1-2 次 ✓                                               │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════    │
│                                                                             │
│  负载因子 = 0.7 (空位少)                                                     │
│  ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐                                 │
│  │ A │ B │ C │ D │   │ E │ F │ G │   │   │                                 │
│  └───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘                                 │
│                                                                             │
│  插入新元素: 可能要探测多次才能找到空位                                        │
│  查找元素:   平均探测 3-5 次                                                  │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════    │
│                                                                             │
│  负载因子 = 0.9 (几乎满了) ❌                                                 │
│  ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐                                 │
│  │ A │ B │ C │ D │ E │ F │ G │ H │ I │   │  只剩 1 个空位！                  │
│  └───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘                                 │
│                                                                             │
│  插入新元素: 可能要探测 9 次才能找到空位！                                     │
│  查找元素:   最差要遍历整个表 → O(n) 退化                                     │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

**性能曲线图:**

```text
平均探测次数
    │
  10│                                    ╱
    │                                  ╱
   8│                                ╱
    │                              ╱
   6│                           ╱
    │                        ╱
   4│                    ╱───── 性能急剧下降！
    │                ╱
   2│        ────────
    │────────
   0└─────────────────────────────────────► 负载因子
    0     0.3     0.5     0.7     0.9   1.0
                          ▲
                     临界点（0.7）
```

#### 0.4.2 什么是「聚集问题」(Clustering)？

聚集是指：**一个冲突会导致后续更多的冲突，形成恶性循环**

```text
┌─────────────────────────────────────────────────────────────────────────────┐
│                           聚集问题演示                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  初始状态: 插入 A，哈希值 = 2                                                │
│  ┌───┬───┬───┬───┬───┬───┬───┬───┐                                         │
│  │   │   │ A │   │   │   │   │   │                                         │
│  └───┴───┴───┴───┴───┴───┴───┴───┘                                         │
│            ▲                                                                │
│         位置2                                                               │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════    │
│                                                                             │
│  插入 B，哈希值 = 2 (冲突！)                                                 │
│  ┌───┬───┬───┬───┬───┬───┬───┬───┐                                         │
│  │   │   │ A │ B │   │   │   │   │   B 被放到位置 3                         │
│  └───┴───┴───┴───┴───┴───┴───┴───┘                                         │
│            ▲   ▲                                                            │
│         冲突  探测                                                           │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════    │
│                                                                             │
│  插入 C，哈希值 = 3 (本来没冲突，但位置 3 被 B 占了！)                         │
│  ┌───┬───┬───┬───┬───┬───┬───┬───┐                                         │
│  │   │   │ A │ B │ C │   │   │   │   C 被放到位置 4                         │
│  └───┴───┴───┴───┴───┴───┴───┴───┘                                         │
│            └───┴───┴───┘                                                    │
│              聚集形成！                                                       │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════    │
│                                                                             │
│  插入 D，哈希值 = 2, 3, 或 4 都会撞到这个聚集块！                              │
│  ┌───┬───┬───┬───┬───┬───┬───┬───┐                                         │
│  │   │   │ A │ B │ C │ D │   │   │   连锁效应：聚集越来越大                  │
│  └───┴───┴───┴───┴───┴───┴───┴───┘                                         │
│            └───────────────┘                                                │
│               聚集块增长                                                      │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

**为什么叫"连锁"反应？**

```text
┌─────────────────────────────────────────────────────────────────────────────┐
│                           聚集的恶性循环                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│      ┌──────────────────┐                                                   │
│      │  元素哈希到聚集块  │                                                   │
│      └────────┬─────────┘                                                   │
│               │                                                             │
│               ▼                                                             │
│      ┌──────────────────┐                                                   │
│      │  被迫放到块的末尾  │                                                   │
│      └────────┬─────────┘                                                   │
│               │                                                             │
│               ▼                                                             │
│      ┌──────────────────┐                                                   │
│      │   聚集块变大      │                                                   │
│      └────────┬─────────┘                                                   │
│               │                                                             │
│               ▼                                                             │
│      ┌──────────────────┐                                                   │
│      │ 更多元素会撞到块  │───────────┐                                       │
│      └──────────────────┘           │                                       │
│               ▲                     │                                       │
│               └─────────────────────┘                                       │
│                    恶性循环！                                                │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 0.4.3 链地址法为什么没有这些问题？

```text
┌─────────────────────────────────────────────────────────────────────────────┐
│                    链地址法为什么不怕这两个问题？                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  1. 负载因子可以超过 1.0                                                      │
│     ────────────────────                                                     │
│     ┌───┐                                                                   │
│     │ 0 │──► [A] ──► [B] ──► [C] ──► nullptr                               │
│     ├───┤                                                                   │
│     │ 1 │──► [D] ──► [E] ──► nullptr                                       │
│     ├───┤                                                                   │
│     │ 2 │──► [F] ──► nullptr                                               │
│     └───┘                                                                   │
│                                                                             │
│     桶数 = 3, 元素数 = 6, 负载因子 = 2.0  ✓ 完全可以工作！                   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════    │
│                                                                             │
│  2. 不存在聚集问题                                                            │
│     ──────────────                                                           │
│     每个元素只会落在自己的桶里，不会占用其他桶的位置                            │
│     冲突只影响同一个桶内的链表长度，不会连锁到其他桶                            │
│                                                                             │
│     桶 2 的冲突 ──────► 只影响桶 2 的链表                                     │
│                        不影响桶 3, 4, 5...                                   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 0.4.4 两种方法对比总结

| 问题 | 含义 | 开放寻址法 | 链地址法 |
| ---- | ---- | ---------- | -------- |
| 负载因子敏感 | 表快满时性能急剧下降 | ❌ >0.7 就很慢 | ✓ 可以超过1.0 |
| 聚集问题 | 冲突导致元素扎堆，形成恶性循环 | ❌ 严重 | ✓ 不存在 |
| 删除操作 | 从表中移除元素 | ❌ 需要墓碑标记 | ✓ 链表删除简单 |
| 内存布局 | 数据在内存中的分布 | ✓ 连续，缓存友好 | ❌ 分散，需要指针 |

**结论**: 对于 CAD 应用场景（频繁增删、对象大、需要稳定指针），链地址法是更好的选择。

---

### 0.5 为什么需要两个桶数组 (myData1, myData2)？

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                            双桶设计解决的问题                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  场景: IndexedMap - 需要同时支持两种查询                                      │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                                                                     │    │
│  │   查询1: "给定 Shape，它的索引是多少？"                              │    │
│  │          FindIndex(myShape)  ──────────────────► Index = 5          │    │
│  │                                                                     │    │
│  │   查询2: "给定索引 5，对应的 Shape 是哪个？"                          │    │
│  │          FindKey(5)  ──────────────────────────► myShape            │    │
│  │                                                                     │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                             │
│  ════════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  如果只有一个桶数组 (单向索引):                                               │
│                                                                             │
│    myData1 (按 Shape 哈希)                                                   │
│    ┌───┐                                                                    │
│    │ 0 │──► nullptr                                                         │
│    ├───┤                                                                    │
│    │ 1 │──► [Shape_A, idx=5] ──► [Shape_B, idx=12]                          │
│    ├───┤                                                                    │
│    │...│                                                                    │
│    └───┘                                                                    │
│                                                                             │
│    FindIndex(Shape_A) = O(1)  ✓ 快速                                        │
│    FindKey(5) = O(n)          ❌ 需要遍历所有节点！                           │
│                                                                             │
│  ════════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  使用两个桶数组 (双向索引):                                                   │
│                                                                             │
│    myData1 (按 Shape 哈希)              myData2 (按 Index 哈希)              │
│    ┌───┐                                ┌───┐                               │
│    │ 0 │──► nullptr                     │ 0 │──► nullptr                    │
│    ├───┤                                ├───┤                               │
│    │ 1 │──► [Shape_A, idx=5]           │ 5 │──► [Shape_A, idx=5]           │
│    ├───┤         ▲                      └───┘         ▲                     │
│    │...│         │                                    │                     │
│    └───┘         └────────────────────────────────────┘                     │
│                           同一个节点被两个桶引用                              │
│                                                                             │
│    FindIndex(Shape_A) = O(1)  ✓ 通过 myData1 查找                           │
│    FindKey(5) = O(1)          ✓ 通过 myData2 查找                           │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 0.6 为什么禁止拷贝？

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              禁止拷贝的设计考量                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  问题场景:                                                                   │
│  ─────────                                                                   │
│  void processMap(NCollection_DataMap<Key, Value> map) {  // 值传递          │
│      // 如果允许拷贝，这里会发生深拷贝                                        │
│      // 对于百万级元素的 Map，这是灾难性的性能问题                            │
│  }                                                                          │
│                                                                             │
│  ════════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  深拷贝的代价:                                                               │
│  ─────────────                                                               │
│                                                                             │
│  原始 Map (100万元素)                    拷贝后                              │
│  ┌─────────────────────┐                ┌─────────────────────┐             │
│  │  myData1[0..N]      │───复制桶数组──►│  myData1[0..N]      │             │
│  │  ┌─────┐            │                │  ┌─────┐            │             │
│  │  │NodeA│            │───复制节点────►│  │NodeA'│           │             │
│  │  │NodeB│            │───复制节点────►│  │NodeB'│           │             │
│  │  │ ... │            │                │  │ ... │            │             │
│  │  │NodeN│ (100万个)  │───复制节点────►│  │NodeN'│           │             │
│  │  └─────┘            │                │  └─────┘            │             │
│  └─────────────────────┘                └─────────────────────┘             │
│                                                                             │
│  时间复杂度: O(n)                                                            │
│  空间复杂度: 内存翻倍                                                         │
│                                                                             │
│  ════════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  OpenCASCADE 的解决方案:                                                     │
│  ──────────────────────                                                      │
│                                                                             │
│  1. 删除拷贝构造函数和赋值运算符                                              │
│     NCollection_BaseMap(const NCollection_BaseMap&) = delete;               │
│     NCollection_BaseMap& operator=(const NCollection_BaseMap&) = delete;    │
│                                                                             │
│  2. 提供显式的 Assign() 方法（派生类实现）                                    │
│     void Assign(const NCollection_DataMap& theOther);  // 显式调用          │
│                                                                             │
│  3. 支持移动语义（零拷贝转移）                                                │
│     NCollection_BaseMap(NCollection_BaseMap&& theOther) noexcept;           │
│                                                                             │
│  好处:                                                                       │
│  ✓ 编译期防止意外拷贝                                                        │
│  ✓ 强制开发者思考是否真的需要拷贝                                            │
│  ✓ 移动语义实现高效的所有权转移                                              │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 0.7 为什么使用素数作为桶数量？

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                            素数桶减少哈希冲突                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  哈希计算: bucket = hashCode % myNbBuckets                                   │
│                                                                             │
│  ════════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  反例: 使用 2 的幂作为桶数量 (如 myNbBuckets = 16)                           │
│  ─────────────────────────────────────────────────                           │
│                                                                             │
│  假设 hashCode 有规律: 0, 16, 32, 48, 64, 80, ...                           │
│                                                                             │
│  bucket = 0 % 16 = 0                                                        │
│  bucket = 16 % 16 = 0                                                       │
│  bucket = 32 % 16 = 0     ──────► 全部落在同一个桶！                         │
│  bucket = 48 % 16 = 0                                                       │
│  bucket = 64 % 16 = 0                                                       │
│                                                                             │
│  桶分布:                                                                     │
│  ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐         │
│  │███│   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │         │
│  │███│   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │         │
│  │███│   │   │   │   │   │   │   │   │   │   │   │   │   │   │   │         │
│  └───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘         │
│    0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15            │
│                                                                             │
│  ❌ 严重不均匀，链表过长，查找退化为 O(n)                                     │
│                                                                             │
│  ════════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  使用素数作为桶数量 (如 myNbBuckets = 17)                                    │
│  ─────────────────────────────────────────                                   │
│                                                                             │
│  bucket = 0 % 17 = 0                                                        │
│  bucket = 16 % 17 = 16                                                      │
│  bucket = 32 % 17 = 15    ──────► 分散到不同的桶                             │
│  bucket = 48 % 17 = 14                                                      │
│  bucket = 64 % 17 = 13                                                      │
│                                                                             │
│  桶分布:                                                                     │
│  ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐     │
│  │ █ │   │   │   │   │   │   │   │   │   │   │   │   │ █ │ █ │ █ │ █ │     │
│  └───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘     │
│    0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16        │
│                                                                             │
│  ✓ 分布均匀，链表短，查找保持 O(1)                                           │
│                                                                             │
│  ════════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  NextPrimeForMap() 函数作用:                                                 │
│  ────────────────────────────                                                │
│                                                                             │
│      输入 N ──────► 返回大于 N 的最小素数                                    │
│                                                                             │
│      例如: NextPrimeForMap(100) ──► 101                                     │
│            NextPrimeForMap(1000) ──► 1009                                   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 0.8 设计决策总结

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        NCollection_BaseMap 设计决策总结                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────────┬────────────────────────┬──────────────────────────┐    │
│  │     设计决策     │       解决的问题        │         带来的好处        │    │
│  ├─────────────────┼────────────────────────┼──────────────────────────┤    │
│  │ 抽象基类设计     │ 多种Map类型代码重复     │ 代码复用、统一维护       │    │
│  ├─────────────────┼────────────────────────┼──────────────────────────┤    │
│  │ 链地址法         │ 哈希冲突处理            │ 删除简单、指针稳定       │    │
│  ├─────────────────┼────────────────────────┼──────────────────────────┤    │
│  │ 双桶数组         │ 双向查找需求            │ 两个方向都是 O(1)        │    │
│  ├─────────────────┼────────────────────────┼──────────────────────────┤    │
│  │ 禁止拷贝         │ 意外深拷贝性能问题      │ 编译期错误、强制显式     │    │
│  ├─────────────────┼────────────────────────┼──────────────────────────┤    │
│  │ 支持移动语义     │ 高效所有权转移          │ 零拷贝、性能优化         │    │
│  ├─────────────────┼────────────────────────┼──────────────────────────┤    │
│  │ 素数桶数量       │ 哈希分布不均            │ 减少冲突、性能稳定       │    │
│  ├─────────────────┼────────────────────────┼──────────────────────────┤    │
│  │ 自定义分配器     │ 内存管理灵活性          │ 可用于特殊内存场景       │    │
│  ├─────────────────┼────────────────────────┼──────────────────────────┤    │
│  │ 内嵌 Iterator   │ 统一遍历接口            │ 所有派生类共享迭代逻辑   │    │
│  └─────────────────┴────────────────────────┴──────────────────────────┘    │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 1. 概述

`NCollection_BaseMap` 是 OpenCASCADE 中所有 Map 容器类的基类，采用**哈希表 + 链地址法**实现。

### 派生类继承关系

```
                    NCollection_BaseMap
                           │
       ┌───────────────────┼───────────────────┐
       │                   │                   │
       ▼                   ▼                   ▼
    NCollection_Map   NCollection_DataMap   NCollection_DoubleMap
       │                   │                   │
       ▼                   ▼                   ▼
 NCollection_IndexedMap  NCollection_IndexedDataMap
```

**支持的Map类型**：
| 类型 | 描述 | isDouble |
|------|------|----------|
| Map | 单键集合 (Set) | false |
| DataMap | 键值对映射 | false |
| DoubleMap | 双向映射（两个键互相映射） | true |
| IndexedMap | 带索引的键集合 | true |
| IndexedDataMap | 带索引的键值对 | true |

---

## 2. 内存布局图

```
┌─────────────────────────────────────────────────────────────────┐
│                    NCollection_BaseMap 对象                      │
├─────────────────────────────────────────────────────────────────┤
│  myAllocator   │ Handle(NCollection_BaseAllocator) │ 内存分配器  │
├─────────────────────────────────────────────────────────────────┤
│  myData1       │ NCollection_ListNode**            │ 主桶数组    │
├─────────────────────────────────────────────────────────────────┤
│  myData2       │ NCollection_ListNode**            │ 辅桶数组    │
├─────────────────────────────────────────────────────────────────┤
│  myNbBuckets   │ Standard_Integer                  │ 桶数量      │
├─────────────────────────────────────────────────────────────────┤
│  mySize        │ Standard_Integer                  │ 元素个数    │
├─────────────────────────────────────────────────────────────────┤
│  isDouble      │ Standard_Boolean                  │ 是否双Map   │
└─────────────────────────────────────────────────────────────────┘
```

---

## 3. 哈希表结构图（链地址法）

### 3.1 单向Map结构 (isDouble = false)

```
myData1 (主桶数组)
┌──────────────────────────────────────────────────────────────────┐
│                                                                  │
│  Index   Bucket                  链表节点                        │
│  ─────   ──────                  ─────────                        │
│                                                                  │
│    0  ─► nullptr                                                 │
│                                                                  │
│    1  ─► ┌─────────┐    ┌─────────┐                             │
│          │ Node A  │───►│ Node B  │───► nullptr                  │
│          │ Key=5   │    │ Key=12  │                              │
│          └─────────┘    └─────────┘                              │
│                                                                  │
│    2  ─► nullptr                                                 │
│                                                                  │
│    3  ─► ┌─────────┐                                            │
│          │ Node C  │───► nullptr                                 │
│          │ Key=7   │                                             │
│          └─────────┘                                             │
│                                                                  │
│    4  ─► nullptr                                                 │
│                                                                  │
│   ...                                                            │
│                                                                  │
│    N  ─► ┌─────────┐    ┌─────────┐    ┌─────────┐              │
│          │ Node D  │───►│ Node E  │───►│ Node F  │───► nullptr   │
│          │ Key=9   │    │ Key=21  │    │ Key=33  │               │
│          └─────────┘    └─────────┘    └─────────┘               │
│                                                                  │
└──────────────────────────────────────────────────────────────────┘
myNbBuckets = N (桶数量)
mySize = 实际存储的节点数量
```

### 3.2 双向Map结构 (isDouble = true)

```
用于 DoubleMap、IndexedMap、IndexedDataMap

myData1 (主桶数组 - 按Key1哈希)         myData2 (辅桶数组 - 按Key2/Index哈希)
┌─────────────────────────────────┐      ┌─────────────────────────────────┐
│  [0] ─► nullptr                 │      │  [0] ─► nullptr                 │
│                                 │      │                                 │
│  [1] ─► Node A ─► Node B        │      │  [1] ─► Node C                  │
│              │          │       │      │              │                  │
│  [2] ─► nullptr         │       │      │  [2] ─► Node A ─► Node D        │
│                         │       │      │                                 │
│  [3] ─► Node C ─────────┘       │      │  [3] ─► Node B                  │
│                                 │      │                                 │
└─────────────────────────────────┘      └─────────────────────────────────┘

                    同一个 Node 可能出现在两个桶数组中
                    通过两种方式查找同一个节点
```

---

## 4. NCollection_ListNode 节点结构

```
┌─────────────────────────────────────────┐
│         NCollection_ListNode            │
├─────────────────────────────────────────┤
│  myNext  │ NCollection_ListNode* │ 下一节点指针
├─────────────────────────────────────────┤
│  （派生类的数据成员）                    │
│  例如：                                  │
│    - MapNode: TheKeyType myKey          │
│    - DataMapNode: TheKeyType myKey      │
│                   TheItemType myValue   │
└─────────────────────────────────────────┘
```

---

## 5. Iterator 迭代器工作原理

### 5.1 迭代器结构

```
┌─────────────────────────────────────────┐
│          Iterator 内部状态               │
├─────────────────────────────────────────┤
│  myNbBuckets │ 总桶数                    │
│  myBuckets   │ 指向 myData1 的指针       │
│  myBucket    │ 当前桶索引                │
│  myNode      │ 当前节点指针              │
└─────────────────────────────────────────┘
```

### 5.2 迭代过程示意图

```
初始状态: myBucket = -1, myNode = nullptr

调用 PNext() 后的遍历顺序:

┌─────────────────────────────────────────────────────────────┐
│                                                             │
│   Bucket 0: nullptr  ──────────────────────► 跳过          │
│                                                             │
│   Bucket 1: Node A ─► Node B ─► nullptr                    │
│             ▲         ▲                                     │
│             │         │                                     │
│             ①         ②   (依次访问链表中的每个节点)        │
│                                                             │
│   Bucket 2: nullptr  ──────────────────────► 跳过          │
│                                                             │
│   Bucket 3: Node C ─► nullptr                               │
│             ▲                                               │
│             ③                                               │
│                                                             │
│   Bucket N: Node D ─► Node E ─► nullptr                     │
│             ▲         ▲                                     │
│             ④         ⑤                                     │
│                                                             │
└─────────────────────────────────────────────────────────────┘

遍历结束条件: myBucket > myNbBuckets && myNode == nullptr
```

### 5.3 PNext() 算法流程

```
┌─────────────────────────┐
│       PNext()           │
└───────────┬─────────────┘
            ▼
    ┌───────────────┐
    │ myBuckets 为空?│
    └───────┬───────┘
            │ 是
            ▼
       ┌─────────┐
       │ 返回    │
       └─────────┘
            │ 否
            ▼
    ┌───────────────┐
    │ myNode 非空?  │────────────────────┐
    └───────┬───────┘                    │ 是
            │ 否                         ▼
            │                   ┌─────────────────┐
            │                   │myNode = myNode->│
            │                   │   Next()        │
            │                   └────────┬────────┘
            │                            ▼
            │                   ┌─────────────────┐
            │                   │ myNode 非空?    │
            │                   └────────┬────────┘
            │                            │ 是
            │                            ▼
            │                      ┌──────────┐
            │                      │  返回    │
            │                      └──────────┘
            │                            │ 否
            ▼                            │
    ┌───────────────────────────────────────────┐
    │         while (myNode == nullptr)          │
    │  ┌─────────────────────────────────────┐  │
    │  │  myBucket++                         │  │
    │  │  if (myBucket > myNbBuckets) return │  │
    │  │  myNode = myBuckets[myBucket]       │  │
    │  └─────────────────────────────────────┘  │
    └───────────────────────────────────────────┘
```

---

## 6. 哈希与碰撞处理

### 6.1 元素查找过程

```
                    查找 Key
                        │
                        ▼
            ┌───────────────────────┐
            │  计算哈希值           │
            │  hashCode = Hash(Key) │
            └───────────┬───────────┘
                        │
                        ▼
            ┌───────────────────────┐
            │  计算桶索引           │
            │  bucket = hashCode %  │
            │          myNbBuckets  │
            └───────────┬───────────┘
                        │
                        ▼
            ┌───────────────────────┐
            │  获取桶头节点         │
            │  node = myData1[bucket]│
            └───────────┬───────────┘
                        │
                        ▼
            ┌───────────────────────┐
            │  遍历链表             │
            │  while (node != null) │◄────────────┐
            │    if (node.key == Key)            │
            │      return node      │            │
            │    node = node->Next()│────────────┘
            │  end while            │
            └───────────┬───────────┘
                        │
                        ▼
                ┌───────────────┐
                │  返回 nullptr │
                │  (未找到)     │
                └───────────────┘
```

### 6.2 Resize（扩容）机制

```
触发条件: mySize > myNbBuckets (负载因子 > 1)

┌─────────────────────────────────────────────────────────────┐
│                     Resize 过程                              │
│                                                              │
│  1. BeginResize(NbBuckets, NewBuckets, data1, data2)        │
│     └─► 计算新的桶数量 (NextPrimeForMap)                    │
│     └─► 分配新的桶数组                                       │
│                                                              │
│  2. 重新哈希所有节点                                         │
│     └─► 遍历旧桶数组                                         │
│     └─► 计算每个节点在新桶中的位置                           │
│     └─► 插入到新桶数组                                       │
│                                                              │
│  3. EndResize(NbBuckets, NewBuckets, data1, data2)          │
│     └─► 释放旧桶数组                                         │
│     └─► 更新 myData1, myData2, myNbBuckets                  │
│                                                              │
└─────────────────────────────────────────────────────────────┘

桶数量选择: 使用素数以减少哈希冲突
NextPrimeForMap() 返回大于 N 的最小素数
```

---

## 7. 关键方法说明

### 7.1 公共接口

```cpp
// 获取桶数量
Standard_Integer NbBuckets() const noexcept;

// 获取元素数量
Standard_Integer Extent() const noexcept;

// 判断是否为空
Standard_Boolean IsEmpty() const noexcept;

// 输出统计信息
void Statistics(Standard_OStream& S) const;

// 获取内存分配器
const Handle(NCollection_BaseAllocator)& Allocator() const noexcept;
```

### 7.2 保护方法（供派生类使用）

```cpp
// 判断是否需要扩容
Standard_Boolean Resizable() const noexcept;

// 增加元素计数
Standard_Integer Increment() noexcept;

// 减少元素计数
Standard_Integer Decrement() noexcept;

// 销毁所有节点
void Destroy(NCollection_DelMapNode fDel, Standard_Boolean doReleaseMemory);

// 计算下一个素数
Standard_Integer NextPrimeForMap(const Standard_Integer N) const noexcept;

// 交换两个Map的内容
void exchangeMapsData(NCollection_BaseMap& theOther) noexcept;
```

---

## 8. 单Map vs 双Map对比

```
┌────────────────────────────────────────────────────────────────────┐
│                        单Map (single = true)                       │
├────────────────────────────────────────────────────────────────────┤
│  - 只使用 myData1                                                  │
│  - myData2 = nullptr                                               │
│  - isDouble = false                                                │
│  - 适用于: Map, DataMap                                            │
│                                                                    │
│  查找: O(1) 平均, O(n) 最差                                        │
└────────────────────────────────────────────────────────────────────┘

┌────────────────────────────────────────────────────────────────────┐
│                        双Map (single = false)                      │
├────────────────────────────────────────────────────────────────────┤
│  - 同时使用 myData1 和 myData2                                     │
│  - 支持双向查找                                                    │
│  - isDouble = true                                                 │
│  - 适用于: DoubleMap, IndexedMap, IndexedDataMap                   │
│                                                                    │
│  myData1: 按 Key1/Key 哈希索引                                     │
│  myData2: 按 Key2/Index 哈希索引                                   │
│                                                                    │
│  两个方向的查找都是: O(1) 平均, O(n) 最差                          │
└────────────────────────────────────────────────────────────────────┘
```

---

## 9. 移动语义支持

```cpp
// 移动构造函数
NCollection_BaseMap(NCollection_BaseMap&& theOther) noexcept
{
    // 转移所有资源
    myAllocator = theOther.myAllocator;
    myData1 = theOther.myData1;
    myData2 = theOther.myData2;
    myNbBuckets = theOther.myNbBuckets;
    mySize = theOther.mySize;

    // 清空源对象
    theOther.myData1 = nullptr;
    theOther.myData2 = nullptr;
    theOther.mySize = 0;
    theOther.myNbBuckets = 0;
}

// 禁止拷贝
NCollection_BaseMap(const NCollection_BaseMap&) = delete;
NCollection_BaseMap& operator=(const NCollection_BaseMap&) = delete;
NCollection_BaseMap& operator=(NCollection_BaseMap&&) = delete;
```

**设计说明**：
- 支持移动构造以实现零拷贝转移
- 禁止拷贝操作，避免意外的深拷贝开销
- 派生类可以实现自己的 Assign() 方法进行深拷贝

---

## 10. 使用示例概念图

```
// 假设我们有 NCollection_DataMap<int, string>

┌──────────────────────────────────────────────────────────────────┐
│                                                                  │
│   DataMap.Bind(5, "five")                                        │
│           │                                                      │
│           ▼                                                      │
│   hashCode = Hash(5) = 1234567                                   │
│   bucket = 1234567 % myNbBuckets = 3                             │
│           │                                                      │
│           ▼                                                      │
│   ┌─────────────────────────────────────────────────────────┐    │
│   │  myData1[3] ─► existing_node ─► nullptr                │    │
│   │                     │                                   │    │
│   │                     ▼                                   │    │
│   │  myData1[3] ─► new_node(5,"five") ─► existing_node     │    │
│   └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│   mySize++                                                       │
│                                                                  │
└──────────────────────────────────────────────────────────────────┘

// 查找 DataMap.Find(5)

┌──────────────────────────────────────────────────────────────────┐
│                                                                  │
│   bucket = Hash(5) % myNbBuckets = 3                             │
│           │                                                      │
│           ▼                                                      │
│   node = myData1[3]                                              │
│   while (node != nullptr)                                        │
│     if (node->Key == 5)                                          │
│       return node->Value  ───────────► "five"                    │
│     node = node->Next()                                          │
│                                                                  │
└──────────────────────────────────────────────────────────────────┘
```

---

## 11. 性能特性总结

| 操作 | 平均时间复杂度 | 最差时间复杂度 | 说明 |
|------|----------------|----------------|------|
| 插入 | O(1) | O(n) | 可能触发扩容 |
| 查找 | O(1) | O(n) | 哈希冲突时退化 |
| 删除 | O(1) | O(n) | 需遍历链表 |
| 遍历 | O(n) | O(n + m) | n=元素数, m=桶数 |

**空间复杂度**: O(n + m)，其中 n 为元素数量，m 为桶数量

---

## 12. 源码位置

- 头文件: `opencascade/NCollection_BaseMap.hxx`
- 实现文件: `NCollection_BaseMap.cxx`

---

*分析日期: 2024-12-25*
*基于 OpenCASCADE 7.x 版本*
