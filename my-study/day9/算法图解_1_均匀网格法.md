# 解法一：均匀网格法 —— 图解详解

## 一句话概括

**把空间切成棋盘格，记住每个格子里有哪些多边形，查询时只检查直线经过的格子。**

---

## 生活中的类比

想象你是一个快递员，要在一个大城市找某条街道。

**暴力方法**：开车把整个城市跑一遍（太慢！）

**均匀网格方法**：
1. 把城市划分成若干个区（如"朝阳区"、"海淀区"）
2. 查地图知道街道在哪个区
3. 只在那个区里找（快多了！）

---

## 图解算法流程

### 第一步：构建网格

```
原始多边形分布：                    覆盖均匀网格：

    ╱╲      ╱╲                    ┌───┬───┬───┬───┐
   ╱  ╲    ╱  ╲                   │ ╱╲│   │╱╲ │   │
  ╱    ╲  ╱    ╲                  │╱  ╲│   ╱  ╲│   │
 ╱──────╲╱──────╲       →        ├───┼───┼───┼───┤
    ╱╲      ╱╲                    │ ╱╲│   │╱╲ │   │
   ╱  ╲    ╱  ╲                   │╱  ╲│   ╱  ╲│   │
  ╱    ╲  ╱    ╲                  ├───┼───┼───┼───┤
                                  │   │   │   │   │
                                  └───┴───┴───┴───┘
```

### 第二步：注册多边形到格子

每个多边形的包围盒覆盖了哪些格子，就注册到哪些格子：

```
三角形 T 的包围盒：
        ┌─────────┐
        │    ╱╲   │
        │   ╱  ╲  │
        │  ╱    ╲ │
        │ ╱──────╲│
        └─────────┘

这个包围盒覆盖了 4 个格子：

        ┌───┬───┐
        │ T │ T │   ← 格子 (0,1) 和 (1,1)
        ├───┼───┤
        │ T │ T │   ← 格子 (0,0) 和 (1,0)
        └───┴───┘

所以：
  grid[0][0].add(T)
  grid[0][1].add(T)
  grid[1][0].add(T)
  grid[1][1].add(T)
```

### 第三步：查询（DDA 算法）

给定直线 AB，沿着它"走"，记录经过的格子：

```
    A●─────────────────────────●B
     ╲                        ╱
      ╲                      ╱
       ╲                    ╱
        ╲                  ╱

    ┌───┬───┬───┬───┬───┬───┐
    │   │   │   │   │   │ ● │ B
    ├───┼───┼───┼───┼●──┼───┤
    │   │   │   │ ● │   │   │
    ├───┼───┼───┼●──┼───┼───┤   经过的格子：
    │   │   │ ● │   │   │   │   用 ● 标记
    ├───┼───┼●──┼───┼───┼───┤
    │   │ ● │   │   │   │   │
    ├───┼●──┼───┼───┼───┼───┤
    │ ● │   │   │   │   │   │ A
    └───┴───┴───┴───┴───┴───┘
```

**DDA 采样过程**：

```cpp
// 计算步数（确保不遗漏格子）
int steps = 直线长度 / 最小格子尺寸 * 2;

for (int s = 0; s <= steps; s++) {
    // 计算采样点位置
    double t = s / (double)steps;  // t 从 0 到 1
    double x = A.x + t * (B.x - A.x);
    double y = A.y + t * (B.y - A.y);

    // 找到采样点所在的格子
    int i = (x - 网格左边界) / 格子宽度;
    int j = (y - 网格下边界) / 格子高度;

    // 收集这个格子里的多边形
    候选集.add_all(grid[i][j]);
}
```

### 第四步：精确测试

对候选集中的每个多边形，做精确的直线-多边形相交测试：

```
候选多边形：{T1, T2, T3, T4, T5}

           直线
    T1      ╱
     ╱╲    ╱   T3        T1: 相交 ✓
    ╱  ╲  ╱    ╱╲        T2: 不相交 ✗
   ╱────╲╱────╱──╲       T3: 相交 ✓
          ╱╲    ╱╲       T4: 相交 ✓
         ╱T2╲  ╱T4╲      T5: 不相交 ✗
              ╱T5 ╲
```

---

## 关键代码解读

### 坐标转格子索引

```cpp
pair<int, int> getCellIndex(double x, double y) {
    // 相对于网格原点的偏移
    double dx = x - globalMinX;
    double dy = y - globalMinY;

    // 除以格子尺寸，向下取整
    int i = (int)(dx / cellWidth);
    int j = (int)(dy / cellHeight);

    // 边界保护
    i = max(0, min(i, gridNx - 1));
    j = max(0, min(j, gridNy - 1));

    return {i, j};
}
```

**图解**：

```
    globalMinY + 3*cellHeight ─┬───────────────────┬─
                               │ (0,2) │ (1,2) │ (2,2) │
    globalMinY + 2*cellHeight ─┼───────┼───────┼───────┤
                               │ (0,1) │ (1,1) │ (2,1) │
    globalMinY + 1*cellHeight ─┼───────┼───────┼───────┤
                               │ (0,0) │ (1,0) │ (2,0) │
    globalMinY ───────────────┴───────┴───────┴───────┘
                               │       │       │       │
                          globalMinX  +cW     +2cW    +3cW

点 (x, y) 的格子索引：
  i = floor((x - globalMinX) / cellWidth)
  j = floor((y - globalMinY) / cellHeight)
```

### 直线与包围盒相交

```cpp
bool lineIntersectsBox(Point2D p1, Point2D p2,
                       double minX, double minY,
                       double maxX, double maxY) {
    // 快速排除：直线完全在盒子外面
    if (max(p1.x, p2.x) < minX) return false;  // 直线在左边
    if (min(p1.x, p2.x) > maxX) return false;  // 直线在右边
    if (max(p1.y, p2.y) < minY) return false;  // 直线在下边
    if (min(p1.y, p2.y) > maxY) return false;  // 直线在上边

    // 检查与四条边的相交
    // ...
}
```

**快速排除示意**：

```
直线在盒子左边（不相交）：     直线可能相交：

     ╲                              ╲
      ╲   ┌───────┐                  ╲ ┌───────┐
       ╲  │ 盒子  │                   ╲│       │
        ╲ │       │                    ╲       │
         ╲└───────┘                     ╲──────┘
          ╲                              ╲
```

---

## 参数选择建议

### 格子数量怎么选？

```
太少的格子：                    太多的格子：
┌─────────────────┐            ┌─┬─┬─┬─┬─┬─┬─┬─┐
│ △ △ △ △ △ △     │            │△│ │ │△│ │ │ │ │
│ △ △ △ △ △ △     │            ├─┼─┼─┼─┼─┼─┼─┼─┤
│ △ △ △ △ △ △     │            │ │△│ │ │△│ │ │△│
└─────────────────┘            ├─┼─┼─┼─┼─┼─┼─┼─┤
每个格子太多三角形              浪费内存，遍历格子开销大
失去加速效果！                  每个格子很空
```

**经验公式**：

```
gridNx ≈ gridNy ≈ sqrt(面数量)

例如：
- 100 个面 → 10 × 10 网格
- 10000 个面 → 100 × 100 网格
```

---

## 完整工作流程图

```
┌─────────────────────────────────────────────────────────┐
│                     预处理阶段                           │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  ┌─────────┐    ┌─────────────┐    ┌────────────────┐  │
│  │ 所有面   │ → │ 计算全局     │ → │ 确定网格参数    │  │
│  │ 的集合   │    │ 包围盒      │    │ (Nx, Ny, cW, cH)│  │
│  └─────────┘    └─────────────┘    └────────────────┘  │
│                                            ↓            │
│                                    ┌────────────────┐  │
│                                    │ 每个面注册到    │  │
│                                    │ 覆盖的格子      │  │
│                                    └────────────────┘  │
└─────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────┐
│                      查询阶段                            │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  ┌─────────┐    ┌─────────────┐    ┌────────────────┐  │
│  │ 输入直线 │ → │ DDA 遍历     │ → │ 收集候选面     │  │
│  │ (p1, p2) │    │ 经过的格子   │    │ (用 set 去重)  │  │
│  └─────────┘    └─────────────┘    └────────────────┘  │
│                                            ↓            │
│                                    ┌────────────────┐  │
│                                    │ 精确相交测试    │  │
│                                    │ 得到结果       │  │
│                                    └────────────────┘  │
└─────────────────────────────────────────────────────────┘
```

---

## 常见问题

### Q1: 为什么需要用 set 去重？

因为一个大的多边形可能覆盖多个格子，直线经过这些格子时会多次遇到它：

```
┌───┬───┬───┐
│ T │ T │ T │   ← 三角形 T 覆盖 3 个格子
├───┼───┼───┤      直线经过这 3 个格子
│ ● │ ● │ ● │      会 3 次遇到 T
└───┴───┴───┘      用 set 只保留 1 个
```

### Q2: DDA 的步数怎么确定？

要确保不遗漏任何格子：

```
步长 < min(格子宽度, 格子高度)

步数 = 直线长度 / 步长
     = 直线长度 / min(cellWidth, cellHeight)

再乘以 2 留余量，确保安全
```

### Q3: 边界上的点属于哪个格子？

取决于 `(int)` 的截断方向。在边界上的点可能归入相邻的两个格子之一：

```
点正好在边界上：
    ┌───┬───┐
    │   │   │
    ├───●───┤  ← 点 ● 在边界上
    │   │   │     归入左边还是右边？
    └───┴───┘

不用担心！因为相邻格子都会被检查
```

---

## 性能分析

### 最好情况

数据均匀分布，直线短：

```
查询复杂度 ≈ O(1)

直线只经过几个格子
每个格子只有几个面
总共检查 < 10 个面
```

### 最坏情况

数据极度聚集，直线很长：

```
所有面都在一个格子里：

┌───┬───┬───┬───┐
│   │   │   │   │
├───┼───┼───┼───┤
│   │△△△│   │   │  ← 所有面挤在一个格子
│   │△△△│   │   │
├───┼───┼───┼───┤
│   │   │   │   │
└───┴───┴───┴───┘

查询复杂度 = O(n)
失去加速效果
```

---

## 总结

**均匀网格法就像给城市画网格地图**：

1. ✅ 简单直观，容易实现
2. ✅ 对均匀数据效果好
3. ❌ 对聚集数据效果差
4. ❌ 需要手动调参（格子数量）

**适用场景**：
- 数据分布大致均匀
- 追求简单实现
- 对性能要求不是极致

**下一步**：如果数据分布不均匀，考虑使用 R-Tree（自适应）或射线行走（理论最优）。
