# 平面分割与直线相交查询算法详解

## 问题背景

### 什么是平面分割？

想象你有一张纸，用很多线段把它划分成了若干个区域（比如三角形）。这就是**平面分割**。

```
     ┌─────────┬─────────┐
     │ \       │       / │
     │   \  1  │  3  /   │
     │  0  \   │   /  2  │
     ├─────────┼─────────┤
     │ \       │       / │
     │   \  5  │  7  /   │
     │  4  \   │   /  6  │
     └─────────┴─────────┘
```

### 问题是什么？

给定一条直线（比如从左下角到右上角的对角线），我们需要快速找出：**这条直线穿过了哪些多边形？**

### 为什么这个问题重要？

- **网格生成**：判断新的网格点落在哪个单元里
- **碰撞检测**：光线追踪、游戏物理引擎
- **GIS系统**：地图上的路径穿过哪些区域
- **CAD软件**：选择工具需要知道鼠标划过了哪些图形

---

## 三种解法概览

| 解法 | 核心思想 | 优点 | 缺点 |
|------|----------|------|------|
| **解法一：均匀网格** | 把空间切成小格子 | 简单易懂 | 对分布不均匀的数据效果差 |
| **解法二：射线行走** | 沿着直线"走"过去 | 理论最优 | 需要完整的拓扑信息 |
| **解法三：R-Tree** | 用树结构组织空间 | 自适应、工业标准 | 实现稍复杂 |

---

## 公共基础：DCEL（双向连接边表）

在介绍三种算法之前，需要先理解它们共用的数据结构——**DCEL**。

### DCEL 是什么？

DCEL 是存储平面图（由点、边、面组成）的一种巧妙方法。它的核心概念是**半边**。

### 什么是半边？

一条边可以被"拆"成两个方向相反的半边：

```
        A ────────────────> B     （半边 1：从 A 到 B）
        A <──────────────── B     （半边 2：从 B 到 A）
```

### 为什么要用半边？

因为每条边有两侧，可能属于两个不同的多边形：

```
              面 1
         ┌─────────┐
         │    ↑    │
     A ──┼────┼────┼── B
         │    ↓    │
         └─────────┘
              面 2

半边 A→B 属于面 1（在它的上方）
半边 B→A 属于面 2（在它的下方）
```

### DCEL 的三个核心元素

```
┌─────────────────────────────────────────────────────────────┐
│                         顶点 (Vertex)                        │
├─────────────────────────────────────────────────────────────┤
│  - 坐标 (x, y)                                               │
│  - 一条从它出发的半边指针                                      │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│                        半边 (HalfEdge)                       │
├─────────────────────────────────────────────────────────────┤
│  - origin: 起点顶点                                          │
│  - twin: 方向相反的配对半边 ← 【关键！用于跳转到相邻面】         │
│  - next: 同一面上的下一条半边                                  │
│  - prev: 同一面上的上一条半边                                  │
│  - incidentFace: 所属的面                                    │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│                          面 (Face)                          │
├─────────────────────────────────────────────────────────────┤
│  - outerComponent: 边界上的一条半边                           │
│  - 包围盒 (minX, minY, maxX, maxY)                           │
└─────────────────────────────────────────────────────────────┘
```

### 如何遍历一个面的所有边？

```cpp
// 从任意一条边开始
HalfEdge* start = face->outerComponent;
HalfEdge* current = start;

do {
    // 处理当前边...
    Point2D from = current->origin->position;
    Point2D to = current->next->origin->position;

    // 移动到下一条边
    current = current->next;
} while (current != start);  // 回到起点结束
```

这就像沿着多边形的边界走一圈！

---

## 公共基础：核心几何算法

### orient2d：方向判定（计算几何的瑞士军刀）

这是计算几何中最重要的函数，用来判断**点在直线的哪一侧**。

```
            C 在左侧（返回值 > 0）
              •
             /
    A ─────────────→ B
             \
              •
            C 在右侧（返回值 < 0）
```

**数学原理**：计算向量的叉积

```cpp
double orient2d(Point2D a, Point2D b, Point2D c) {
    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
}
```

**几何意义**：
- 返回值是三角形 ABC 有符号面积的两倍
- 正值 → C 在 AB 左侧（逆时针）
- 负值 → C 在 AB 右侧（顺时针）
- 零值 → 三点共线

### 线段相交判定

两条线段相交，当且仅当它们**互相跨越**：

```
        A             A
        │              \
    C───┼───D    C──────X──────D
        │                \
        B                 B

    C和D在AB两侧        A和B在CD两侧
    同时满足才相交！
```

---

## 解法一：DCEL + 均匀网格

### 核心思想

把整个平面切成规整的小方格（像棋盘一样），然后记录每个格子里有哪些多边形。

```
┌───┬───┬───┬───┬───┐
│ 0 │ 1 │ 2 │ 3 │ 4 │
├───┼───┼───┼───┼───┤
│ 5 │ 6 │ 7 │ 8 │ 9 │  ← 每个格子记录覆盖它的多边形
├───┼───┼───┼───┼───┤
│10 │11 │12 │13 │14 │
└───┴───┴───┴───┴───┘
```

### 预处理阶段

1. **计算全局包围盒**：找到所有多边形的坐标范围
2. **确定网格参数**：gridNx × gridNy 个格子
3. **注册多边形**：每个多边形注册到它覆盖的所有格子中

```
多边形 P 的包围盒覆盖了格子 6、7、11、12
→ 把 P 添加到这四个格子的列表中
```

### 查询阶段（DDA 算法）

**DDA（数字微分分析器）**：沿直线采样，找出经过的所有格子

```
直线从 A 到 B：

    ┌───┬───┬───┬───┬───┐
    │   │   │   │   │ B │ ← 终点
    ├───┼───┼───┼───┼●──┤
    │   │   │   │ ● │   │
    ├───┼───┼───┼●──┼───┤
    │   │   │ ● │   │   │
    ├───┼───┼●──┼───┼───┤
    │ A │ ● │   │   │   │ ← 起点
    └───┴───┴───┴───┴───┘

    采样点 ● 经过的格子都要检查！
```

**算法步骤**：
1. 计算直线长度，确定采样步数
2. 沿直线均匀采样
3. 收集所有采样点经过的格子中的多边形（用 set 去重）
4. 对候选多边形做精确相交测试

### 时间复杂度

| 操作 | 复杂度 |
|------|--------|
| 预处理 | O(n × k)，n 是面数，k 是平均每面覆盖的格子数 |
| 查询 | O(L/c × f)，L 是直线长度，c 是格子尺寸，f 是每格平均面数 |

### 优缺点

**优点**：
- ✅ 实现简单，易于调试
- ✅ 对均匀分布的数据效果好

**缺点**：
- ❌ 格子太大：每个格子面太多，失去加速效果
- ❌ 格子太小：占用太多内存，遍历格子开销大
- ❌ 对非均匀分布数据效果差（有些格子很空，有些格子很满）

---

## 解法二：射线行走法（Ray Walking）

### 核心思想

不用额外的空间索引，直接利用 DCEL 的拓扑信息"走"过去！

```
起点在三角形 A 内
    ↓
找到射线穿出 A 的边
    ↓
通过 twin 指针跳到相邻三角形 B
    ↓
继续找穿出边...
    ↓
直到终点或离开网格
```

### 关键洞察

**twin 指针是相邻面之间的桥梁！**

```
         面 1
    ┌─────────┐
    │         │
A ──┼── he1 ──┼── B
    │   ↕↕↕   │      ← twin 指针连接两个相邻面
    │  he2    │
    └─────────┘
         面 2

he1->twin = he2
he2->twin = he1

从面 1 跳到面 2：face2 = he1->twin->incidentFace
```

### 第一步：点定位（Walk 算法）

给定起点 P，找到包含它的三角形：

```cpp
Face* locatePoint(Point2D p) {
    Face* current = 任意一个面;

    while (true) {
        // 计算 P 相对于三条边的位置
        double s0 = orient2d(边0, p);
        double s1 = orient2d(边1, p);
        double s2 = orient2d(边2, p);

        // 如果 P 在所有边的同一侧 → 找到了！
        if (s0 >= 0 && s1 >= 0 && s2 >= 0) {
            return current;
        }

        // 否则，通过"最偏离"的边跳到相邻面
        // 选 orient 值最负的边
        if (s0 最负) {
            current = 边0.twin->incidentFace;
        } else if (s1 最负) {
            current = 边1.twin->incidentFace;
        } else {
            current = 边2.twin->incidentFace;
        }
    }
}
```

**为什么选"最偏离"的边？**

因为 orient 值越负，说明点在那个方向越"远"。往那边走能最快接近目标。

```
          点 P
            •
           /|\
          / | \
         /  |  \   ← P 相对于这条边最"外"
        /   |   \     所以从这里跳出去
       ▼    ▼    ▼
```

### 第二步：射线行走

找到起点所在的面后，开始沿射线"行走"：

```cpp
vector<Face*> rayWalkQuery(Point2D p1, Point2D p2) {
    vector<Face*> result;

    // 1. 定位起点
    Face* current = locatePoint(p1);
    result.push_back(current);

    while (true) {
        // 2. 找射线穿出当前面的边
        HalfEdge* exitEdge = nullptr;
        double minT = 无穷大;

        for (每条边 he) {
            double t = 射线与边的交点参数;
            if (t > 0 && t < minT) {
                minT = t;
                exitEdge = he;
            }
        }

        // 3. 如果 t > 1，说明终点在当前面内，结束
        if (minT > 1) break;

        // 4. 如果没有 twin，说明到达边界，结束
        if (!exitEdge->twin) break;

        // 5. 跳到相邻面
        current = exitEdge->twin->incidentFace;
        result.push_back(current);
    }

    return result;
}
```

### 射线与边的交点计算

```
射线：P(t) = p1 + t × (p2 - p1)，t ∈ [0, 1]
边：  Q(s) = a + s × (b - a)，  s ∈ [0, 1]

      p1 ─────────────→ p2
             •
            /
           /  ← 交点
          /
     a ──────────────── b
```

通过解方程组得到参数 t 和 s，如果都在 [0, 1] 范围内，则有效相交。

### 时间复杂度

| 操作 | 复杂度 |
|------|--------|
| 点定位 | O(√n) 平均，O(n) 最坏 |
| 射线行走 | O(k)，k 是实际穿过的面数 |

**这是输出敏感的最优复杂度！** 只访问真正相交的面。

### 优缺点

**优点**：
- ✅ 理论最优：只访问相交的面
- ✅ 不需要额外空间
- ✅ 对任何分布都有效

**缺点**：
- ❌ 需要正确设置 twin 指针（完整拓扑）
- ❌ 点定位有启动开销

---

## 解法三：R-Tree

### 核心思想

用**树结构**组织空间数据，每个节点代表一个区域（包围盒）。

```
                    [根节点]
                   整个区域
                  /         \
            [子树1]         [子树2]
           左半区域        右半区域
          /    \           /    \
       [面A] [面B]      [面C] [面D]
```

### R-Tree 的核心概念

**MBR（最小包围矩形）**：每个节点都有一个包围盒

```
┌─────────────────────────────┐
│         节点的 MBR           │
│    ┌───────┐                │
│    │ 面 A  │    ┌─────┐    │
│    └───────┘    │ 面 B │    │
│                 └─────┘    │
└─────────────────────────────┘

节点的 MBR 包含其所有子节点/数据的 MBR
```

### R-Tree 的插入

```
要插入新的面 X：

1. 从根节点开始
2. 选择"最佳"子节点（使 MBR 增长最小的）
3. 递归向下，直到叶子节点
4. 插入数据
5. 如果节点满了，分裂节点
6. 分裂可能向上传播
```

**选择子节点的策略**：

```
当前节点有两个子节点：

子节点 1 的 MBR          子节点 2 的 MBR
┌─────────┐              ┌─────────────┐
│         │              │             │
│         │   面 X       │             │
│         │    ●         │             │
└─────────┘              └─────────────┘

插入到子节点 1：MBR 需要扩大很多
插入到子节点 2：MBR 需要扩大较少
→ 选择子节点 2！
```

### R-Tree 的查询

```
查询与矩形 Q 相交的所有面：

1. 从根节点开始
2. 对于每个子节点：
   - 如果子节点 MBR 与 Q 不相交 → 跳过（剪枝！）
   - 如果相交 → 递归进入
3. 到达叶子节点时，收集数据
```

**剪枝的威力**：

```
                    [根节点]
                   /         \
            [子树1]         [子树2]  ← 与查询矩形不相交
           相交！          直接跳过！
          /    \           节省大量时间
       [面A] [面B]

只需要检查子树1，子树2 完全跳过
```

### 直线查询的实现

R-Tree 本身只支持矩形查询，所以：

1. 计算直线的包围盒
2. 用 R-Tree 做矩形查询，得到候选面
3. 对候选面做精确相交测试

```
直线 AB 的包围盒：

    B •
     /
    /
   /
  /
 /
• A

┌─────────────────┐
│       B •       │  ← 直线的包围盒
│      /          │
│     /           │
│    /            │
│   /             │
│  /              │
│ • A             │
└─────────────────┘

用这个矩形做 R-Tree 查询
```

### 时间复杂度

| 操作 | 复杂度 |
|------|--------|
| 构建 | O(n log n) |
| 查询 | O(log n + k)，k 是候选面数 |

### 优缺点

**优点**：
- ✅ 自适应：自动适应数据分布
- ✅ 不需要拓扑信息（twin 指针）
- ✅ 工业标准，广泛使用

**缺点**：
- ❌ 实现比均匀网格复杂
- ❌ 候选面可能略多于实际相交面

---

## 三种方法的对比总结

### 适用场景

| 场景 | 推荐方法 |
|------|----------|
| 数据均匀分布，追求简单 | 均匀网格 |
| 有完整拓扑，追求极致性能 | 射线行走 |
| 通用场景，数据分布不确定 | R-Tree |

### 性能对比（1000 次随机查询，200 个三角形）

```
方法          总耗时      平均每次    加速比（vs 暴力）
─────────────────────────────────────────────────────
暴力方法      ~10000 μs   ~10 μs      1x
均匀网格      ~2000 μs    ~2 μs       5x
射线行走      ~1500 μs    ~1.5 μs     6-7x
R-Tree        ~1800 μs    ~1.8 μs     5-6x
```

### 代码复杂度

```
均匀网格 ≈ 300 行
射线行走 ≈ 400 行（需要正确设置 twin）
R-Tree   ≈ 500 行（树结构操作较多）
```

---
