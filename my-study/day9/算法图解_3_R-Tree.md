# 解法三：R-Tree —— 图解详解

## 一句话概括

**用树结构把空间"分层装箱"，查询时只打开可能相关的箱子。**

---

## 生活中的类比

想象你在一个大仓库里找特定的货物：

**暴力方法**：翻遍仓库每个角落（太慢！）

**R-Tree 方法**：
1. 仓库分成几个大区（A区、B区、C区...）
2. 每个大区分成若干货架
3. 每个货架有若干小格子
4. 你知道要找的货物大概在哪个范围
5. 只检查相关的大区 → 货架 → 格子

```
仓库（根节点）
├── A区（子树1）
│   ├── 货架1
│   │   ├── 格子1 [货物]
│   │   └── 格子2 [货物]
│   └── 货架2
│       └── 格子3 [货物]
└── B区（子树2）
    └── 货架3
        └── 格子4 [货物]  ← 如果要找的东西不在 B区，直接跳过！
```

---

## 核心概念：MBR（最小包围矩形）

每个节点都有一个**包围盒**，包含它下面所有内容：

```
节点的 MBR（最小包围矩形）
┌────────────────────────────────────┐
│                                    │
│    ┌──────────┐                    │
│    │  面 A    │    ┌──────────┐   │
│    │          │    │  面 B    │   │
│    └──────────┘    │          │   │
│                    └──────────┘   │
│                                    │
└────────────────────────────────────┘
         节点的 MBR 包住所有子元素
```

---

## R-Tree 的结构

```
                        [根节点 MBR]
                       整个数据范围
                      /            \
              [子节点1 MBR]      [子节点2 MBR]
              左半部分           右半部分
             /    |    \           |
         [面A] [面B] [面C]      [面D]

每个节点：
- isLeaf：是否是叶子节点
- count：子节点/数据数量
- mbr：自己的包围盒
- childMBR[]：每个子节点的包围盒
- children[] 或 data[]：子节点指针或数据指针
```

### 叶子节点 vs 内部节点

```
内部节点：                        叶子节点：
┌──────────────────┐              ┌──────────────────┐
│ isLeaf = false   │              │ isLeaf = true    │
│ count = 3        │              │ count = 4        │
│ mbr = [整体范围] │              │ mbr = [整体范围] │
│ children[0] = ●──┼──→子树1     │ data[0] = ●──────┼──→面A
│ children[1] = ●──┼──→子树2     │ data[1] = ●──────┼──→面B
│ children[2] = ●──┼──→子树3     │ data[2] = ●──────┼──→面C
└──────────────────┘              │ data[3] = ●──────┼──→面D
                                  └──────────────────┘
```

---

## 插入算法图解

### 目标

把新的面 X 插入到 R-Tree 中，保持树的平衡。

### 步骤1：从根节点开始，选择最佳子节点

**策略**：选择使 MBR 增长最小的子节点

```
根节点有两个子节点：

子节点 1 的 MBR              子节点 2 的 MBR
┌─────────────┐              ┌─────────────────────┐
│    △ △ △    │              │       △ △           │
│    △ △ △    │              │                     │
└─────────────┘              └─────────────────────┘

                    新的面 X
                       ●

如果插入到子节点 1：               如果插入到子节点 2：
┌───────────────────┐            ┌─────────────────────┐
│    △ △ △          │            │       △ △       ●   │
│    △ △ △      ●   │            │                     │
└───────────────────┘            └─────────────────────┘
   MBR 扩大很多！                    MBR 只扩大一点点

选择子节点 2！（面积增量更小）
```

### 步骤2：递归向下，直到叶子节点

```
根节点
   │
   ├─ 选择子节点 2（面积增量最小）
   │
   子节点 2
      │
      ├─ 选择子节点 2.1（面积增量最小）
      │
      叶子节点
         │
         └─ 插入面 X
```

### 步骤3：处理节点分裂

如果叶子节点已满（达到 MAXNODES），需要分裂：

```
分裂前：节点已满，要插入 X

┌────────────────────┐
│ [A] [B] [C] [D] [E]│  ← 已有 5 个（假设 MAXNODES=5）
│        + [X]       │  ← 要插入第 6 个
└────────────────────┘

分裂后：变成两个节点

┌──────────┐  ┌──────────┐
│ [A] [B]  │  │ [C] [D]  │
│ [X]      │  │ [E]      │
└──────────┘  └──────────┘
   节点 1        节点 2（新建）

父节点需要接收新的子节点 2
如果父节点也满了 → 继续向上分裂
```

### 步骤4：分裂传播到根

如果分裂一直传播到根节点：

```
分裂前：
        [根节点已满]
       /  |  |  |  \
      ...          ...

分裂后：
            [新根节点]
           /          \
    [原根节点]     [新节点]
   /  |  |         |  |  \
  ...              ...
```

树的高度增加 1！

---

## 查询算法图解

### 范围查询

给定查询矩形 Q，找出所有与 Q 相交的面。

```
查询矩形 Q
┌─────┐
│     │
└─────┘

R-Tree 结构：
                [根节点 MBR]
               ┌───────────────────────────┐
               │                           │
               └───────────────────────────┘
              /                              \
      [子节点1 MBR]                    [子节点2 MBR]
    ┌───────────┐                    ┌───────────┐
    │ Q相交！   │                    │ Q不相交   │
    └───────────┘                    └───────────┘
   ✓ 继续搜索                        ✗ 跳过！（剪枝）
   /          \
[面A MBR]  [面B MBR]
Q相交！     Q不相交
结果加A      跳过
```

### 查询的递归过程

```cpp
void search(节点, 查询矩形 Q, 结果列表) {
    for (每个子节点/数据 i) {
        if (childMBR[i] 与 Q 相交) {
            if (是叶子节点) {
                结果列表.add(data[i]);  // 添加到结果
            } else {
                search(children[i], Q, 结果列表);  // 递归搜索
            }
        }
        // 如果不相交，直接跳过（剪枝的威力！）
    }
}
```

### 直线查询

R-Tree 本身只支持矩形查询，所以直线查询分两步：

```
步骤 1：计算直线的包围盒

      P2
     ●
    /        直线包围盒
   /         ┌──────────────┐
  /          │      ●P2     │
 /           │     /        │
●P1          │    /         │
             │   /          │
             │  ●P1         │
             └──────────────┘

步骤 2：用包围盒做 R-Tree 查询

得到候选面：{A, B, C, D, E}

步骤 3：对候选面做精确相交测试

A: 直线穿过？ ✓
B: 直线穿过？ ✗
C: 直线穿过？ ✓
D: 直线穿过？ ✗
E: 直线穿过？ ✓

最终结果：{A, C, E}
```

---

## R-Tree 的参数

### MAXNODES（每个节点最多多少个子节点）

```
MAXNODES 太小（如 2）：          MAXNODES 太大（如 100）：

        [根]                           [根]
       /    \                    /||||||||||||||||||\
     [A]    [B]                 很多很多子节点...
    / \     / \
   ... ...  ... ...

树太深！                        节点内搜索太慢！
查询要遍历很多层               每个节点要线性扫描很多项

典型值：4 ~ 16
```

### MINNODES（节点分裂后每部分最少多少个）

```
通常 MINNODES = MAXNODES / 2

确保分裂后两边都不会太空
```

---

## 代码关键部分解读

### MBR 相交判断

```cpp
bool Rect2D::intersects(const Rect2D& other) const {
    // 两个矩形相交 ⟺ 在 x 和 y 两个轴上都有重叠

    // 在 x 轴上分离？
    if (maxX < other.minX) return false;  // 我在它左边
    if (minX > other.maxX) return false;  // 我在它右边

    // 在 y 轴上分离？
    if (maxY < other.minY) return false;  // 我在它下边
    if (minY > other.maxY) return false;  // 我在它上边

    // 都没分离 → 相交！
    return true;
}
```

图解：

```
不相交（x轴分离）：        不相交（y轴分离）：       相交：
┌───┐                    ┌───┐                  ┌───┐
│ A │      ┌───┐         │ A │                  │ A ├──┐
└───┘      │ B │         └───┘                  └───┤ B│
           └───┘              ┌───┐                 └──┘
                              │ B │
                              └───┘
```

### 面积增量计算

```cpp
double Rect2D::enlargement(const Rect2D& other) const {
    // 计算扩展后的边界
    double newMinX = min(minX, other.minX);
    double newMinY = min(minY, other.minY);
    double newMaxX = max(maxX, other.maxX);
    double newMaxY = max(maxY, other.maxY);

    // 扩展后的面积
    double newArea = (newMaxX - newMinX) * (newMaxY - newMinY);

    // 面积增量 = 新面积 - 原面积
    return newArea - area();
}
```

图解：

```
原 MBR：          扩展后：
┌─────┐           ┌──────────┐
│     │           │ 原    新 │
│     │    ●  →   │    ●     │
└─────┘           └──────────┘

面积增量 = 扩展后面积 - 原面积
```

---

## 与均匀网格、射线行走的对比

```
                均匀网格        射线行走         R-Tree
             ──────────────────────────────────────────
空间划分        固定网格        不划分          自适应树
             ┌─┬─┬─┬─┐         不需要        自动调整
             ├─┼─┼─┼─┤
             └─┴─┴─┴─┘

适应性          差              好             很好
            （对聚集数据    （任何分布     （自动适应
             效果差）        都有效）       数据分布）

拓扑需求        不需要        需要 twin       不需要
                            指针

查询复杂度    O(格子数×f)      O(k)         O(log n + k)
             f=每格面数    k=相交面数      k=候选面数

空间复杂度    O(网格大小)     O(1)           O(n)

实现复杂度       简单          中等           中等
```

---

## R-Tree 变体

### R*-Tree（R-star Tree）

改进的 R-Tree，优化：

1. **更好的子节点选择**：不只考虑面积增量，还考虑重叠面积
2. **更好的分裂算法**：最小化总面积和重叠
3. **强制重新插入**：定期重新插入部分节点，优化树结构

### R+-Tree

节点的 MBR 不允许重叠，一个对象可能被存储在多个叶子节点。

### 本实现的简化

我们的实现使用：
- 简单的"最小面积增量"选择策略
- 简单的"二分法"分裂

---

## 完整工作流程图

```
┌─────────────────────────────────────────────────────────┐
│                     构建阶段                             │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  ┌─────────┐    ┌─────────────┐    ┌────────────────┐  │
│  │ 添加面   │ → │ 计算面的     │ → │ 插入到         │  │
│  │ addFace │    │ 包围盒      │    │ R-Tree         │  │
│  └─────────┘    └─────────────┘    └────────────────┘  │
│                                            ↓            │
│                      ┌──────────────────────────────┐  │
│                      │ 可能触发节点分裂和树高增长    │  │
│                      └──────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────┐
│                      查询阶段                            │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  ┌─────────┐    ┌─────────────┐    ┌────────────────┐  │
│  │ 输入直线 │ → │ 计算直线     │ → │ R-Tree 范围    │  │
│  │ (p1, p2) │    │ 包围盒      │    │ 查询           │  │
│  └─────────┘    └─────────────┘    └────────────────┘  │
│                                            ↓            │
│                                    ┌────────────────┐  │
│                                    │ 对候选面做     │  │
│                                    │ 精确相交测试   │  │
│                                    └────────────────┘  │
│                                            ↓            │
│                                    ┌────────────────┐  │
│                                    │ 返回相交的面   │  │
│                                    └────────────────┘  │
└─────────────────────────────────────────────────────────┘
```

---

## 性能分析

### 时间复杂度

| 操作 | 复杂度 | 说明 |
|------|--------|------|
| 插入 | O(log n) | n 是已有的面数 |
| 查询 | O(log n + k) | k 是候选面数 |
| 构建 | O(n log n) | 插入 n 个面 |

### 剪枝效果示例

```
假设有 1000 个面，查询一条短直线

暴力方法：检查 1000 个面

R-Tree（假设每个节点 8 个子节点，树高约 4）：
- 根节点：检查 8 个 MBR，2 个相交
- 第 2 层：检查 2×8 = 16 个 MBR，4 个相交
- 第 3 层：检查 4×8 = 32 个 MBR，8 个相交
- 叶子层：检查 8×8 = 64 个 MBR，10 个相交

总共检查：8 + 16 + 32 + 64 = 120 个 MBR
精确测试：10 个面

vs 暴力的 1000 个 → 约 8-10 倍加速！
```

---

## Gmsh 源码参考

R-Tree 在 Gmsh 中的实现位于：

```
文件：src/common/rtree.h
```

Gmsh 使用 R-Tree 进行：
- 空间查询加速
- 碰撞检测
- 最近邻搜索

---

## 常见问题

### Q1: R-Tree 和 B-Tree 有什么关系？

都是平衡树，但用途不同：
- **B-Tree**：一维数据索引（如数据库主键）
- **R-Tree**：多维数据索引（如空间坐标）

R-Tree 可以看作 B-Tree 在多维空间的推广。

### Q2: 为什么直线查询要先算包围盒？

因为 R-Tree 只支持矩形查询。直线是一维的，需要"升维"到二维矩形才能查询。

```
直线 → 包围盒 → R-Tree 查询 → 候选面 → 精确测试
```

### Q3: 如果所有面都重叠怎么办？

R-Tree 的效率会下降，因为每次查询都要检查很多节点。

这是 R-Tree 的固有局限。对于高度重叠的数据，可以考虑：
- R*-Tree（优化重叠）
- 其他空间索引（如 KD-Tree）

---

## 总结

**R-Tree 就像一个有层次的仓库管理系统**：

1. ✅ 自适应：自动适应数据分布
2. ✅ 不需要拓扑信息
3. ✅ 工业标准，广泛使用
4. ✅ 支持动态插入删除
5. ❌ 实现比均匀网格复杂
6. ❌ 候选面可能略多于实际相交面

**适用场景**：
- 数据分布不确定
- 需要通用的空间索引
- 需要动态更新数据

**核心要点**：
- MBR 是组织空间的基础
- 选择子节点时最小化面积增量
- 查询时通过 MBR 相交判断进行剪枝
- 节点满了就分裂，保持树平衡
