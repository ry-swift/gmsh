# 解法二：射线行走法 —— 图解详解

## 一句话概括

**沿着直线"走"过去，每次穿过一条边就跳到相邻的三角形，直到到达终点。**

---

## 生活中的类比

想象你在一个由多个房间组成的迷宫里走直线：

```
┌─────┬─────┬─────┐
│     │     │     │
│房间1│房间2│房间3│  ← 你要从 A 走到 B
│  A→─┼──→──┼──→B │
└─────┴─────┴─────┘
```

**你的策略**：
1. 从 A 所在的房间（房间1）出发
2. 朝 B 的方向走，穿过一扇门
3. 进入相邻房间（房间2）
4. 继续走，再穿过一扇门
5. 到达 B 所在的房间（房间3）

**关键**：每次穿门时，你知道门那边是哪个房间（这就是 twin 指针的作用！）

---

## 核心概念：twin 指针

### twin 是什么？

每条边有两个"半边"，它们互为 twin：

```
           面 1
      ┌───────────┐
      │           │
  A ──┼── he1 ──→─┼── B     he1: 从 A 到 B，属于面 1
      │           │
      │   ↕ twin  │         he1.twin = he2
      │           │         he2.twin = he1
      │           │
  A ──┼──← he2 ───┼── B     he2: 从 B 到 A，属于面 2
      │           │
      └───────────┘
           面 2
```

### twin 的作用：一步跨越到相邻面

```cpp
// 当前在面 1，想去面 2
Face* 面2 = he1->twin->incidentFace;

// 就这么简单！O(1) 时间！
```

**这就是射线行走高效的秘密！**

---

## 算法分两步

### 第一步：点定位（找起点在哪个三角形）

### 第二步：射线行走（沿直线跳跃前进）

---

## 第一步详解：点定位（Walk 算法）

### 问题

给定点 P，找到包含它的三角形。

### 思路

从任意一个三角形开始，不断"靠近" P，直到找到包含 P 的三角形。

### 核心判断：orient2d

```
点 P 在三角形内部的条件：
P 相对于三条边都在同一侧（都是左侧或都是右侧）

           C
          /\
         /  \
        / P  \    ← P 在所有边的左侧
       /  ●   \      orient(A,B,P) > 0
      /        \     orient(B,C,P) > 0
     A──────────B    orient(C,A,P) > 0
```

### 行走过程图解

```
起始：从三角形 T0 开始，目标是找到包含 P 的三角形

第 1 步：检查 P 相对于 T0 三条边的位置

         T0
        ╱╲
       ╱  ╲         P 在边 AB 的右侧（外侧）
      ╱    ╲        → 通过边 AB 的 twin 跳到 T1
     A──────B
         ↓ twin
     ┌──────┐
     │  T1  │
     └──────┘

第 2 步：检查 P 相对于 T1 三条边的位置

     ┌──────┐
     │  T1  │        P 在边 CD 的右侧（外侧）
     C──────D        → 通过边 CD 的 twin 跳到 T2
         ↓ twin
        ╱╲
       ╱T2╲
      ╱  P ╲         P 在 T2 的所有边内侧
     ╱  ●   ╲        → 找到了！
    ╱────────╲
```

### 选择"最偏离"的边

当 P 在多条边外侧时，选择 orient 值最负的那条边跳过去：

```
         C
        /\
       /  \
      /    \
     /   ●P \      P 在边 AB 外侧：orient(A,B,P) = -5
    A────────B     P 在边 BC 外侧：orient(B,C,P) = -2

选择 AB（orient 值 -5 最负）
→ 往这个方向跳，能更快接近 P
```

### 点定位的代码逻辑

```cpp
Face* locatePoint(Point2D p) {
    Face* current = 任意起始面;

    while (true) {
        // 获取当前三角形的三个顶点
        Vertex* v0 = ...;
        Vertex* v1 = ...;
        Vertex* v2 = ...;

        // 计算 P 相对于三条边的位置
        double s0 = -orient2d(v0, v1, p);  // 边 0
        double s1 = -orient2d(v1, v2, p);  // 边 1
        double s2 = -orient2d(v2, v0, p);  // 边 2

        // 如果都 >= 0，P 在三角形内
        if (s0 >= 0 && s1 >= 0 && s2 >= 0) {
            return current;  // 找到了！
        }

        // 选择最负的边跳过去
        if (s0 最负 && 边0有twin) {
            current = 边0.twin.face;
        } else if (s1 最负 && 边1有twin) {
            current = 边1.twin.face;
        } else if (s2 最负 && 边2有twin) {
            current = 边2.twin.face;
        } else {
            return nullptr;  // P 在平面分割外部
        }
    }
}
```

---

## 第二步详解：射线行走

### 问题

已知起点 P1 所在的三角形，找出射线 P1→P2 穿过的所有三角形。

### 核心操作

在每个三角形中：
1. 找到射线"穿出"的那条边
2. 通过 twin 跳到相邻三角形
3. 重复，直到到达终点或边界

### 找穿出边

```
射线 P1 → P2 在三角形 T 中：

         C
        /\
       /  \
      / ●P1\        射线从 P1 出发
     /   ↘  \       与边 BC 相交
    A────────B      → 边 BC 是穿出边
          ╲
           ╲
            ●P2
```

### 计算射线与边的交点

```
射线：P(t) = P1 + t × (P2 - P1)，t ∈ [0, 1]
边：  Q(s) = A + s × (B - A)，  s ∈ [0, 1]

交点条件：P(t) = Q(s)

解这个方程组得到 t 和 s：
- t > 0：交点在 P1 前方
- t ≤ 1：交点不超过 P2
- s ∈ [0, 1]：交点在边上

选择 t 最小且有效的边 = 穿出边
```

### 行走过程图解

```
射线 P1 → P2：

    ┌─────┬─────┬─────┐
    │  T0 │  T1 │  T2 │
    │     │     │     │
P1 ●──────┼──────┼─────● P2
    │     │     │     │
    └─────┴─────┴─────┘

步骤：
1. 在 T0 中，找穿出边（右边界），t = 0.33
2. 通过 twin 跳到 T1，记录 T1
3. 在 T1 中，找穿出边（右边界），t = 0.67
4. 通过 twin 跳到 T2，记录 T2
5. 在 T2 中，找穿出边，t = 1.2 > 1
6. t > 1 说明 P2 在 T2 内，结束

结果：[T0, T1, T2]
```

### 射线行走的代码逻辑

```cpp
vector<Face*> rayWalkQuery(Point2D p1, Point2D p2) {
    vector<Face*> result;

    // 1. 定位起点
    Face* current = locatePoint(p1);
    if (!current) return result;

    result.push_back(current);

    while (true) {
        // 2. 在当前面中找穿出边
        HalfEdge* exitEdge = nullptr;
        double minT = 无穷大;

        for (当前面的每条边 he) {
            double t = 计算射线与边的交点参数;

            // t > 0：交点在前方
            // t < minT：是最近的交点
            if (t > 0 && t < minT) {
                minT = t;
                exitEdge = he;
            }
        }

        // 3. 判断是否结束
        if (minT > 1) {
            // 终点在当前面内
            break;
        }

        if (!exitEdge || !exitEdge->twin) {
            // 到达边界
            break;
        }

        // 4. 跳到相邻面
        current = exitEdge->twin->incidentFace;
        result.push_back(current);
    }

    return result;
}
```

---

## 关键数学：射线与线段交点

### 问题设定

```
射线：P(t) = P1 + t × d，其中 d = P2 - P1
边：  Q(s) = A + s × e，其中 e = B - A

求交点，即求 t 和 s 使得 P(t) = Q(s)
```

### 推导

```
P1 + t × d = A + s × e

移项：
t × d - s × e = A - P1

写成矩阵形式：
[dx  -ex] [t]   [Ax - P1x]
[dy  -ey] [s] = [Ay - P1y]

用克莱姆法则：
denom = dx × ey - dy × ex  （行列式）

t = ((Ax - P1x) × ey - (Ay - P1y) × ex) / denom
s = ((Ax - P1x) × dy - (Ay - P1y) × dx) / denom
```

### 有效性检查

```
有效交点的条件：
1. denom ≠ 0（射线和边不平行）
2. t > 0（交点在射线前方）
3. t ≤ 1（交点不超过终点）
4. 0 ≤ s ≤ 1（交点在边上）
```

---

## 正确设置 twin 指针

射线行走的前提是 twin 指针正确设置。

### 如何设置 twin？

用一个 map 记录已经遇到的边：

```cpp
map<pair<int,int>, HalfEdge*> edgeMap;

// 添加三角形 (v0, v1, v2) 时
for (每条边 (vi, vj)) {
    // 规范化：小顶点ID在前
    auto key = make_pair(min(vi, vj), max(vi, vj));

    if (edgeMap 中有 key) {
        // 找到配对边！
        HalfEdge* 已有边 = edgeMap[key];
        当前边.twin = 已有边;
        已有边.twin = 当前边;
    } else {
        // 第一次遇到这条边
        edgeMap[key] = 当前边;
    }
}
```

### 图解

```
添加三角形 T0 (顶点 0, 1, 2)：
边 (0,1) → 存入 map
边 (1,2) → 存入 map
边 (2,0) → 存入 map

添加三角形 T1 (顶点 1, 3, 2)：
边 (1,3) → 存入 map
边 (3,2) → 存入 map
边 (2,1) → 规范化为 (1,2)，在 map 中找到！
         → 设置 twin 指针

        0
       /\
      /  \
     / T0 \
    1──────2     ← 边 (1,2) 被 T0 和 T1 共享
     \ T1 /         twin 指针连接它们
      \  /
       \/
        3
```

---

## 性能分析

### 时间复杂度

| 操作 | 复杂度 | 说明 |
|------|--------|------|
| 点定位 | O(√n) 平均 | n 是三角形数 |
| 射线行走 | O(k) | k 是穿过的三角形数 |

### 为什么是 O(k)？

因为每次跳转只需要：
- 遍历 3 条边找穿出边：O(1)
- 通过 twin 跳转：O(1)

总共跳 k 次 → O(k)

### 这是最优的！

k 是输出大小（实际相交的三角形数），算法时间与输出成正比，称为**输出敏感**。

---

## 边界情况处理

### 情况1：起点在平面分割外部

```
      ┌─────────┐
      │ 三角网格 │
      │         │
      └─────────┘
                    ● P1（外部）

处理：遍历边界边，找射线进入的第一个面
```

### 情况2：射线恰好穿过顶点

```
         ●
        /|\
       / | \
      /  |  \
     ●───┼───●
         |
         ↓ 射线

处理：数值容差 EPS 避免精度问题
```

### 情况3：射线与边共线

```
    ●───────────●
          ↑
        射线方向

处理：rayEdgeIntersection 返回 -1（无效）
```

---

## 与均匀网格的对比

```
              均匀网格              射线行走
           ┌──────────┐         ┌──────────┐
起点定位    │   O(1)   │         │  O(√n)   │
           ├──────────┤         ├──────────┤
每步开销    │  遍历格子 │         │   O(1)   │
           │  中的面  │         │ twin跳转 │
           ├──────────┤         ├──────────┤
访问的面    │ 可能有假 │         │ 只访问真 │
           │ 阳性     │         │ 正相交的 │
           ├──────────┤         ├──────────┤
空间开销    │ O(格子数)│         │   O(1)   │
           └──────────┘         └──────────┘
```

---

## 完整工作流程图

```
┌─────────────────────────────────────────────────────────┐
│                     预处理阶段                           │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  ┌─────────┐    ┌─────────────┐    ┌────────────────┐  │
│  │ 添加顶点 │ → │ 添加三角形   │ → │ 设置 twin 指针 │  │
│  │         │    │ (用顶点索引) │    │ (用 edgeMap)  │  │
│  └─────────┘    └─────────────┘    └────────────────┘  │
└─────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────┐
│                      查询阶段                            │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  ┌─────────┐    ┌─────────────┐    ┌────────────────┐  │
│  │ 输入直线 │ → │ 点定位       │ → │ 射线行走       │  │
│  │ (p1, p2) │    │ (Walk算法)  │    │ (沿线跳跃)    │  │
│  └─────────┘    └─────────────┘    └────────────────┘  │
│                                            ↓            │
│                                    ┌────────────────┐  │
│                                    │ 返回穿过的所有 │  │
│                                    │ 三角形列表     │  │
│                                    └────────────────┘  │
└─────────────────────────────────────────────────────────┘
```

---

## Gmsh 源码参考

射线行走在 Gmsh 中的实现位于：

```
文件：src/mesh/meshTriangulation.cpp
函数：Walk（第 395-444 行）
```
